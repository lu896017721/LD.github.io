<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode之每日一题：2022-7-25</title>
    <url>/2022/07/25/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-25/</url>
    <content><![CDATA[<h2 id="问题描述-10">问题描述</h2>
<h3 id="题目：完全二叉树插入器">题目：完全二叉树插入器</h3>
<p>完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>
<p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p>
<p>实现 CBTInserter 类:</p>
<ul>
<li>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；</li>
<li>CBTInserter.insert(int v)  向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值；</li>
<li>CBTInserter.get_root() 将返回树的头节点。</li>
</ul>
<h3 id="示例-13">示例</h3>
<p>1、</p>
<p><img src="/2022/07/25/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-25/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;CBTInserter&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;get_root&quot;]</span><br><span class="line">[[[1, 2]], [3], [4], []]</span><br><span class="line">输出</span><br><span class="line">[null, 1, 2, [1, 2, 3, 4]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">CBTInserter cBTInserter = new CBTInserter([1, 2]);</span><br><span class="line">cBTInserter.insert(3);  // 返回 1</span><br><span class="line">cBTInserter.insert(4);  // 返回 2</span><br><span class="line">cBTInserter.get_root(); // 返回 [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<h3 id="提示-9">提示</h3>
<ul>
<li>树中节点数量范围为 [1, 1000]</li>
<li>0 &lt;= Node.val &lt;= 5000</li>
<li>root 是完全二叉树</li>
<li>0 &lt;= val &lt;= 5000</li>
<li>每个测试用例最多调用 insert 和 get_root 操作 $10^4$ 次</li>
</ul>
<h3 id="来源-13">来源</h3>
<p>来源：力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/complete-binary-tree-inserter">https://leetcode.cn/problems/complete-binary-tree-inserter</a></p>
<h2 id="问题解答-13">问题解答</h2>
<h3 id="思想-6">思想</h3>
<p>三个函数中，最主要是初始化和插入这两个函数，返回根节点可以在初始化时就得到。而初始化也是给插入服务的，所以考虑插入节点需要什么，即找到当前插入的父节点。</p>
<p>完全二叉树是按照从上到下、从左到右依次插入节点，这里有一个规律，每当插入两个节点，其可插入的父节点按照顺序后移一位，如节点1、2、3、4，当插入完2，3节点后，4节点插入的位置为节点2。下面代码的 traverse 函数就是实现本功能。</p>
<h3 id="代码-14">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: TreeNode</span>):</span><br><span class="line">        self.root = root</span><br><span class="line">        self.n, self.nodelist = self.traverse(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, root:TreeNode</span>):</span><br><span class="line">        nodelist = deque([root])</span><br><span class="line">        visiting = deque([root])</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(visiting) &gt; <span class="number">0</span>:</span><br><span class="line">            node = visiting.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                visiting.append(node.left)</span><br><span class="line">                nodelist.append(node.left)</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    visiting.append(node.right)</span><br><span class="line">                    nodelist.append(node.right)</span><br><span class="line">                    n += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                    nodelist.popleft()</span><br><span class="line">                    n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> n, nodelist</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n, nodelist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        node = self.nodelist[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.n == <span class="number">0</span>:</span><br><span class="line">            node.left = TreeNode(val)</span><br><span class="line">            self.nodelist.append(node.left)</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = TreeNode(val)</span><br><span class="line">            self.nodelist.append(node.right)</span><br><span class="line">            self.nodelist.popleft()</span><br><span class="line">            self.n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root</span>(<span class="params">self</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">return</span> self.root</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-7-23</title>
    <url>/2022/07/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-23/</url>
    <content><![CDATA[<h2 id="问题描述-8">问题描述</h2>
<h3 id="题目：摆动排序-II">题目：摆动排序 II</h3>
<p>给定一个长度为 n 的整数数组 nums ，其中 nums 是范围为 [1,n] 的整数的排列。还提供了一个 2D 整数数组 sequences ，其中 sequences[i] 是 nums 的子序列。检查 nums 是否是唯一的最短超序列 。最短超序列是长度最短的序列，并且所有序列 sequences[i] 都是它的子序列。对于给定的数组 sequences ，可能存在多个有效的超序列 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如，对于 sequences = [[1,2],[1,3]] ，有两个最短的 超序列 ，[1,2,3] 和 [1,3,2] 。</span><br><span class="line">而对于 sequences = [[1,2],[1,3],[1,2,3]] ，唯一可能的最短 超序列 是 [1,2,3] 。[1,2,3,4] 是可能的超序列，但不是最短的。</span><br></pre></td></tr></table></figure>
<p>如果 nums 是序列的唯一最短超序列 ，则返回 true ，否则返回 false 。子序列是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p>
<h3 id="示例-11">示例</h3>
<h4 id="1、">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], sequences = [[1,2],[1,3]]</span><br><span class="line">输出：false</span><br><span class="line">解释：有两种可能的超序列：[1,2,3]和[1,3,2]。</span><br><span class="line">序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。</span><br><span class="line">序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。</span><br><span class="line">因为 nums 不是唯一最短的超序列，所以返回false。</span><br></pre></td></tr></table></figure>
<h4 id="2、">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], sequences = [[1,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：最短可能的超序列为 [1,2]。</span><br><span class="line">序列 [1,2] 是它的子序列：[1,2]。</span><br><span class="line">因为 nums 不是最短的超序列，所以返回false。</span><br></pre></td></tr></table></figure>
<h4 id="3、">3、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：true</span><br><span class="line">解释：最短可能的超序列为[1,2,3]。</span><br><span class="line">序列 [1,2] 是它的一个子序列：[1,2,3]。</span><br><span class="line">序列 [1,3] 是它的一个子序列：[1,2,3]。</span><br><span class="line">序列 [2,3] 是它的一个子序列：[1,2,3]。</span><br><span class="line">因为 nums 是唯一最短的超序列，所以返回true。</span><br></pre></td></tr></table></figure>
<h3 id="提示-7">提示</h3>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 104</li>
<li>nums 是 [1, n] 范围内所有整数的排列</li>
<li>1 &lt;= sequences.length &lt;= 104</li>
<li>1 &lt;= sequences[i].length &lt;= 104</li>
<li>1 &lt;= sum(sequences[i].length) &lt;= 105</li>
<li>1 &lt;= sequences[i][j] &lt;= n</li>
<li>sequences 的所有数组都是 唯一 的</li>
<li>sequences[i] 是 nums 的一个子序列</li>
</ul>
<h3 id="来源-11">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/ur2n8P">https://leetcode.cn/problems/ur2n8P</a></p>
<h2 id="问题解答-11">问题解答</h2>
<h3 id="思想：拓扑排序">思想：拓扑排序</h3>
<p>我们把sequences看成是一个有向图，若按照拓扑排序，入度为0的点只有一个，则一定是一个最短的超序列，否则不是。此题也可以理解为，用sequences能不能转化为一个唯一序列。</p>
<p><img src="/2022/07/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-23/1.png" alt="uTools_1658562075174"></p>
<p>思路来源作者 作者：capital-worker，链接：<a href="https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-capital-worker-n6ti/">https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-capital-worker-n6ti/</a></p>
<h4 id="详细：">详细：</h4>
<p>由于 sequences 中的每个序列都是nums 的子序列，因此每个序列中的数字顺序都和 nums 中的数字顺序一致。为了判断 nums 是不是序列的唯一最短超序列，只需要判断根据 sequences 中的每个序列构造超序列的结果是否唯一。</p>
<p>可以将 sequences 中的所有序列看成有向图，数字 1 到 n分别表示图中的 n 个结点，每个序列中的相邻数字表示的结点之间存在一条有向边。根据给定的序列构造超序列等价于有向图的拓扑排序。</p>
<p>首先根据有向边计算每个结点的入度，然后将所有入度为 0 的结点添加到队列中，进行拓扑排序。每一轮拓扑排序时，队列中的元素个数表示可以作为超序列下一个数字的元素个数，根据队列中的元素个数，执行如下操作。</p>
<pre><code>如果队列中的元素个数大于 1，则超序列的下一个数字不唯一，因此 nums 不是唯一的最短超序列，返回 false。

如果队列中的元素个数等于 1，则超序列的下一个数字是队列中唯一的数字。将该数字从队列中取出，将该数字指向的每个数字的入度减 1，并将入度变成 0 的数字添加到队列中。
</code></pre>
<p>重复上述过程，直到出现队列中的元素个数不等于 1 的情况。</p>
<pre><code>如果队列中的元素个数大于 1，则 nums 不是唯一的最短超序列，返回 false。
如果队列为空，则完整的拓扑排序结束，nums 是唯一的最短超序列，返回 true。
</code></pre>
<p>作者：LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/">https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/</a></p>
<h3 id="代码1：">代码1：</h3>
<p>使用二维 n x n 数组来存储 sequences 构成的有向图，以列为入度、行为出度，依次删除入度为 0 的节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sequenceReconstruction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], sequences: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:  </span><br><span class="line">        n = <span class="built_in">len</span>(nums) </span><br><span class="line">        num_list = <span class="built_in">set</span>([])</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> sequences:</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> l:</span><br><span class="line">                num_list.update([a])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num_list) != <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        rudu = np.zeros(shape=(n,n))</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> sequences:</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(l[:-<span class="number">1</span>], l[<span class="number">1</span>:]):</span><br><span class="line">                rudu[i-<span class="number">1</span>,j-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">rudu</span>):</span><br><span class="line">            result = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(np.<span class="built_in">sum</span>(rudu, axis=<span class="number">0</span>)):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                    result.append(i)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dul</span>(<span class="params">rudu, col</span>):</span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(rudu[col,:]):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                rudu[col,i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> rudu</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(rudu)</span><br><span class="line">            <span class="keyword">if</span> rudu.shape[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cols = process(rudu)</span><br><span class="line">            <span class="built_in">print</span>(cols)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cols) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            rudu = dul(rudu, cols[<span class="number">0</span>])</span><br><span class="line">            rudu = np.delete(rudu, cols[<span class="number">0</span>], axis=<span class="number">0</span>)</span><br><span class="line">            rudu = np.delete(rudu, cols[<span class="number">0</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="代码2：">代码2：</h3>
<p>上面采用二维 n x n 数组存有向图，所需的时间和内存很大，而且涉及数组的行列删除，这对于n很大的情况很不友好。下面采用两个列表来简化操作，一个列表用于依次存 1 - n 节点的下一个节点，另一个列表存每个节点的入度为多少，每次将入度为 0 的节点放入q栈里，出栈时，下一个节点的入度减一，然后继续将入度为 0 的节点放入栈里。那么，如果栈里同时有1个以上的节点，说明不是唯一。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sequenceReconstruction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], sequences: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:  </span><br><span class="line">		n = <span class="built_in">len</span>(nums)</span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        inDeg = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> sequence <span class="keyword">in</span> sequences:</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> pairwise(sequence):</span><br><span class="line">                <span class="built_in">print</span>(x,y)</span><br><span class="line">                g[x - <span class="number">1</span>].append(y - <span class="number">1</span>)</span><br><span class="line">                inDeg[y - <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        q = deque([i <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(inDeg) <span class="keyword">if</span> d == <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            x = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                inDeg[y] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDeg[y] == <span class="number">0</span>:</span><br><span class="line">                    q.append(y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作者：LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/">https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-28</title>
    <url>/2022/06/28/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-28/</url>
    <content><![CDATA[<h2 id="问题描述-9">问题描述</h2>
<h3 id="题目：摆动排序-II-2">题目：摆动排序 II</h3>
<p>给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p>
<p>你可以假设所有输入数组都可以得到满足题目要求的结果。</p>
<h3 id="示例-12">示例</h3>
<p>1、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,1,1,6,4]</span><br><span class="line">输出：[1,6,1,5,1,4]</span><br><span class="line">解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,2,2,3,1]</span><br><span class="line">输出：[2,3,1,3,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="提示-8">提示</h3>
<ul>
<li>1 &lt;= nums.length &lt;= 5 * 104</li>
<li>0 &lt;= nums[i] &lt;= 5000</li>
<li>题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果</li>
</ul>
<h3 id="来源-12">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/wiggle-sort-ii">https://leetcode.cn/problems/wiggle-sort-ii</a></p>
<h2 id="问题解答-12">问题解答</h2>
<h3 id="思想-5">思想</h3>
<p>如果将这样的序列隔行取出来可以得到以下两个列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[0]   nums[2]   nums[4]   nums[6]   nums[8]... </span><br><span class="line">nums[1]   nums[3]   nums[5]   nums[7]   nums[9]... </span><br></pre></td></tr></table></figure>
<p>如果这两个序列按照降序排列，即有： nums[1]  &gt; nums[0] ,  nums[1]   nums[3]  , nums[1] &gt; nums[2] ,	因此 nums[1] 为序列的最大值，同理可得 nums[3] 为子序列的最大值。又因为下面一行总比上面一行大，所以下面一行取序列中大数，上面取小数。</p>
<h3 id="代码-13">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleSort</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        numss = nums.copy()</span><br><span class="line">        numss.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(numss)</span><br><span class="line">        mid = <span class="built_in">int</span>((<span class="built_in">len</span>(numss)+<span class="number">1</span>)/<span class="number">2</span>) - <span class="number">1</span> </span><br><span class="line">        n = length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                nums[i] = numss[mid]</span><br><span class="line">                mid = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i] = numss[n]</span><br><span class="line">                n = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-27</title>
    <url>/2022/06/27/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-27/</url>
    <content><![CDATA[<h2 id="问题描述-7">问题描述</h2>
<h3 id="题目：最长特殊序列-II">题目：最长特殊序列 II</h3>
<p>给定字符串列表 strs ，返回其中 最长的特殊序列 。如果最长特殊序列不存在，返回 -1 。</p>
<p>特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。 s 的 子序列可以通过删去字符串 s 中的某些字符实现。例如，“abc” 是 “aebdc” 的子序列，因为您可以删除&quot;aebdc&quot;中的下划线字符来得到 “abc” 。“aebdc&quot;的子序列还包括&quot;aebdc”、 “aeb” 和 “” (空字符串)。</p>
<h3 id="示例-10">示例</h3>
<p>1、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;aba&quot;,&quot;cdc&quot;,&quot;eae&quot;]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;aaa&quot;,&quot;aaa&quot;,&quot;aa&quot;]</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<h3 id="提示-6">提示</h3>
<ul>
<li>2 &lt;= strs.length &lt;= 50</li>
<li>1 &lt;= strs[i].length &lt;= 10</li>
<li>strs[i] 只包含小写英文字母</li>
</ul>
<h3 id="来源-10">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii">https://leetcode.cn/problems/longest-uncommon-subsequence-ii</a></p>
<h2 id="问题解答-10">问题解答</h2>
<p>由题意可知，如果序列中字符串两两不同，那么最长的特殊序列一定是长度最大的，但由于存在相同的情况，所以为了尽快找到最长特殊序列，可以从字符串长度最大的开始，依次判断它是不是其他字符串的子串。</p>
<p>判断是不是子串的方法：双指针法。指针一 i 指向其他字符串的首位置，指针二 j 指向该字符串的首位置，两个位置的字符一样， i 和 j 都加 1 ，否则只有 i 加 1 ，最后如果在指针 i 超出范围前， j 的位置超过了最后一个位置，说明 j 指向的字符串是 i 指向字符串的子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLUSlength</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># str1是不是str2的子串</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isslen</span>(<span class="params">str1, str2</span>):</span><br><span class="line">            <span class="comment"># str1长度比str2大时，肯定不是</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str1) &gt; <span class="built_in">len</span>(str2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str2):</span><br><span class="line">                <span class="keyword">if</span> str2[i] == str1[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == <span class="built_in">len</span>(str1):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">       	<span class="comment"># 按照字符串长度的逆序排列</span></span><br><span class="line">        strs.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> isslen(strs[i], strs[j]):</span><br><span class="line">                    n = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span>            </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(strs[i])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-16</title>
    <url>/2022/06/16/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-16/</url>
    <content><![CDATA[<h2 id="问题描述-11">问题描述</h2>
<h3 id="题目：数组中的-k-diff-数对">题目：数组中的 k-diff 数对</h3>
<p>给你一个整数数组 nums 和一个整数 k，请你在数组中找出 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。k-diff 数对定义为一个整数对 (nums[i], nums[j]) ，并满足下述全部条件：</p>
<ul>
<li>
<p>0 &lt;= i, j &lt; nums.length</p>
</li>
<li>
<p>i != j</p>
</li>
<li>
<p>nums[i] - nums[j] == k</p>
<p>注意，|val| 表示 val 的绝对值。</p>
</li>
</ul>
<h3 id="示例-14">示例</h3>
<ol>
<li></li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3, 1, 4, 1, 5], k = 2</span><br><span class="line"></span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3, 4, 5], k = 1</span><br><span class="line"></span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li></li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 3, 1, 5, 4], k = 0</span><br><span class="line"></span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">解释：数组中只有一个 0-diff 数对，(1, 1) 。</span><br></pre></td></tr></table></figure>
<h3 id="提示-10">提示</h3>
<ul>
<li>1 &lt;= nums.length &lt;= $10^4$</li>
<li>$-10^7$ &lt;= nums[i] &lt;= $10^7$</li>
<li>0 &lt;= k &lt;= $10^7$</li>
</ul>
<h3 id="来源-14">来源</h3>
<p>力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/k-diff-pairs-in-an-array">https://leetcode.cn/problems/k-diff-pairs-in-an-array</a></p>
<h2 id="问题解答-14">问题解答</h2>
<h3 id="双指针法">双指针法</h3>
<p>对于乱序的列表进行处理，可能只能暴力穷举，但如果是排好序的列表，如从高到低排好序，位置i和位置j（j &gt; i）的差小于 k ，那么 i 与 j 之间的数都不会间隔 k ， 等于 k 的数只会在 j 的后面（固定 i ），如果大于 k ，那么等于 k 的数就会在 i 的前面（固定 j ）。如果等于 k ，那么这就是一对满足条件的数对。移动 i ，那么就可以找到所有满足条件的数对。</p>
<h3 id="代码-15">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPairs</span>(<span class="params">self, nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        result = <span class="built_in">set</span>() <span class="comment"># 这样避免重复数对</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[i] - nums[j] &gt; k:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= j :</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] - nums[j] &lt; k:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.add((nums[j],nums[i]))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= j :</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(result) </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Python连接MySQL数据库</title>
    <url>/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1>01 MySQL安装和设置</h1>
<p>这里不详细介绍，可以参考B站视频：<a href="https://www.bilibili.com/video/BV12b411K7Zu?spm_id_from=333.337.search-card.all.click">MySQL_基础+高级篇- 数据库 -sql -mysql教程_mysql视频_mysql入门_尚硅谷</a></p>
<h1>02 Python操作MySQL</h1>
<p>目前，关于Python操作数据库主要有以下几种方法：</p>
<ul>
<li><strong>MySQLdb的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQLdb是用于Python连接MySQL数据库的接口，它实现了Python数据库API规范V2.0，基于MySQL C API上建立的，目前只支持Python2.x。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>PyMySQL的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PyMySQL是Python中用于连接MySQL服务器的一个库，它支持Python3.x，是一个纯Python写的MySQL客户端，它的目标是替代MySQLdb。PyMySQL在MIT许可下发布。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>mysql.connector 的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</span><br><span class="line"></span><br><span class="line">目前，有两个 MySQL 驱动：</span><br><span class="line"></span><br><span class="line">1. mysql-connector-python：是 MySQL 官方的纯 Python 驱动</span><br><span class="line">2. MySQL-python ：是封装了 MySQL C驱动的 Python 驱动</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SQLAlchemy的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是是一种ORM（Object-Relational Mapping）框架，将关系数据库的表结构映射到对象上，隐藏了数据库操作背后的细节，简化了数据操作。</span><br></pre></td></tr></table></figure>
<h2 id="2-1在Python3-X上安装MySQL驱动">2.1在Python3.X上安装MySQL驱动</h2>
<p>这里选择PyMySQL作为主要研究对象。安装方法和验证是否安装成功的步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install pymysql</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br></pre></td></tr></table></figure>
<p>如果没有产生错误，则表明安装成功。</p>
<p>如果这里因网络原因没有安装成功，可以选择到网址 <a href="https://pypi.org/">https://pypi.org/</a> 里面搜索pymysql下载（需要魔法）。</p>
<h2 id="2-2-建立数据库连接"><strong>2.2 建立数据库连接</strong></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;连接数据库，创建游标&#x27;&#x27;&#x27;</span></span><br><span class="line">connection = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, <span class="comment"># IP地址，我这里用的本地地址</span></span><br><span class="line">                    port=<span class="number">3306</span>, <span class="comment"># 端口号</span></span><br><span class="line">                    user=<span class="string">&#x27;root&#x27;</span>, <span class="comment"># 用户名</span></span><br><span class="line">                    passwd=<span class="string">&#x27;123456&#x27;</span>, <span class="comment"># 密码</span></span><br><span class="line">                    charset = <span class="string">&#x27;utf8&#x27;</span> <span class="comment"># 编码方式</span></span><br><span class="line">                    )</span><br><span class="line">cursor = connection.cursor()</span><br></pre></td></tr></table></figure>
<h2 id="2-3-创建数据库"><strong>2.3 创建数据库</strong></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&#x27;create database if not exists s;&#x27;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<h2 id="2-4-创建数据表">2.4 创建数据表</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;create table stu(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(sql) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p><strong>cursor()：表示游标</strong></p>
<p><strong>execute()：是执行语句</strong></p>
<p><strong>commit()：是提交事务，执行语句后有这个才能对数据库进行真正的操作，也可以在创建连接时，设置autocommit = True</strong>。即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connection = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, <span class="comment"># IP地址，我这里用的本地地址</span></span><br><span class="line">                    port=<span class="number">3306</span>, <span class="comment"># 端口号</span></span><br><span class="line">                    user=<span class="string">&#x27;root&#x27;</span>, <span class="comment"># 用户名</span></span><br><span class="line">                    passwd=<span class="string">&#x27;123456&#x27;</span>, <span class="comment"># 密码</span></span><br><span class="line">                    charset = <span class="string">&#x27;utf8&#x27;</span>, <span class="comment"># 编码方式</span></span><br><span class="line">                    autocommit = <span class="literal">True</span></span><br><span class="line">                    )</span><br></pre></td></tr></table></figure>
<h2 id="2-5-增、改、删、查">2.5 增、改、删、查</h2>
<h3 id="2-5-1-增">2.5.1 增</h3>
<p>在cutomers表中插入数据用的是&quot;INSERT INTO&quot;语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert1 = <span class="string">&quot;INSERT INTO stu(id,name,class, age) Values(1,&#x27;ludong&#x27;,1,10);&quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(insert1) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>上面这种方式是在插入的时候，值是常量的情况，当值为变量的时候，可以采用下面这种方式，即多输入一个列表或元组来作为值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert2 = <span class="string">&quot;INSERT INTO stu(id,name,class, age) Values(%s,%s,%s,%s)&quot;</span></span><br><span class="line">values = [<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">1</span>,<span class="number">10</span>]</span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(insert2, values) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>除了用一条条用execute( )插入之外，我们还可以用executemany（）的方式批量插入，也就是val中包含的是一个元组列表，包含我们想要插入的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert2 = <span class="string">&quot;INSERT INTO stu(id,name,class, age) Values(%s,%s,%s,%s)&quot;</span></span><br><span class="line">values = [[<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">2</span>,<span class="number">11</span>]]</span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.executemany(insert2, values) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>需要注意的事是：如果数据表格有更新，那么必须用到commit()语句，否则在workbench是看不到插入的数据的。执行以上代码后，回到数据库 s 下面的 stu 表格，我们可以看到最终的结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/1.png" alt="image-20220608194453767"></p>
<h3 id="2-5-2-改">2.5.2 改</h3>
<p>在 stu 表中更改数据用的是&quot;UPDATE&quot;语句。例如，我们将最后一条“zhangsan”的年龄改成10：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update = <span class="string">&quot; UPDATE stu SET age=10 WHERE name=&#x27;zhangsan&#x27; &quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(update) </span><br><span class="line">connection.commit() </span><br></pre></td></tr></table></figure>
<p>执行代码，回到表格我们可以看到结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/2.png" alt="image-20220608194827301"></p>
<h3 id="2-5-3-删">2.5.3 删</h3>
<p>关于删，删除表格用的是“DROP TABLE ”语句。这里为了方便只写下代码，不执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete = <span class="string">&quot; DROP TABLE stu &quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(update) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>当需要删除一条数据记录时候，用到的语句是“DELETE  FROM”语句。例如：想在 stu 这个表格当中，删除重复的那两条数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete = <span class="string">&quot; DELETE FROM stu WHERE name=&#x27;lisi&#x27; &quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(delete) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>执行代码，回到 stu 我们可以看到结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/3.png" alt="image-20220608195255618"></p>
<h3 id="2-5-4-查">2.5.4 查</h3>
<ul>
<li><strong>普通查询</strong></li>
</ul>
<p>普通查询数据用的是SELECT语句。例如：需要查询 stu 的所有信息，并且进行打印输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql=<span class="string">&quot;SELECT * FROM stu&quot;</span> </span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>)  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchall()     <span class="comment"># fetchall() 获取所有记录  </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line"> 	<span class="built_in">print</span>(x)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">sql=<span class="string">&quot;SELECT * FROM stu&quot;</span> </span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>)  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchone()     <span class="comment"># fetchone() 获取一条记录  </span></span><br><span class="line"><span class="built_in">print</span>(myresult)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">sql=<span class="string">&quot;SELECT * FROM stu&quot;</span> </span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>)  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchmany(size=<span class="number">2</span>)     <span class="comment"># fetchmany() 获取部分记录  </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line"> 	<span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>得到最终结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/4.png" alt="image-20220608201425200"></p>
<p>值得注意的是：**fetchall()**表示的是获得所有记录；**fetchone()**表示只获取一条数据；**fetchmany(size=2)**表示获取两条记录。</p>
<ul>
<li><strong>限定条件查找</strong></li>
</ul>
<p>为了获取指定条件下的查找结果，我们可以使用where语句。例如：需要在查询 stu 的所有信息基础上，输出 class 为 2 的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql=<span class="string">&quot;SELECT * FROM stu WHERE class = 2&quot;</span>  </span><br><span class="line">mycursor.execute(sql)  </span><br><span class="line">myresult = mycursor.fetchall()     <span class="comment"># fetchall() 获取所有记录  </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">  <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>最终得到的结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/5.png" alt="image-20220608202545352"></p>
<ul>
<li><strong>通配符查找</strong></li>
</ul>
<p>有时候为了进行模糊查询，可以匹配通配符，通过“LIKE”来进行查找：</p>
<p><strong>百分号 （%）</strong>: 代表零个、一个或多个数字或字符；</p>
<p><strong>下划线 （_）</strong>: 代表一个单一的数字或字符。</p>
<p>例如：查出所有名字中含有do的记录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql=<span class="string">f&quot; SELECT * FROM stu WHERE name LIKE &#x27;%do%&#x27; &quot;</span>  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchall()      </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">  <span class="built_in">print</span>(x) </span><br></pre></td></tr></table></figure>
<p>执行代码，我们得到的结果如下：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/6.png" alt="image-20220608202753988"></p>
<p>值得注意的是：但是使用Like查询时，即使我们在代码输入的是“do”，执行过程中也会将含有“Do”、“DO”、“dO”的记录同样输出，即用LIKE匹配通配符对大小写不敏感。为了区分大小写，可以用“GLOB”进行查询。详情见：<a href="https://blog.csdn.net/diaokua8472/article/details/101640342">【SQL】glob 和 like 的区别</a></p>
<ul>
<li><strong>排序</strong></li>
</ul>
<p>查询结果排序可以使用 ORDER BY 语句，默认的排序方式为升序，如果要设置降序排序，可以设置关键字 DESC。例如：我们要按照年龄对 stu 进行升序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升序</span></span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM stu ORDER BY age&quot;</span> </span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line"><span class="comment"># sql = &quot;SELECT * FROM stu ORDER BY age DESC&quot; </span></span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">result=cursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>执行代码，得到的结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/7.png" alt="image-20220608203453718"></p>
<ul>
<li><strong>LIMIT</strong></li>
</ul>
<p>当数据库数量非常大的时候，为了限制查询的数据量，可以采用&quot;LIMIT&quot;语句来指定，比如我们希望在 stu 表中找出年龄最高的三个人：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT * FROM stu ORDER BY age DESC LIMIT 2&quot;</span>  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">result=cursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>执行代码，得到结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/7.png" alt="image-20220608203453718"></p>
<ul>
<li><strong>二次筛选</strong></li>
</ul>
<p>有时候我们在进行一次筛选后，还需要设定一个筛选条件进行二次筛选，我们就可以采用“HAVING”语句。例如：我们希望统计在年龄处于20-30（不包括20岁，但是包括30岁）的人当中，选择薪资大于5000的消费者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二次过滤  </span></span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM stu WHERE age=10 HAVING class=1 &quot;</span>  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">result=cursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br><span class="line">con.commit()  </span><br></pre></td></tr></table></figure>
<p>执行代码后，得到的结果如下：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/8.png" alt="img"></p>
<h2 id="3-5-分组聚合">3.5 分组聚合</h2>
<p>在数据库中，分组常用的语句为“GROUP BY”语句，聚合函数，通常是配合分组进行使用，在数据库中常用的聚合函数为：</p>
<ol>
<li><strong>COUNT（*）</strong>：表示计算总行数，括号可以写*和字段名字</li>
<li><strong>MAX（column）</strong>：表示求此列的最大值</li>
<li><strong>MIN（column）</strong>：表示求此列的最小值</li>
<li><strong>SUM（column）</strong>：表示求此列的和</li>
<li><strong>AVG（column）</strong>：表示求此列的平均值</li>
</ol>
<ul>
<li><strong>从customers表中统计出男女薪资总和</strong></li>
</ul>
<p>以sex为类别进行GROUP BY 分组，加上WHERE来做条件判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#统计出男女的薪水总数  </span></span><br><span class="line">sql = <span class="string">&quot;SELECT sex,sum(sl) FROM customers GROUP BY sex&quot;</span>  </span><br><span class="line">mycursor.execute(sql)  </span><br><span class="line">myresult=mycursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>最终结果为：</p>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC1kMTdkODdjNTg0OTcyZWE2P2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<ul>
<li><strong>从customers表中，按性别进行分组，统计出年龄在20-30的消费者的薪资，并且按照薪资高低进行排序</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照性别进行分组，统计出年龄在20-30岁的消费者的薪资  </span><br><span class="line">sql = &quot;SELECT sex,sum(sl) FROM customers WHERE age&gt;20 and age&lt;=30 GROUP BY sex ORDER BY sl&quot;  </span><br><span class="line">mycursor.execute(sql)  </span><br><span class="line">myresult=mycursor.fetchall()  </span><br><span class="line">for x in myresult:  </span><br><span class="line">    print(x)  </span><br></pre></td></tr></table></figure>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC01NGVjN2RlYWExNzkwOTIwP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<p>值得注意的是：本例是以sex为类别进行GROUP BY 分组，加上WHERE来做条件判断，加上ORDER BY 排序，但是GROUP BY 的位置必须要在WHERE 之后，在ORDER BY 之前。</p>
<h2 id="3-6-分批量读取和处理数据">3.6 分批量读取和处理数据</h2>
<p>程序运行的时候，数据都是在内存中的，但是有时候如果数据量太大，内存会装不下，这个时候我们就需要分批从数据库去读取数据，然后再处理，等到处理完了之后，再去读取。比如：我们要从customers当中分批读取和处理薪资大于8000的消费者，并将其存入另一张表中。我们的做法是先新建一个表，然后从数据库当中读取3个，并且将读取的这3个进行处理，处理完读取的这三个后，再去数据库重新读取三个，直到数据库的数据读完为止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分批读取并且处理将薪资大于8000的消费者的记录存到另一张表中  </span></span><br><span class="line"><span class="comment"># 创建一个临时表   </span></span><br><span class="line">tmpName = \<span class="string">&#x27;cust_tmp\&#x27;  </span></span><br><span class="line"><span class="string">dropTable(mycursor, tmpName)    </span></span><br><span class="line"><span class="string">mycursor.execute(&quot;CREATE TABLE cust_tmp(id INT AUTO_INCREMENT PRIMARY KEY,\</span></span><br><span class="line"><span class="string">                               name VARCHAR(255), address VARCHAR(255), \  </span></span><br><span class="line"><span class="string">                               sex VARCHAR(225), age INT(10), sl INT(10))&quot;)</span></span><br><span class="line"><span class="string">ins = con.cursor(buffered=True)  </span></span><br><span class="line"><span class="string">if tableExists(mycursor, tableName):  </span></span><br><span class="line"><span class="string">    print(&quot;process table: %s&quot;, tableName)  </span></span><br><span class="line"><span class="string">    # 查询表里的记录  </span></span><br><span class="line"><span class="string">    sql = &quot;SELECT * FROM customers WHERE address is not null&quot;  </span></span><br><span class="line"><span class="string">    mycursor.execute(sql)  </span></span><br><span class="line"><span class="string">    # 每次处理 batchsize 条记录，直到所有查询结果处理完  </span></span><br><span class="line"><span class="string">    batchsize = 3  </span></span><br><span class="line"><span class="string">    readsize = batchsize  </span></span><br><span class="line"><span class="string">    while readsize == batchsize:  </span></span><br><span class="line"><span class="string">        print(&quot;before batch&quot;)  </span></span><br><span class="line"><span class="string">        myresult = mycursor.fetchmany(size=batchsize)  </span></span><br><span class="line"><span class="string">        for x in myresult:  </span></span><br><span class="line"><span class="string">            if x[5]&gt;8000:  </span></span><br><span class="line"><span class="string">                ins.execute(&quot;INSERT INTO&quot;+tmpName+&quot;(id,name,address,sex,age,sl) VALUES (%s, %s,%s, %s,%s,%s)&quot;, x)  </span></span><br><span class="line"><span class="string">                print(x)  </span></span><br><span class="line"><span class="string">        readsize = len(myresult)  </span></span><br><span class="line"><span class="string">else:  </span></span><br><span class="line"><span class="string">    print(&quot;table: does not exists&quot;, tableName)  </span></span><br><span class="line"><span class="string">con.commit()  </span></span><br><span class="line"><span class="string">con.close()  </span></span><br></pre></td></tr></table></figure>
<p>我们回到workbench找到这个新建的表格cust_tmp，我们可以发现薪资大于8000的消费者都被记录上了：</p>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC05NThhZDE1MGJiNGMxMjRiP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<p>执行代码，我们可以看到处理的过程如下：</p>
<p>在第一批读取的三条记录中，只有两条是满足薪资大于8000的要求，第二批读取的三条记录中，只有一条满足薪资大于8000的要求，而在第三批读取的三条记录中，没有任何记录是满足薪资大于8000的要求，当没有记录可以读的时候，程序即停止。</p>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC0xYTRlNGRiZDZiNmEwZDkyP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<h2 id="通用类">通用类</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mycursor</span>(<span class="params">db_name=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;连接数据库，创建游标&#x27;&#x27;&#x27;</span></span><br><span class="line">    config = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;host&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;port&#x27;</span>, <span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">                      [<span class="string">&#x27;192.168.137.155&#x27;</span>, <span class="string">&#x27;shanger&#x27;</span>, <span class="number">3306</span>, <span class="string">&#x27;0123&#x27;</span>]))</span><br><span class="line">    config.update(database=db_name)</span><br><span class="line">    connection = pymysql.connect(**config)</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    <span class="keyword">return</span> cursor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">use</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;切换数据库，返回游标&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> mycursor(db_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_database</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;新建数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;create database if not exists <span class="subst">&#123;db_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_table</span>(<span class="params">tbl_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;新建数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;create table if not exists <span class="subst">&#123;tbl_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drop_database</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;删除数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;drop database if exists <span class="subst">&#123;db_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drop_table</span>(<span class="params">tbl_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;删除数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;drop table if exists <span class="subst">&#123;tbl_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">sql</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;以数据框形式返回查询据结果&#x27;&#x27;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    data = cursor.fetchall()  <span class="comment"># 以元组形式返回查询数据</span></span><br><span class="line">    header = [t[<span class="number">0</span>] <span class="keyword">for</span> t <span class="keyword">in</span> cursor.description]</span><br><span class="line">    df = pd.DataFrame(<span class="built_in">list</span>(data), columns=header)  <span class="comment"># pd.DataFrem 对列表具有更好的兼容性</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_databases</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;查看服务器上的所有数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">&#x27;show databases;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> query(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_database</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;查看当前数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">&#x27;select database();&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> query(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_tables</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;查看当前数据库中所有的表&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">&#x27;show tables;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> query(sql)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-1</title>
    <url>/2022/06/01/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-1/</url>
    <content><![CDATA[<h2 id="问题描述-6">问题描述</h2>
<h3 id="题目：外星文字典">题目：外星文字典</h3>
<p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>
<p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经按这门新语言的字母顺序进行了排序 。</p>
<p>请你根据该词典还原出此语言中已知的字母顺序，并按字母递增顺序排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种顺序即可。</p>
<p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p>
<ul>
<li>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。</li>
<li>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</li>
</ul>
<h3 id="示例-9">示例</h3>
<ol>
<li>
<p>输入：words = [“wrt”,“wrf”,“er”,“ett”,“rftt”]<br>
输出：“wertf”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;wrt&#x27; &lt; &#x27;wrf&#x27;  --&gt;  &#x27;t&#x27; &lt; &#x27;f&#x27;</span><br><span class="line">&#x27;wrf&#x27; &lt; &#x27;er&#x27;   --&gt;  &#x27;w&#x27; &lt; &#x27;e&#x27;</span><br><span class="line">&#x27;er&#x27;  &lt; &#x27;ett&#x27;  --&gt;  &#x27;r&#x27; &lt; &#x27;t&#x27;</span><br><span class="line">&#x27;ett&#x27; &lt; &#x27;rftt&#x27; --&gt;  &#x27;e&#x27; &lt; &#x27;r&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输入：words = [“z”,“x”]<br>
输出：“zx”</p>
</li>
<li>
<p>输入：words = [“z”,“x”,“z”]<br>
输出：“”<br>
解释：不存在合法字母顺序，因此返回 “” 。</p>
</li>
</ol>
<h3 id="提示-5">提示</h3>
<ul>
<li>1 &lt;= words.length &lt;= 100</li>
<li>1 &lt;= words[i].length &lt;= 100</li>
<li>words[i] 仅由小写英文字母组成</li>
</ul>
<h3 id="来源-9">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/Jf1JuT">https://leetcode.cn/problems/Jf1JuT</a></p>
<h2 id="问题解答-9">问题解答</h2>
<h3 id="拓扑排序-深度优先搜索">拓扑排序 + 深度优先搜索</h3>
<p>这道题是拓扑排序问题。外星文字典中的字母和字母顺序可以看成有向图，字典顺序即为所有字母的一种排列，满足每一条有向边的起点字母和终点字母的顺序都和这两个字母在排列中的顺序相同，该排列即为有向图的拓扑排序。</p>
<p>只有当有向图中无环时，才有拓扑排序，且拓扑排序可能不止一种。如果有向图中有环，则环内的字母不存在符合要求的排列，因此没有拓扑排序。</p>
<p>使用拓扑排序求解时，将外星文字典中的每个字母看成一个节点，将字母之间的顺序关系看成有向边。对于外星文字典中的两个相邻单词，同时从左到右遍历，当遇到第一个不相同的字母时，该位置的两个字母之间即存在顺序关系。</p>
<p>以下两种情况不存在合法字母顺序：</p>
<ul>
<li>字母之间的顺序关系存在由至少 2个字母组成的环，例如 words=[“a”, “b”, “a”]</li>
<li>相邻两个单词满足后面的单词是前面的单词的前缀，且后面的单词的长度小于前面的单词的长度，例如 words=[“ab”, 'a&quot;]。</li>
</ul>
<p>其余情况下都存在合法字母顺序，可以使用拓扑排序得到字典顺序。</p>
<p>拓扑排序可以使用深度优先搜索或广度优先搜索实现，以下介绍拓扑排序 + 深度优先搜索方法。</p>
<p>使用深度优先搜索实现拓扑排序的总体思想是：对于一个特定节点，如果该节点的所有相邻节点都已经搜索完成，则该节点也会变成已经搜索完成的节点，在拓扑排序中，该节点位于其所有相邻节点的前面。一个节点的相邻节点指的是从该节点出发通过一条有向边可以到达的节点。</p>
<p>由于拓扑排序的顺序和搜索完成的顺序相反，因此需要使用一个栈存储所有已经搜索完成的节点。深度优先搜索的过程中需要维护每个节点的状态，每个节点的状态可能有三种情况：「未访问」、「访问中」和「已访问」。初始时，所有节点的状态都是「未访问」。</p>
<p>每一轮搜索时，任意选取一个「未访问」的节点u，从节点u开始深度优先搜索。将节点u的	状态更新为「访问中」，对于每个与节点u相邻的节点v，判断节点v的状态，执行如下操作：</p>
<ol>
<li>
<p>如果节点v的状态是「未访问」，则继续搜索节点v；</p>
</li>
<li>
<p>如果节点v的状态是「访问中」，则找到有向图中的环，因此不存在拓扑排序；</p>
</li>
<li>
<p>如果节点v的状态是「已访问」，则节点v已经搜索完成并入栈，节点u尚未入栈，因此节点u的拓扑顺序一定在节点v的前面，不需要执行任何操作。</p>
</li>
</ol>
<p>当节点u的所有相邻节点的状态都是「已访问」时，将节点u的状态更新为「已访问」，并将节点u入栈。</p>
<p>当所有节点都访问结束之后，如果没有找到有向图中的环，则存在拓扑排序，所有节点从栈顶到栈底的顺序即为拓扑排序。</p>
<p>实现方面，由于每个节点是一个字母，因此可以使用字符数组代替栈，当节点入栈时，在字符数组中按照从后往前的顺序依次填入每个字母。当所有节点都访问结束之后，将字符数组转成字符串，即为字典顺序。</p>
<h4 id="代码-12">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> pairwise</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">alienOrder</span>(<span class="params">self, words: <span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        g = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> words[<span class="number">0</span>]:</span><br><span class="line">            g[c] = []</span><br><span class="line">        <span class="keyword">for</span> s, t <span class="keyword">in</span> pairwise(words):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                g.setdefault(c, [])</span><br><span class="line">            <span class="keyword">for</span> u, v <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">                <span class="keyword">if</span> u != v:</span><br><span class="line">                    g[u].append(v)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t):</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        VISITING, VISITED = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        states = &#123;&#125;</span><br><span class="line">        order = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            states[u] = VISITING</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> g[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> states:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dfs(v):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> states[v] == VISITING:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            order.append(u)</span><br><span class="line">            states[u] = VISITED</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(order)) <span class="keyword">if</span> <span class="built_in">all</span>(dfs(u) <span class="keyword">for</span> u <span class="keyword">in</span> g <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> states) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="作者-7">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/Jf1JuT/solution/wai-xing-wen-zi-dian-by-leetcode-solutio-to66/">https://leetcode.cn/problems/Jf1JuT/solution/wai-xing-wen-zi-dian-by-leetcode-solutio-to66/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-30</title>
    <url>/2022/05/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-30/</url>
    <content><![CDATA[<h2 id="问题1描述">问题1描述</h2>
<h3 id="题目：掉落的方块">题目：掉落的方块</h3>
<p>在二维平面上的 x 轴上，放置着一些方块。</p>
<p>给你一个二维整数数组 positions ，其中 positions[i] = [lefti, sideLengthi] 表示：第 i 个方块边长为 sideLengthi ，其左侧边与 x 轴上坐标点 lefti 对齐。</p>
<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 另一个正方形的顶边 或者是 x 轴上 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
<p>在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。</p>
<p>返回一个整数数组 ans ，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。</p>
<h3 id="示例-7">示例</h3>
<ol>
<li>
<p>输入：positions = [[1,2],[2,3],[6,1]]</p>
<p>输出：[2,5,5]</p>
<p><img src="/2022/05/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-30/1.png" alt="image-20220530181242124"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line"></span><br><span class="line">第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。</span><br><span class="line"></span><br><span class="line">第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。</span><br><span class="line"></span><br><span class="line">第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。</span><br><span class="line"></span><br><span class="line">因此，返回 [2, 5, 5] 作为答案。</span><br></pre></td></tr></table></figure>
<p>2.输入：positions = [[100,100],[200,100]]</p>
<p>输出：[100,100]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line"></span><br><span class="line">第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。</span><br><span class="line"></span><br><span class="line">第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。</span><br><span class="line"></span><br><span class="line">因此，返回 [100, 100] 作为答案。</span><br><span class="line"></span><br><span class="line">注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。</span><br></pre></td></tr></table></figure>
<h3 id="提示-3">提示</h3>
<p>$ 1 &lt;= positions.length &lt;= 1000$</p>
<p>​    $1 &lt;= lefti &lt;= 10^8$</p>
<p>$ 1 &lt;= sideLengthi &lt;= 10^6$</p>
<h3 id="来源-7">来源</h3>
<p>力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/falling-squares">https://leetcode.cn/problems/falling-squares</a></p>
<h3 id="问题解答-7">问题解答</h3>
<h4 id="暴力枚举">暴力枚举</h4>
<p>用数组 heights 记录各个方块掉落后的高度。对于第 i 个掉落的方块，如果它的底部区间与第 j 个掉落的方块有重叠，那么它掉落后的高度至少为 heights[j]+sizei，其中 j&lt;i且 sizei为第 i 个掉落的方块的边长。因此对于第 i 个掉落的方块，heights[i] 的初始值为 sizei，我们暴力枚举所有之前已经掉落的方块，如果两者的底部区间有重叠，那么更新heights[i] = max⁡(heights[i],heights[j]+sizei)。</p>
<p>因为题目要求返回一个所有已经落稳的方块的最大堆叠高度列表，我们从 i=1 开始，更新 heights[i]=max⁡(heights[i],heights[i−1])，然后返回 heights 即可。</p>
<h5 id="代码-10">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fallingSquares</span>(<span class="params">self, positions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(positions)</span><br><span class="line">        heights = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i, (left1, side1) <span class="keyword">in</span> <span class="built_in">enumerate</span>(positions):</span><br><span class="line">            right1 = left1 + side1 - <span class="number">1</span></span><br><span class="line">            heights[i] = side1</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                left2, right2 = positions[j][<span class="number">0</span>], positions[j][<span class="number">0</span>] + positions[j][<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> right1 &gt;= left2 <span class="keyword">and</span> right2 &gt;= left1:</span><br><span class="line">                    heights[i] = <span class="built_in">max</span>(heights[i], heights[j] + side1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            heights[i] = <span class="built_in">max</span>(heights[i], heights[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> heights</span><br></pre></td></tr></table></figure>
<h5 id="作者-6">作者</h5>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/falling-squares/solution/diao-luo-de-fang-kuai-by-leetcode-soluti-2dmw/">https://leetcode.cn/problems/falling-squares/solution/diao-luo-de-fang-kuai-by-leetcode-soluti-2dmw/</a></p>
<h2 id="问题2描述">问题2描述</h2>
<h3 id="题目：从根到叶的二进制数之和">题目：从根到叶的二进制数之和</h3>
<p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p>
<h3 id="示例-8">示例</h3>
<p>输入：root = [1,0,1,0,1,0,1]<br>
输出：22</p>
<p><img src="/2022/05/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-30/2.png" alt="image-20220530182147285"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</span><br></pre></td></tr></table></figure>
<h3 id="提示-4">提示</h3>
<ul>
<li>树中的节点数在 <code>[1, 1000]</code> 范围内</li>
<li><code>Node.val</code> 仅为 <code>0</code> 或 <code>1</code></li>
</ul>
<h3 id="来源-8">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers">https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers</a></p>
<h3 id="问题解答-8">问题解答</h3>
<h4 id="直接遍历">直接遍历</h4>
<p>直接对二叉树进行遍历，唯一需要做的就是在遍历一个节点时，需要更改节点的值val，其值为如果它为叶节点时，它到根节点路径对应的二进制数的值，node.val = node.val + num*2， num为父节点的值。最后将所有叶节点的节点值加起来即可。</p>
<h4 id="代码-11">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRootToLeaf</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        leaflist = <span class="built_in">list</span>()</span><br><span class="line">        visiting = deque([root])</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">node, num</span>):</span><br><span class="line">            node.val = node.val + num*<span class="number">2</span></span><br><span class="line">            visiting.append(node)</span><br><span class="line">        <span class="keyword">while</span> visiting:</span><br><span class="line">            temp = visiting.popleft()</span><br><span class="line">            val = temp.val</span><br><span class="line">            <span class="keyword">if</span> (temp.right <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">and</span> (temp.left <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                leaflist.append(temp)</span><br><span class="line">            <span class="keyword">elif</span> temp.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                add(temp.left, val)</span><br><span class="line">            <span class="keyword">elif</span> temp.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                add(temp.right, val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                add(temp.left, val)</span><br><span class="line">                add(temp.right, val)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> leaflist:</span><br><span class="line">            <span class="built_in">sum</span> += node.val</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-23</title>
    <url>/2022/05/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-23/</url>
    <content><![CDATA[<h2 id="问题描述-5">问题描述</h2>
<h3 id="题目：为高尔夫比赛砍树">题目：为高尔夫比赛砍树</h3>
<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：</p>
<ul>
<li>0 表示障碍，无法触碰</li>
<li>1 表示地面，可以行走</li>
<li>比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度</li>
</ul>
<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。你需要<strong>按照树的高度从低向高砍掉所有的树</strong>，每砍过一颗树，该单元格的值变为 1（即变为地面）。</p>
<p>你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的<strong>最小</strong>步数。 如果你无法砍完所有的树，返回 -1 。</p>
<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>
<h3 id="示例-5">示例</h3>
<p>1、<img src="/2022/05/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-23/1.png" alt="image-20220523190046063"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[1,2,3],[0,0,4],[7,6,5]]</span><br><span class="line">输出：6</span><br><span class="line">解释：沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</span><br></pre></td></tr></table></figure>
<p>2、<img src="/2022/05/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-23/2.png" alt="image-20220523190117932"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[1,2,3],[0,0,0],[7,6,5]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。</span><br></pre></td></tr></table></figure>
<p>3、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[2,3,4],[0,0,5],[8,7,6]]</span><br><span class="line">输出：6</span><br><span class="line">解释：可以按与示例 1 相同的路径来砍掉所有的树。</span><br><span class="line">(0,0) 位置的树，可以直接砍去，不用算步数。</span><br></pre></td></tr></table></figure>
<h3 id="来源-5">来源</h3>
<p>力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event">https://leetcode.cn/problems/cut-off-trees-for-golf-event</a></p>
<h2 id="问题解答-5">问题解答</h2>
<h3 id="BFS">BFS</h3>
<h4 id="思路-3">思路</h4>
<p>首先对矩阵中的树按照树的高度进行排序，依次求出相邻的树之间的最短距离。记录在某个时间点已经添加到队列中的节点，这些节点已被处理或在等待处理的队列中。对于下一个要处理的每个节点，查看他们的四个方向上相邻的点，如果相邻的点没有被遍历过且不是障碍，将其加入到队列中，直到找到终点为止，返回当前的步数即可。最终返回所有的步数之和即为最终结果。</p>
<h4 id="代码-7">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutOffTree</span>(<span class="params">self, forest: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx: <span class="built_in">int</span>, sy: <span class="built_in">int</span>, tx: <span class="built_in">int</span>, ty: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            m, n = <span class="built_in">len</span>(forest), <span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">            q = deque([(<span class="number">0</span>, sx, sy)])</span><br><span class="line">            vis = &#123;(sx, sy)&#125;</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                d, x, y = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> x == tx <span class="keyword">and</span> y == ty:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> ((x - <span class="number">1</span>, y), (x + <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; n <span class="keyword">and</span> forest[nx][ny] <span class="keyword">and</span> (nx, ny) <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                        vis.add((nx, ny))</span><br><span class="line">                        q.append((d + <span class="number">1</span>, nx, ny))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        trees = <span class="built_in">sorted</span>((h, i, j) <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(forest) <span class="keyword">for</span> j, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(row) <span class="keyword">if</span> h &gt; <span class="number">1</span>)</span><br><span class="line">        ans = preI = preJ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, i, j <span class="keyword">in</span> trees:</span><br><span class="line">            d = bfs(preI, preJ, i, j)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            ans += d</span><br><span class="line">            preI, preJ = i, j</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="补充">补充</h4>
<p>这里求两点之间的最短距离可以选择很多方法，如A*搜索、Dijkstra算法等。</p>
<h3 id="AStar-算法-并查集预处理无解">AStar 算法 + 并查集预处理无解</h3>
<h4 id="思路-4">思路</h4>
<p>AStar 算法使用到了优先队列（堆）来进行启发式搜索，而对于一些最佳路径方向与两点相对位置相反（例如 TTT 在 SSS 的右边，但由于存在障碍，最短路径需要先从左边绕一圈才能到 TTT），AStar 反而会因为优先队列（堆）而多一个 log⁡ 的复杂度。</p>
<p>因此一个可行的优化是，先提前处理无解的情况，常见的做法是在预处理过程中运用并查集来维护连通性。这种对于不影响复杂度上界的预处理相比后续可能出现的大量无效搜索（最终无解）的计算量而言，是有益的。</p>
<h4 id="代码-8">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutOffTree</span>(<span class="params">self, forest: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(forest)</span><br><span class="line">        n = <span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">        p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m * n)]</span><br><span class="line">        tempDirs = [[<span class="number">0</span>, -<span class="number">1</span>],[-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        visited_list = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a, b</span>):</span><br><span class="line">            p[find(a)] = p[find(b)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> p[x] != x:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getIdx</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">return</span> i * n + j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">a ,b</span>):</span><br><span class="line">            <span class="keyword">return</span> find(a) == find(b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y, nx, ny</span>):</span><br><span class="line">            <span class="keyword">return</span> np.<span class="built_in">abs</span>(x - nx) + np.<span class="built_in">abs</span>(y - ny)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">astar</span>(<span class="params">x, y, nx, ny</span>):</span><br><span class="line">            <span class="keyword">global</span> g</span><br><span class="line">            <span class="keyword">if</span> x == nx <span class="keyword">and</span> y == ny:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">            dirs = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">            q = deque([(f(x, y, nx, ny), x, y)])</span><br><span class="line">            <span class="built_in">map</span>.update(&#123;getIdx(x, y):<span class="number">0</span>&#125;)</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                _, x, y = q.popleft()</span><br><span class="line">                step = <span class="built_in">map</span>.get(getIdx(x, y))</span><br><span class="line">                <span class="keyword">for</span> di <span class="keyword">in</span> dirs:</span><br><span class="line">                    tx, ty = x + di[<span class="number">0</span>], y + di[<span class="number">1</span>]</span><br><span class="line">                    nidx = getIdx(tx, ty)</span><br><span class="line">                    <span class="keyword">if</span> tx &lt; <span class="number">0</span> <span class="keyword">or</span> tx &gt;= m <span class="keyword">or</span> ty &lt; <span class="number">0</span> <span class="keyword">or</span> ty &gt;= n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> forest[tx][ty] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> tx == nx <span class="keyword">and</span> ty == ny:</span><br><span class="line">                        <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> nidx <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">map</span>.keys() <span class="keyword">or</span> <span class="built_in">map</span>.get(nidx) &gt; step + <span class="number">1</span>:</span><br><span class="line">                        q.append((step+<span class="number">1</span>+f(tx, ty, nx, ny), tx, ty))</span><br><span class="line">                        <span class="built_in">map</span>.update(&#123;nidx:step+<span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理过程中，同时使用「并查集」维护连通性</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> forest[i][j] &gt; <span class="number">1</span>:</span><br><span class="line">                    visited_list.append((forest[i][j], i, j))</span><br><span class="line">                <span class="keyword">if</span> forest[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> tempDirs:</span><br><span class="line">                    nx, ny = i + dx, j + dy</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; m) <span class="keyword">and</span> (ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; n) <span class="keyword">and</span> forest[nx][ny] != <span class="number">0</span>:</span><br><span class="line">                        union(getIdx(i, j), getIdx(nx, ny))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 若不满足所有树点均与 (0,0)，提前返回无解</span></span><br><span class="line">        <span class="keyword">for</span> _, x, y <span class="keyword">in</span> visited_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> query(getIdx(<span class="number">0</span>, <span class="number">0</span>), getIdx(x, y)):</span><br><span class="line">                <span class="built_in">print</span>(p)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ASTAR</span></span><br><span class="line">        visited_list = <span class="built_in">sorted</span>(visited_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        x, y, ans = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, nx, ny <span class="keyword">in</span> visited_list:</span><br><span class="line">            d = astar(x, y, nx, ny)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">0</span>:</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            ans += d</span><br><span class="line">            x, y = nx, ny</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="作者-5">作者</h4>
<p>AC_OIer，链接：<a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution/by-ac_oier-ksth/">https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution/by-ac_oier-ksth/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择策略总结</title>
    <url>/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/507101225">https://zhuanlan.zhihu.com/p/507101225</a></p>
<h2 id="特征选择">特征选择</h2>
<p>太多的特征会增加模型的复杂性和过拟合，而太少的特征会导致模型的拟合不足。将模型优化为足够复杂以使其性能可推广，但又足够简单易于训练、维护和解释是特征选择的主要工作。“特征选择”意味着可以保留一些特征并放弃其他一些特征。本文的目的是概述一些特征选择策略：</p>
<ol>
<li>删除未使用的列</li>
<li>删除具有缺失值的列</li>
<li>不相关的特征</li>
<li>低方差特征</li>
<li>多重共线性</li>
<li>特征系数</li>
<li>p 值</li>
<li>方差膨胀因子 (VIF)</li>
<li>基于特征重要性的特征选择</li>
<li>使用 sci-kit learn 进行自动特征选择</li>
<li>主成分分析 (PCA)</li>
</ol>
<h2 id="数据集">数据集</h2>
<p>为了更好的展示各个特征选择策略的结果，下面使用的数据集是来自 PyCaret（一个开源的低代码机器学习库）。数据集相当干净，但做了一些预处理。</p>
<p>加载数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = <span class="string">&#x27;https://raw.githubusercontent.com/pycaret/pycaret/master/datasets/automobile.csv&#x27;</span> </span><br><span class="line">df = pd.read_csv(data) </span><br><span class="line"> </span><br><span class="line">df.sample(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/1.png" alt="image-20220520093922825"></p>
<p>该数据集包含 202 行和 26 列——每行代表一个汽车实例，每列代表其特征和相应的价格。 这些列包括：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Index([<span class="string">&#x27;symboling&#x27;</span>, <span class="string">&#x27;normalized-losses&#x27;</span>, <span class="string">&#x27;make&#x27;</span>, <span class="string">&#x27;fuel-type&#x27;</span>, <span class="string">&#x27;aspiration&#x27;</span>, <span class="string">&#x27;num-of-doors&#x27;</span>, <span class="string">&#x27;body-style&#x27;</span>, <span class="string">&#x27;drive-wheels&#x27;</span>, <span class="string">&#x27;engine-location&#x27;</span>,<span class="string">&#x27;wheel-base&#x27;</span>, <span class="string">&#x27;length&#x27;</span>, <span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;curb-weight&#x27;</span>, <span class="string">&#x27;engine-type&#x27;</span>, <span class="string">&#x27;num-of-cylinders&#x27;</span>, <span class="string">&#x27;engine-size&#x27;</span>, <span class="string">&#x27;fuel-system&#x27;</span>, <span class="string">&#x27;bore&#x27;</span>, <span class="string">&#x27;stroke&#x27;</span>, <span class="string">&#x27;compression-ratio&#x27;</span>, <span class="string">&#x27;horsepower&#x27;</span>, <span class="string">&#x27;peak-rpm&#x27;</span>, <span class="string">&#x27;city-mpg&#x27;</span>, <span class="string">&#x27;highway-mpg&#x27;</span>, <span class="string">&#x27;price&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在让我们深入研究特征选择的 11 种策略。</p>
<h2 id="实现模型之前">实现模型之前</h2>
<h3 id="删除未使用的列">删除未使用的列</h3>
<p>通过一定的先验知识，可以判别出某些列在最终模型中不会以任何形式使用（例如“ID”、“FirstName”、“LastName”等列）。 如果有这样某个特定列将不会被使用，请随时将其删除。</p>
<p>在上述的数据集中，没有发现这样一列有这样的问题，所以这里不删除任何列。</p>
<h3 id="删除具有缺失值的列">删除具有缺失值的列</h3>
<p>缺失值会给后续的分析、处理带来很大的困扰，因此需采用不同的策略来清理缺失数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># total null values per column </span></span><br><span class="line">df.isnull().<span class="built_in">sum</span>() </span><br><span class="line"> </span><br><span class="line">&gt;&gt; </span><br><span class="line">symboling             <span class="number">0</span> </span><br><span class="line">normalized-losses    <span class="number">37</span> </span><br><span class="line">make                  <span class="number">0</span> </span><br><span class="line">fuel-<span class="built_in">type</span>             <span class="number">0</span> </span><br><span class="line">aspiration            <span class="number">0</span> </span><br><span class="line">num-of-doors          <span class="number">2</span> </span><br><span class="line">body-style            <span class="number">0</span> </span><br><span class="line">drive-wheels          <span class="number">0</span> </span><br><span class="line">engine-location       <span class="number">0</span> </span><br><span class="line">wheel-base            <span class="number">0</span> </span><br><span class="line">length                <span class="number">0</span> </span><br><span class="line">width                 <span class="number">0</span> </span><br><span class="line">height                <span class="number">0</span> </span><br><span class="line">curb-weight           <span class="number">0</span> </span><br><span class="line">engine-<span class="built_in">type</span>           <span class="number">0</span> </span><br><span class="line">num-of-cylinders      <span class="number">0</span> </span><br><span class="line">engine-size           <span class="number">0</span> </span><br><span class="line">fuel-system           <span class="number">0</span> </span><br><span class="line">bore                  <span class="number">0</span> </span><br><span class="line">stroke                <span class="number">0</span> </span><br><span class="line">compression-ratio     <span class="number">0</span> </span><br><span class="line">horsepower            <span class="number">0</span> </span><br><span class="line">peak-rpm              <span class="number">0</span> </span><br><span class="line">city-mpg              <span class="number">0</span> </span><br><span class="line">highway-mpg           <span class="number">0</span> </span><br><span class="line">price                 <span class="number">0</span> </span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>1、如果列中缺少大量数据，那么完全删除它是非常好的方法。如这里数据集里面的‘ normalized-losses ’这一列，缺失率达到了17%，那么删除它可能是一个好的选择。</p>
<p>2、如果列中缺少少量数据，那么可以采用插补的方法。如这里数据集里面的‘ num-of-doors ’ 。插补的方法一般有个案剔除法（直接删除有缺失值这一条数据）、均值替换法（用全局或附近数据的均值来替换均值）、附近替换法（直接用附近某一条数据的值来替换缺失值）。</p>
<h3 id="不相关的特征">不相关的特征</h3>
<p>无论模型处理的是回归问题（预测数字）还是分类问题（预测类别），输入特征都需要与目标值具有相关性。 如果一个特征没有表现出相关性，它就是一个主要的消除目标。 对于数值特征和分类特征可以分别进行相关性测试。</p>
<h4 id="数值变量">数值变量</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># correlation between target and features </span></span><br><span class="line">(df.corr().loc[<span class="string">&#x27;price&#x27;</span>] </span><br><span class="line"> .plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">4</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/2.png" alt="img"></p>
<p>在此示例中，<em>peak-rpm</em>, <em>compression-ratio, stroke, bore</em> , <em>symboling</em> 等特征与价格几乎没有相关性，因此可以删除它们。</p>
<p>可以手动删除列，也可以使用相关阈值进行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># drop uncorrelated numeric features (threshold &lt;0.2) </span></span><br><span class="line">corr = <span class="built_in">abs</span>(df.corr().loc[<span class="string">&#x27;price&#x27;</span>]) </span><br><span class="line">corr = corr[corr&lt;<span class="number">0.2</span>] </span><br><span class="line">cols_to_drop = corr.index.to_list() </span><br><span class="line">df = df.drop(cols_to_drop, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="分类变量">分类变量</h4>
<p>可以使用箱线图查找目标和分类特征之间的相关性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns </span><br><span class="line"> </span><br><span class="line">sns.boxplot(y = <span class="string">&#x27;price&#x27;</span>, x = <span class="string">&#x27;fuel-type&#x27;</span>, data=df)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/3.png" alt="img"></p>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/4.png" alt="img"></p>
<p>柴油车的中位价高于汽油车。 这意味着这个分类变量可以解释汽车价格，所以整个特征是具有相关性的。从第二个箱线图也可以看出普通吸入方式和涡轮增压两个对于汽车价格也具有相关性。</p>
<h3 id="低方差特征">低方差特征</h3>
<p>检查一下各个特征的差异：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># variance of numeric features </span></span><br><span class="line">(df </span><br><span class="line"> .select_dtypes(include=np.number) </span><br><span class="line"> .var() </span><br><span class="line"> .astype(<span class="string">&#x27;str&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/5.png" alt="image-20220520101044816"></p>
<p>这里的“symboling”具有极低的方差，虽然这是删除的候选者， 在这个数据集中，因为它的值在-2和3之间，因此方差很低:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;symboling&#x27;</span>].describe()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/6.png" alt="image-20220520101329463"></p>
<p>另两个特征“height”和“width”，他们的方差都不高，而且他们的取值也很大，所以可以删除这两个特征。</p>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/8.png" alt="image-20220520101845865"><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/7.png" alt="image-20220520101830675"></p>
<h3 id="多重共线性">多重共线性</h3>
<p>当任何两个特征之间存在相关性时，就会出现多重共线性。 在机器学习中，期望每个特征都应该独立于其他特征，即它们之间没有共线性。 如高马力车辆往往具有高发动机尺寸。 所以你可能想消除其中一个，让另一个决定目标变量——价格。</p>
<p>我们可以分别测试数字和分类特征的多重共线性：</p>
<h4 id="数值变量-2">数值变量</h4>
<p>Heatmap 是检查和寻找相关特征的最简单方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"> </span><br><span class="line">sns.<span class="built_in">set</span>(rc=&#123;<span class="string">&#x27;figure.figsize&#x27;</span>:(<span class="number">16</span>,<span class="number">10</span>)&#125;) </span><br><span class="line">sns.heatmap(df.corr(), </span><br><span class="line">            annot=<span class="literal">True</span>, </span><br><span class="line">            linewidths=<span class="number">.5</span>, </span><br><span class="line">            center=<span class="number">0</span>, </span><br><span class="line">            cbar=<span class="literal">False</span>, </span><br><span class="line">            cmap=<span class="string">&quot;PiYG&quot;</span>) </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/9.png" alt="img"></p>
<p>大多数特征在某种程度上相互关联，但有些特征具有非常高的相关性，例如长度与轴距以及发动机尺寸与马力。</p>
<p>可以根据相关阈值手动或以编程方式删除这些功能。 我将手动删除具有 0.80 共线性阈值的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># drop correlated features </span></span><br><span class="line">df = df.drop([<span class="string">&#x27;length&#x27;</span>, <span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;curb-weight&#x27;</span>, <span class="string">&#x27;engine-size&#x27;</span>, <span class="string">&#x27;city-mpg&#x27;</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>还可以使用称为方差膨胀因子 (VIF) 的方法来确定多重共线性并根据高 VIF 值删除特征。</p>
<h4 id="分类变量-2">分类变量</h4>
<p>检查分类变量之间的共线性，诸如独立性卡方检验之类的统计检验。</p>
<p>检查一下数据集中的两个分类列——燃料类型和车身风格——是独立的还是相关的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_cat = df[[<span class="string">&#x27;fuel-type&#x27;</span>, <span class="string">&#x27;body-style&#x27;</span>]] </span><br><span class="line">df_cat.sample(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/10.png" alt="image-20220520103040597"></p>
<p>然后在每一列中创建一个类别的交叉表/列联表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crosstab = pd.crosstab(df_cat[<span class="string">&#x27;fuel-type&#x27;</span>], df_cat[<span class="string">&#x27;body-style&#x27;</span>]) </span><br><span class="line">crosstab</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/11.png" alt="image-20220520103157014"></p>
<p>最后在交叉表上运行卡方检验，其结果将说明这两个特征是否独立。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2_contingency </span><br><span class="line"> </span><br><span class="line">chi2_contingency(crosstab)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/12.png" alt="image-20220520103313909"></p>
<p>输出依次是卡方值、p 值、自由度和预期频率数组。</p>
<p>因为 p 值 &lt;0.05，因此可以拒绝特征之间没有关联的原假设，即两个特征之间存在统计上的显著关系。由于这两个特征之间存在关联，可以选择删除其中一个。</p>
<h2 id="实现模型之后">实现模型之后</h2>
<p>到目前为止已经展示了在实现模型之前应用的特征选择策略。 这些策略在第一轮特征选择以建立初始模型时很有用。 但是一旦构建了模型，就可以获得有关模型性能中每个特征的适应度的更多信息。 根据这些新信息，可以进一步确定要保留哪些功能。</p>
<p>下面使用最简单的线性模型展示其中的一些方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># drop columns with missing values </span></span><br><span class="line">df = df.dropna() </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split </span><br><span class="line"><span class="comment"># get dummies for categorical features </span></span><br><span class="line">df = pd.get_dummies(df, drop_first=<span class="literal">True</span>) </span><br><span class="line"><span class="comment"># X features </span></span><br><span class="line">X = df.drop(<span class="string">&#x27;price&#x27;</span>, axis=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># y target </span></span><br><span class="line">y = df[<span class="string">&#x27;price&#x27;</span>] </span><br><span class="line"><span class="comment"># split data into training and testing set </span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression </span><br><span class="line"><span class="comment"># scaling </span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler </span><br><span class="line">scaler = StandardScaler() </span><br><span class="line">X_train = scaler.fit_transform(X_train) </span><br><span class="line">X_test = scaler.fit_transform(X_test) </span><br><span class="line"><span class="comment"># convert back to dataframe </span></span><br><span class="line">X_train = pd.DataFrame(X_train, columns = X.columns.to_list()) </span><br><span class="line">X_test = pd.DataFrame(X_test, columns = X.columns.to_list()) </span><br><span class="line"><span class="comment"># instantiate model </span></span><br><span class="line">model = LinearRegression()<span class="comment"># fit </span></span><br><span class="line">model.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>现在已经拟合了模型，下面进行另一轮特征选择。</p>
<h3 id="特征系数">特征系数</h3>
<p>如果正在运行回归任务，则特征适应度的一个关键指标是回归系数（所谓的 beta 系数），它显示了模型中特征的相对贡献。 有了这些信息，可以删除贡献很小或没有贡献的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># feature coefficients </span></span><br><span class="line">coeffs = model.coef_ </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualizing coefficients </span></span><br><span class="line">index = X_train.columns.tolist() </span><br><span class="line"> </span><br><span class="line">(pd.DataFrame(coeffs, index = index, columns = [<span class="string">&#x27;coeff&#x27;</span>]).sort_values(by = <span class="string">&#x27;coeff&#x27;</span>) </span><br><span class="line"> .plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">4</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/13.png" alt="img"></p>
<p>某些特征beta 系数很小，对汽车价格的预测贡献不大。 可以过滤掉这些特征：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter variables near zero coefficient value </span></span><br><span class="line">temp = pd.DataFrame(coeffs, index = index, columns = [<span class="string">&#x27;coeff&#x27;</span>]).sort_values(by = <span class="string">&#x27;coeff&#x27;</span>) </span><br><span class="line">temp = temp[(temp[<span class="string">&#x27;coeff&#x27;</span>]&gt;<span class="number">1</span>) | (temp[<span class="string">&#x27;coeff&#x27;</span>]&lt; -<span class="number">1</span>)] </span><br><span class="line"> </span><br><span class="line"><span class="comment"># drop those features </span></span><br><span class="line">cols_coeff = temp.index.to_list() </span><br><span class="line">X_train = X_train[cols_coeff] </span><br><span class="line">X_test = X_test[cols_coeff]</span><br></pre></td></tr></table></figure>
<h3 id="p-值">p 值</h3>
<p>在回归任务中，p 值告诉我们预测变量和目标之间的关系是否具有统计显著性。 statsmodels 库提供了带有特征系数和相关 p 值的回归输出的函数。</p>
<p>如果某些特征不显著，可以将它们一个一个移除，然后每次重新运行模型，直到找到一组具有显著 p 值的特征，并通过更高的调整 R2 提高性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm </span><br><span class="line">ols = sm.OLS(y, X).fit() </span><br><span class="line"><span class="built_in">print</span>(ols.summary())</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/14.png" alt="image-20220520104330245"></p>
<p>如上面的“curb-weight”特征的 p 值只有0.001，可以删除。</p>
<h3 id="方差膨胀因子-VIF">方差膨胀因子 (VIF)</h3>
<p>方差膨胀因子 (VIF) 是衡量多重共线性的另一种方法。 它定义为整体模型方差与每个独立特征的方差的比率。 一个特征的高 VIF 表明它与一个或多个其他特征相关。 根据经验：</p>
<ul>
<li>VIF = 1 表示无相关性</li>
<li>VIF = 1-5 中等相关性</li>
<li>VIF &gt; 5 高相关</li>
</ul>
<p>VIF 是一种消除多重共线性特征的有用技术。 这里将所有 VIF 高于10的删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.stats.outliers_influence <span class="keyword">import</span> variance_inflation_factor </span><br><span class="line"> </span><br><span class="line"><span class="comment"># calculate VIF </span></span><br><span class="line">vif = pd.Series([variance_inflation_factor(X.values, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">1</span>])], index=X.columns) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># display VIFs in a table </span></span><br><span class="line">index = X_train.columns.tolist() </span><br><span class="line">vif_df = pd.DataFrame(vif, index = index, columns = [<span class="string">&#x27;vif&#x27;</span>]).sort_values(by = <span class="string">&#x27;vif&#x27;</span>, ascending=<span class="literal">False</span>) </span><br><span class="line">vif_df[vif_df[<span class="string">&#x27;vif&#x27;</span>]&lt;<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/15.png" alt="image-20220520104823147"></p>
<h3 id="基于特征重要性选择">基于特征重要性选择</h3>
<p>决策树/随机森林使用一个特征来分割数据，该特征最大程度地减少了杂质(以基尼系数杂质或信息增益衡量)。 找到最佳特征是算法如何在分类任务中工作的关键部分。 我们可以通过 feature_importances_ 属性访问最好的特征。</p>
<p>让我们在我们的数据集上实现一个随机森林模型并过滤一些特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier </span><br><span class="line"> </span><br><span class="line"><span class="comment"># instantiate model </span></span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">200</span>, random_state=<span class="number">0</span>) </span><br><span class="line"><span class="comment"># fit model </span></span><br><span class="line">model.fit(X,y)</span><br></pre></td></tr></table></figure>
<p>现在让我们看看特征重要性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  feature importance </span></span><br><span class="line">importances = model.feature_importances_ </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualization </span></span><br><span class="line">cols = X.columns </span><br><span class="line">(pd.DataFrame(importances, cols, columns = [<span class="string">&#x27;importance&#x27;</span>]) </span><br><span class="line"> .sort_values(by=<span class="string">&#x27;importance&#x27;</span>, ascending=<span class="literal">True</span>) </span><br><span class="line"> .plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">4</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/16.png" alt="img"></p>
<p>上面的输出显示了每个特征在减少每个节点/拆分处的重要性。</p>
<p>由于随机森林分类器有很多估计量（例如上面例子中的 200 棵决策树），可以用置信区间计算相对重要性的估计值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate standard deviation of feature importances  </span></span><br><span class="line">std = np.std([i.feature_importances_ <span class="keyword">for</span> i <span class="keyword">in</span> model.estimators_], axis=<span class="number">0</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualization </span></span><br><span class="line">feat_with_importance  = pd.Series(importances, X.columns) </span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">5</span>)) </span><br><span class="line">feat_with_importance.plot.bar(yerr=std, ax=ax) </span><br><span class="line">ax.set_title(<span class="string">&quot;Feature importances&quot;</span>) </span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Mean decrease in impurity&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/17.png" alt="img"></p>
<p>现在我们知道了每个特征的重要性，可以手动或以编程方式确定保留哪些特征以及删除哪些特征。</p>
<h3 id="使用-Scikit-Learn-自动选择特征">使用 Scikit Learn 自动选择特征</h3>
<p>sklearn 库中有一个完整的模块，只需几行代码即可处理特征选择。</p>
<p>sklearn 中有许多自动化流程，但这里只展示一些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import modules </span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> (SelectKBest, chi2, SelectPercentile, SelectFromModel, SequentialFeatureSelector, SequentialFeatureSelector)</span><br></pre></td></tr></table></figure>
<h4 id="基于卡方的技术">基于卡方的技术</h4>
<p>基于卡方的技术根据一些预定义的分数选择特定数量的用户定义特征 (k)。 这些分数是通过计算 X（独立）和 y（因）变量之间的卡方统计量来确定的。 在 sklearn 中，需要做的就是确定要保留多少特征。 如果想保留 10 个功能，实现将如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># select K best features </span></span><br><span class="line">X_best = SelectKBest(chi2, k=<span class="number">10</span>).fit_transform(X,y) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># number of best features </span></span><br><span class="line">X_best.shape[<span class="number">1</span>] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>如果有大量特征，可以指定要保留的特征百分比。 假设我们想要保留 75% 的特征并丢弃剩余的 25%：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keep 75% top features  </span></span><br><span class="line">X_top = SelectPercentile(chi2, percentile = <span class="number">75</span>).fit_transform(X,y) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># number of best features </span></span><br><span class="line">X_top.shape[<span class="number">1</span>] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; <span class="number">36</span></span><br></pre></td></tr></table></figure>
<h4 id="正则化">正则化</h4>
<p>正则化减少了过拟合。 如果有太多的特征，正则化控制它们的效果，或者通过缩小特征系数（称为 L2 正则化）或将一些特征系数设置为零（称为 L1 正则化）。</p>
<p>一些模型具有内置的 L1/L2 正则化作为超参数来惩罚特征。 可以使用转换器 SelectFromModel 消除这些特征。</p>
<p>下面实现一个带有惩罚 = ‘l1’ 的 LinearSVC 算法。 然后使用 SelectFromModel 删除一些特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># implement algorithm </span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC </span><br><span class="line">model = LinearSVC(penalty= <span class="string">&#x27;l1&#x27;</span>, C = <span class="number">0.002</span>, dual=<span class="literal">False</span>) </span><br><span class="line">model.fit(X,y) </span><br><span class="line"><span class="comment"># select features using the meta transformer </span></span><br><span class="line">selector = SelectFromModel(estimator = model, prefit=<span class="literal">True</span>) </span><br><span class="line"> </span><br><span class="line">X_new = selector.transform(X) </span><br><span class="line">X_new.shape[<span class="number">1</span>] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; <span class="number">2</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># names of selected features </span></span><br><span class="line">feature_names = np.array(X.columns) </span><br><span class="line">feature_names[selector.get_support()] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; array([<span class="string">&#x27;wheel-base&#x27;</span>, <span class="string">&#x27;horsepower&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<h4 id="序贯法">序贯法</h4>
<p>序贯法是一种经典的统计技术。 在这种情况下一次添加/删除一个功能并检查模型性能，直到它针对需求进行优化。</p>
<p>序贯法有两种变体。 前向选择技术从 0 特征开始，然后添加一个最大程度地减少错误的特征； 然后添加另一个特征，依此类推。</p>
<p>向后选择在相反的方向上起作用。 模型从包含的所有特征开始并计算误差； 然后它消除了一个可以进一步减少误差的特征。 重复该过程，直到保留所需数量的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># instantiate model </span></span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">0</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># select features </span></span><br><span class="line">selector = SequentialFeatureSelector(estimator=model, n_features_to_select=<span class="number">10</span>, direction=<span class="string">&#x27;backward&#x27;</span>, cv=<span class="number">2</span>) </span><br><span class="line">selector.fit_transform(X,y) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># check names of features selected </span></span><br><span class="line">feature_names = np.array(X.columns) </span><br><span class="line">feature_names[selector.get_support()] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; array([<span class="string">&#x27;bore&#x27;</span>, <span class="string">&#x27;make_mitsubishi&#x27;</span>, <span class="string">&#x27;make_nissan&#x27;</span>, <span class="string">&#x27;make_saab&#x27;</span>, </span><br><span class="line">       <span class="string">&#x27;aspiration_turbo&#x27;</span>, <span class="string">&#x27;num-of-doors_two&#x27;</span>, <span class="string">&#x27;body style_hatchback&#x27;</span>, <span class="string">&#x27;engine-type_ohc&#x27;</span>, <span class="string">&#x27;num-of-cylinders_twelve&#x27;</span>, <span class="string">&#x27;fuel-system_spdi&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<h3 id="主成分分析-PCA">主成分分析 (PCA)</h3>
<p>PCA的主要目的是降低高维特征空间的维数。原始特征被重新投影到新的维度（即主成分）。 最终目标是找到最能解释数据方差的特征数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import PCA module </span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA </span><br><span class="line"><span class="comment"># scaling data </span></span><br><span class="line">X_scaled = scaler.fit_transform(X) </span><br><span class="line"><span class="comment"># fit PCA to data </span></span><br><span class="line">pca = PCA() </span><br><span class="line">pca.fit(X_scaled) </span><br><span class="line">evr = pca.explained_variance_ratio_ </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualizing the variance explained by each principal components </span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>)) </span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(evr)), evr.cumsum(), marker=<span class="string">&quot;o&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>) </span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of components&quot;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&quot;Cumulative explained variance&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/18.png" alt="img"></p>
<p>20 个主成分解释了超过 80% 的方差，因此可以将模型拟合到这 20 个成分（特征）。 可以预先确定方差阈值并选择所需的主成分数量。</p>
]]></content>
      <tags>
        <tag>Knowledge summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-19</title>
    <url>/2022/05/19/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-19/</url>
    <content><![CDATA[<h2 id="问题描述-4">问题描述</h2>
<h3 id="题目：最少移动次数使数组元素相等-II">题目：最少移动次数使数组元素相等 II</h3>
<p>给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。</p>
<h3 id="示例-4">示例</h3>
<ol>
<li>
<pre><code>输入：nums = [1,2,3]
输出：2
解释：
只需要两步操作（每步操作指南使一个元素加 1 或减 1）：
[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   输入：nums = [1,10,2,9]</span><br><span class="line">   输出：16</span><br></pre></td></tr></table></figure>




</code></pre>
</li>
</ol>
<h3 id="注意-2">注意</h3>
<ul>
<li>$n == nums.length$</li>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li>
</ul>
<h3 id="来源-4">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/</a></p>
<h2 id="问题解答-4">问题解答</h2>
<h3 id="暴力法-3">暴力法</h3>
<h4 id="思想-3">思想</h4>
<p>首先，最终相同的值不可能在 nums 的最小值和最大值的范围之外，所以遍历所有数，然后返回与其他数距离之和最小的那个。</p>
<h4 id="代码-5">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoves2</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_min = <span class="built_in">min</span>(nums)</span><br><span class="line">        num_max = <span class="built_in">max</span>(nums)</span><br><span class="line">    </span><br><span class="line">        times_min = np.inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_min, num_max+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">                temp += np.<span class="built_in">abs</span>(j - i)</span><br><span class="line">            <span class="keyword">if</span> temp &lt; times_min:</span><br><span class="line">                times_min = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(times_min)</span><br></pre></td></tr></table></figure>
<h3 id="规律法">规律法</h3>
<h4 id="思想-4">思想</h4>
<p>首先，最终相同的值不可能在 nums 的最小值和最大值的范围之外，所以结果在 [nums_min, nums_max] 之内。</p>
<p>然后，对于该范围任意一个数，它距离 nums_min 、 nums_max 的距离之和一定是等于 nums_max - nums_min。</p>
<p>既然这样，那么最小值和最大值可以从整个列表 nums 除去，那么新的 nums 又根据这种性质删除最大值和最小值。</p>
<p>最后，该问题就转化成求列表的中位数。列表长度为奇数时等于其中位数，为偶数时等于两个值中任意的那个。</p>
<h4 id="代码-6">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoves2</span>(<span class="params">self, nums</span>):</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([nums[-(i+<span class="number">1</span>)] - nums[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) // <span class="number">2</span>)])</span><br></pre></td></tr></table></figure>
<h4 id="作者-4">作者</h4>
<p>fuxuemingzhu，链接：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/by-fuxuemingzhu-13z3/">https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/by-fuxuemingzhu-13z3/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-18</title>
    <url>/2022/05/18/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-18/</url>
    <content><![CDATA[<h2 id="问题描述-2">问题描述</h2>
<h3 id="题目：乘法表中第k小的数">题目：乘法表中第k小的数</h3>
<p>给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。</p>
<h3 id="示例-2">示例</h3>
<ol>
<li>
<p>输入: m = 3, n = 3, k = 5输出: 3解释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乘法表:</span><br><span class="line">    1  2  3</span><br><span class="line"></span><br><span class="line">    2  4  6</span><br><span class="line"></span><br><span class="line">    3  6  9</span><br><span class="line">第5小的数字是 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输入: m = 2, n = 3, k = 6</p>
<p>输出: 6</p>
<p>解释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乘法表:</span><br><span class="line">    1	2	3</span><br><span class="line">    2	4	6</span><br><span class="line"></span><br><span class="line">第6小的数字是 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意">注意</h3>
<ul>
<li>m 和 n 的范围在  [1, 30000] 之间。</li>
<li>k 的范围在 [1, m * n] 之间。</li>
</ul>
<h3 id="来源-2">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table">https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table</a></p>
<h2 id="问题解答-2">问题解答</h2>
<h3 id="二分法">二分法</h3>
<h4 id="思想">思想</h4>
<p>首先，给了一个 m∗n 乘法表的二维矩阵，我们其实能很快地找到矩阵中有多少个数字小于等于 x。</p>
<p>由于第 i 行的数字分别是 $i, 2i, 3i,…$，因此这一行小于等于 x 的数字个数为 $\min(\frac{x}{i},n)$。因为$\frac{x}{i}$ 得到了 x 是 i 的多少倍，表示在第 i 行最多有多少数字小于等于 x。同时矩阵最多有 n 列，因此需要取个最小值。</p>
<p>那么矩阵中小于等于 x 的数字个数等于各行的累加，即$ \sum_{i=1}^m \min(\frac{x}{i}, n)$个。</p>
<p>所以该题就是希望得到$ \sum_{i=1}^m \min(\frac{x}{i}, n) = k$时的 x 的最小值，之所以最小是因为乘法表中数字是离散，小于 x 的个数可能和小于 x+1的个数一样。得到整个 x 的方法就是二分查找。</p>
<p>注意一点：找出最小的 x 在代码中的体现就是当小于 x 的个数等于k时，应该将中间值 mid 赋给上限。</p>
<h4 id="代码-3">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthNumber</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_min = <span class="number">1</span></span><br><span class="line">        num_max = n*m</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getnums</span>(<span class="params">num</span>):</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>): </span><br><span class="line">                    result += n <span class="keyword">if</span> i*n &lt;= num <span class="keyword">else</span> <span class="built_in">int</span>(num/i)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            mid = <span class="built_in">int</span>((num_max + num_min)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> getnums(mid) &lt; k:</span><br><span class="line">                num_min = mid </span><br><span class="line">            <span class="keyword">elif</span> getnums(mid) &gt;= k:</span><br><span class="line">                num_max = mid </span><br><span class="line">    </span><br><span class="line">            <span class="built_in">print</span>(num_max, num_min)</span><br><span class="line">            <span class="keyword">if</span> (num_max == num_min):</span><br><span class="line">                <span class="keyword">return</span> num_min</span><br><span class="line">            <span class="keyword">elif</span> (num_min + <span class="number">1</span> == num_max):</span><br><span class="line">                <span class="keyword">return</span> num_max</span><br></pre></td></tr></table></figure>
<h4 id="作者-2">作者</h4>
<p>fuxuemingzhu，链接：<a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution/by-fuxuemingzhu-8eq4/">https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution/by-fuxuemingzhu-8eq4/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-16</title>
    <url>/2022/05/16/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-16/</url>
    <content><![CDATA[<h2 id="问题描述-3">问题描述</h2>
<h3 id="题目：后继者">题目：后继者</h3>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。如果指定节点没有对应的“下一个”节点，则返回null。</p>
<h3 id="示例-3">示例</h3>
<ol>
<li>
<p>输入: root = [2,1,3], p = 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>输出: 2</p>
</li>
<li>
<p>输入: root = [5,3,6,2,4,null,null,1], p = 6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /   </span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输出: null</p>
</li>
</ol>
<h3 id="来源-3">来源</h3>
<p>力扣（LeetCode） 链接：<a href="https://leetcode.cn/problems/successor-lcci">https://leetcode.cn/problems/successor-lcci</a></p>
<h2 id="问题解答-3">问题解答</h2>
<h3 id="暴力法-2">暴力法</h3>
<h4 id="思想-2">思想</h4>
<p>先中序遍历树得到节点遍历顺序列表，再一一对比找出指定节点及其下一个节点。</p>
<h4 id="代码-4">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, root: TreeNode, p: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">rootnode</span>):</span><br><span class="line">            <span class="keyword">if</span> rootnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            getitem(rootnode.left)</span><br><span class="line">            result.append(rootnode)</span><br><span class="line">            getitem(rootnode.right)</span><br><span class="line">        getitem(root)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(result):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> p:</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(result) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> result[i+<span class="number">1</span>]</span><br><span class="line">        		<span class="keyword">else</span>:</span><br><span class="line">            		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="改进">改进</h4>
<p>因为只需要找出指定节点的下一个节点，所以可以用两个指针，一个指向当前节点的上一个节点，一个指向当前节点；若上一个节点是指定节点，则返回当前节点，否则返回null。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, root: TreeNode, p: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">global</span> last, now </span><br><span class="line">        last = <span class="literal">None</span></span><br><span class="line">        now = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">rootnode</span>):</span><br><span class="line">            <span class="keyword">global</span> last, now</span><br><span class="line">            <span class="keyword">if</span> rootnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            getitem(rootnode.left)</span><br><span class="line">            <span class="keyword">if</span> last <span class="keyword">is</span> p:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            last = now</span><br><span class="line">            now = rootnode  </span><br><span class="line">            getitem(rootnode.right)</span><br><span class="line">        getitem(root)</span><br><span class="line">        <span class="keyword">if</span> last <span class="keyword">is</span> p:</span><br><span class="line">            <span class="keyword">return</span> now</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="BST-特性-递归">BST 特性 + 递归</h2>
<h4 id="思路-2">思路</h4>
<p>利用 BST 的特性，我们可以根据当前节点 root 与 p 的值大小关系来确定搜索方向：</p>
<ul>
<li>若有<code>root.val &lt;= p.val</code>: 根据 BST 特性可知当前节点 root 及其左子树子节点均满足「值小于等于 p.val」，因此不可能是 p 点的后继，我们直接到 root 的右子树搜索 p 的后继（递归处理）；</li>
<li>若有 <code>root.val &gt; p.val </code>: 当第一次搜索到满足此条件的节点时，在以 root 为根节点的子树中「位于最左下方」的值为 p 的后继，但也有可能 root 没有左子树，因此 p 的后继要么在 root 的左子树中（若有），要么是 root 本身，此时我们可以直接到 root 的左子树搜索，若搜索结果为空返回 root，否则返回搜索结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, root: TreeNode, p: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= p.val: </span><br><span class="line">            <span class="keyword">return</span> self.inorderSuccessor(root.right, p)</span><br><span class="line">        ans = self.inorderSuccessor(root.left, p)</span><br><span class="line">        <span class="keyword">return</span> root <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="作者-3">作者</h4>
<p>AC_OIer，链接：<a href="https://leetcode.cn/problems/successor-lcci/solution/by-ac_oier-xib5/">https://leetcode.cn/problems/successor-lcci/solution/by-ac_oier-xib5/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-12</title>
    <url>/2022/05/12/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-12/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<h3 id="题目：序列化和反序列化二叉搜索树">题目：序列化和反序列化二叉搜索树</h3>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>
<p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。编码的字符串应尽可能紧凑。</p>
<h3 id="示例">示例</h3>
<ol>
<li>
<p>输入：root = [2,1,3]</p>
<p>输出：[2,1,3]</p>
</li>
<li>
<p>输入：root = [ ]</p>
<p>输出：[ ]</p>
</li>
</ol>
<h3 id="提示">提示</h3>
<ul>
<li>树中节点数范围是 [0, 104]</li>
<li>0 &lt;= Node.val &lt;= 104</li>
<li>题目数据保证输入的树是一棵二叉搜索树。</li>
</ul>
<h3 id="来源">来源</h3>
<p>力扣（LeetCode） 链接：<a href="https://leetcode.cn/problems/serialize-and-deserialize-bst">https://leetcode.cn/problems/serialize-and-deserialize-bst</a></p>
<h2 id="问题解答">问题解答</h2>
<h3 id="暴力法">暴力法</h3>
<h4 id="想法">想法</h4>
<p>二叉树就是由根节点、左子节点和右子节点组成，所以想序列化二叉搜索树就相当于保存好根节点的值和左右子节点的索引。所以按照中序遍历方式遍历整个二叉树，并按照以下规则进行转换成字符串：‘#节点索引v节点值l左子节点索引r右子节点索引r’。</p>
<p>反序列化就先得到所有定位字符的位置，然后创建所有节点，并命名为相应的索引，最后根据字符串给各个节点附上左子节点和右子节点。</p>
<p>不足：没有用到二叉搜索树的条件，这种方法对任意二叉树均可使用。</p>
<h4 id="代码">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">encoder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> +  <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_num = self.num</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(temp_num) + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> +  <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;r&#x27;</span> + encoder(root.right) </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    temp_num = self.num</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(temp_num) + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span> + encoder(root.left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_num = self.num</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    left_num = self.num</span><br><span class="line">                    temp = encoder(root.left) </span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    a = <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(temp_num)  + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> + <span class="built_in">str</span>(left_num) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;r&#x27;</span> + temp</span><br><span class="line">                    <span class="keyword">return</span> a + encoder(root.right)</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> encoder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(data)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        node_pos = <span class="built_in">list</span>([])</span><br><span class="line">        node_v = <span class="built_in">list</span>([])</span><br><span class="line">        node_l = <span class="built_in">list</span>([])</span><br><span class="line">        node_r = <span class="built_in">list</span>([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node_pos.append(i)</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                node_v.append(i)</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                node_l.append(i)</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                node_r.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(node_pos):</span><br><span class="line">            nums = <span class="built_in">int</span>(data[j+<span class="number">1</span>:node_v[i]])</span><br><span class="line">            values = <span class="built_in">int</span>(data[node_v[i]+<span class="number">1</span>:node_l[i]])</span><br><span class="line">            <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(nums)] = TreeNode(values)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(node_pos):</span><br><span class="line">            nums = <span class="built_in">int</span>(data[j+<span class="number">1</span>:node_v[i]])</span><br><span class="line">            places_left = <span class="built_in">int</span>(data[node_l[i]+<span class="number">1</span>:node_r[<span class="number">2</span>*i]]) </span><br><span class="line">            places_right = <span class="built_in">int</span>(data[node_r[<span class="number">2</span>*i]+<span class="number">1</span>:node_r[<span class="number">2</span>*i+<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">if</span> places_left != <span class="number">0</span>: </span><br><span class="line">                <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(nums)].left = <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(places_left)]</span><br><span class="line">            <span class="keyword">if</span> places_right != <span class="number">0</span>: </span><br><span class="line">                <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(nums)].right = <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(places_right)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">globals</span>()[<span class="string">&#x27;node1&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<p>二叉搜索树它或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
<p><img src="/2022/05/12/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-12/1.png" alt="image-20220512190914590"></p>
<p>二叉搜索树的特殊之处在于其中序遍历是有序的，可以利用这一点来优化时间和空间复杂度。</p>
<h4 id="思路">思路</h4>
<p>给定一棵二叉树的「先序遍历」和「中序遍历」可以恢复这颗二叉树。给定一棵二叉树的「后序遍历」和「中序遍历」也可以恢复这颗二叉树。而对于二叉搜索树，给定「先序遍历」或者「后序遍历」，对其经过排序即可得到「中序遍历」。因此，仅对二叉搜索树做「先序遍历」或者「后序遍历」，即可达到序列化和反序列化的要求。此题解采用「后序遍历」的方法。</p>
<p>序列化时，只需要对二叉搜索树进行后序遍历，再将数组编码成字符串即可。</p>
<p>反序列化时，需要先将字符串解码成后序遍历的数组。在将后序遍历的数组恢复成二叉搜索树时，不需要先排序得到中序遍历的数组再根据中序和后序遍历的数组来恢复二叉树，而可以根据有序性直接由后序遍历的数组恢复二叉搜索树。后序遍历得到的数组中，根结点的值位于数组末尾，左子树的节点均小于根节点的值，右子树的节点均大于根节点的值，可以根据这些性质设计递归函数恢复二叉搜索树。</p>
<h4 id="代码-2">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            postOrder(root.left)</span><br><span class="line">            postOrder(root.right)</span><br><span class="line">            arr.append(root.val)</span><br><span class="line">        postOrder(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, arr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span><br><span class="line">        arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, data.split()))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">lower: <span class="built_in">int</span>, upper: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">            <span class="keyword">if</span> arr == [] <span class="keyword">or</span> arr[-<span class="number">1</span>] &lt; lower <span class="keyword">or</span> arr[-<span class="number">1</span>] &gt; upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            val = arr.pop()</span><br><span class="line">            root = TreeNode(val)</span><br><span class="line">            root.right = construct(val, upper)</span><br><span class="line">            root.left = construct(lower, val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> construct(-inf, inf)</span><br></pre></td></tr></table></figure>
<h4 id="作者">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-5m9r4/">https://leetcode.cn/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-5m9r4/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-10</title>
    <url>/2022/05/10/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-10/</url>
    <content><![CDATA[<h2 id="问题介绍-2">问题介绍</h2>
<h3 id="题目：猫和老鼠-II">题目：猫和老鼠 II</h3>
<p>一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。它们所处的环境设定是一个<code>rows x cols</code>的方格 grid，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。</p>
<ul>
<li>玩家由字符 ‘C’ （代表猫）和 ‘M’ （代表老鼠）表示。</li>
<li>地板由字符 ‘.’ 表示，玩家可以通过这个格子。</li>
<li>墙用字符 ‘#’ 表示，玩家不能通过这个格子。</li>
<li>食物用字符 ‘F’ 表示，玩家可以通过这个格子。</li>
<li>字符 ‘C’ ， ‘M’ 和 ‘F’ 在 grid 中都只会出现一次。</li>
</ul>
<p>猫和老鼠按照如下规则移动：</p>
<ul>
<li>老鼠先移动，然后两名玩家轮流移动。</li>
<li>每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，它们不能跳过墙也不能跳出 grid 。</li>
<li>catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。</li>
<li>它们可以停留在原地。</li>
<li>老鼠可以跳跃过猫的位置。</li>
</ul>
<p>游戏有 4 种方式会结束：</p>
<ol>
<li>如果猫跟老鼠处在相同的位置，那么猫获胜。</li>
<li>如果猫先到达食物，那么猫获胜。</li>
<li>如果老鼠先到达食物，那么老鼠获胜。</li>
<li>如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。</li>
</ol>
<p>给你 rows x cols 的矩阵 grid 和两个整数 catJump 和 mouseJump ，双方都采取<strong>最优策略</strong>，如果老鼠获胜，那么请你返回 true ，否则返回 false 。</p>
<h3 id="示例-15">示例</h3>
<p>1、</p>
<p><img src="/2022/05/10/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-10/1.png" alt="image-20220510184546749"></p>
<p>输入：grid = [“####F”,“#C…”,“M…”], catJump = 1, mouseJump = 2</p>
<p>输出：true</p>
<p>解释：猫无法抓到老鼠，也没法比老鼠先到达食物。</p>
<p>2、</p>
<p><img src="/2022/05/10/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-10/2.png" alt="image-20220510184711602"></p>
<p>输入：grid = [“M.C…F”], catJump = 1, mouseJump = 4</p>
<p>输出：true</p>
<p>3、</p>
<p>输入：grid = [“M.C…F”], catJump = 1, mouseJump = 3</p>
<p>输出：false</p>
<p>4、</p>
<p>输入：grid = [“C…#”,“…#F”,“…#”,“M…”], catJump = 2, mouseJump = 5</p>
<p>输出：false</p>
<p>5、</p>
<p>输入：grid = [“.M…”,“…#…”,“#…#.”,“C#.#.”,“…#F”], catJump = 3, mouseJump = 1</p>
<p>输出：true</p>
<h3 id="提示-11">提示</h3>
<ul>
<li>rows = grid.length</li>
<li>cols = grid[i].length</li>
<li>$1 \leq rows$, $cols \leq 8$</li>
<li>grid[i][j] 只包含字符 ‘C’ ，‘M’ ，‘F’ ，‘.’ 和 ‘#’ 。</li>
<li>grid 中只包含一个 ‘C’ ，‘M’ 和 ‘F’ 。</li>
<li>$1\leq catJump$, $mouseJump \leq 8$</li>
</ul>
<h3 id="来源-15">来源</h3>
<p>力扣（LeetCode）链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii">https://leetcode.cn/problems/cat-and-mouse-ii</a></p>
<h2 id="问题解答-15">问题解答</h2>
<p>该题未解答出来，下面是优质题解</p>
<h4 id="1、拓扑排序">1、拓扑排序</h4>
<h5 id="介绍">介绍</h5>
<p>此题解需要提前了解博弈问题中的必胜状态、必败状态与必和状态的概念，以及最优策略。</p>
<p>博弈问题通常可以使用动态规划求解。由于动态规划的时间复杂度和游戏轮数有关，因此动态规划的时间复杂度较高。博弈问题的另一种解法是拓扑排序。和动态规划相比，拓扑排序的时间复杂度和游戏轮数无关，因此拓扑排序的时间复杂度较低。下面是用拓扑排序解此题的思路</p>
<h5 id="概述">概述</h5>
<p>给定的网格包含 rows行和 cols列，网格中的单元格总数是 $total=rows×cols$。每个单元格对应一个编号，第 i 行第 j 列的单元格编号是$ i×cols+j$，其中$0≤i&lt;rows$，$0≤j&lt;cols$。</p>
<p>首先遍历网格，得到猫和老鼠初始时所在的单元格以及食物所在的单元格，然后计算获胜方。</p>
<h5 id="求解简化问题">求解简化问题</h5>
<p>这道题规定了移动次数上限为1000，如果在 1000次移动之内老鼠不能获胜，则猫获胜。可以首先考虑一个简化问题，在没有移动次数上限的情况下计算获胜方。该简化问题可以使用拓扑排序得到结果。</p>
<p>游戏中的状态由老鼠的位置、猫的位置和轮到移动的一方三个因素决定。初始时，只有边界情况的胜负结果已知，其余所有状态的结果都初始化为未知。边界情况为直接确定胜负的情况，包括三种情况：</p>
<ul>
<li>猫和老鼠在同一个单元格，无论在哪个单元格，都是猫获胜；</li>
<li>猫和食物在同一个单元格，无论老鼠在哪个单元格，都是猫获胜；</li>
<li>老鼠和食物在同一个单元格，只要猫和食物不在同一个单元格，无论猫在哪个单元格，都是老鼠获胜。</li>
</ul>
<p>从边界情况出发遍历其他情况。对于当前状态，可以得到老鼠所在的单元格、猫所在的单元格和轮到移动的一方，根据当前状态可知上一轮的所有可能状态，其中上一轮的移动方和当前的移动方相反，上一轮的移动方在上一轮状态和当前状态所在的单元格相同或不同（注意可以停留在原地）。假设当前状态是老鼠所在的单元格编号是 mouse，猫所在的单元格编号是 cat，则根据当前的移动方，可以得到上一轮的所有可能状态：</p>
<ul>
<li>如果当前的移动方是老鼠，则上一轮的移动方是猫，上一轮状态中老鼠所在的单元格编号是 mouse，猫所在的单元格编号可能是 cat 或者向四个方向之一跳跃到达的单元格编号，跳跃的距离不超过 catJump且不能跳过墙及不能跳出网格；</li>
<li>如果当前的移动方是猫，则上一轮的移动方是老鼠，上一轮状态中猫所在的单元格编号是 cat，老鼠所在的单元格编号可能是 mouse或者向四个方向之一跳跃到达的单元格编号，跳跃的距离不超过 mouseJump且不能跳过墙及不能跳出网格。</li>
</ul>
<p>对于上一轮的每一种可能的状态，如果该状态的结果已知，则不需要重复计算该状态的结果，只有对结果未知的状态，才需要计算该状态的结果。对于上一轮的移动方，只有当可以确定上一轮状态是必胜状态或者必败状态时，才更新上一轮状态的结果。</p>
<ul>
<li>如果上一轮的移动方和当前状态的获胜方相同，由于当前状态为上一轮的移动方的必胜状态，因此上一轮的移动方一定可以移动到当前状态而获胜，上一轮状态为上一轮的移动方的必胜状态。</li>
<li>如果上一轮的移动方和当前状态的获胜方不同，则上一轮的移动方需要尝试其他可能的移动，可能有以下三种情况：
<ul>
<li>如果存在一种移动可以到达上一轮的移动方的必胜状态，则上一轮状态为上一轮的移动方的必胜状态；</li>
<li>如果所有的移动都到达上一轮的移动方的必败状态，则上一轮状态为上一轮的移动方的必败状态；</li>
<li>如果所有的移动都不能到达上一轮的移动方的必胜状态，但是存在一种移动可以到达上一轮的移动方的未知状态，则上一轮状态为上一轮的移动方的未知状态。</li>
</ul>
</li>
</ul>
<p>其中，对于必败状态与未知状态的判断依据为上一轮的移动方可能的移动是都到达必败状态还是可以到达未知状态。为了实现必败状态与未知状态的判断，需要记录每个状态的度，初始时每个状态的度为当前玩家在当前单元格可以到达的单元格数，由于可以停留在原地，因此初始时每个状态的度为当前玩家在当前单元格可以跳跃到达的单元格数加 1。</p>
<p>遍历过程中，从当前状态出发遍历上一轮的所有可能状态，如果上一轮状态的结果未知且上一轮的移动方和当前状态的获胜方不同，则将上一轮状态的度减 1。如果上一轮状态的度减少到 0，则从上一轮状态出发到达的所有状态都是上一轮的移动方的必败状态，因此上一轮状态也是上一轮的移动方的必败状态。</p>
<p>在确定上一轮状态的结果（必胜或必败）之后，即可从上一轮状态出发，遍历其他的未知状态。当没有更多的状态可以确定胜负结果时，遍历结束，此时即可得到初始状态的结果。</p>
<h5 id="求解原始问题">求解原始问题</h5>
<p>上述解法为简化问题的解法，没有考虑移动次数的上限。由于移动次数的限制只会影响到平局以及老鼠获胜的条件，因此只需要对平局和老鼠获胜的情况考虑移动次数。</p>
<p>平局对应上述解法中的未知状态，表示当猫和老鼠都按照最优策略参与游戏时，双方都无法在有限的移动次数内到达食物所在的单元格，移动次数一定会超过老鼠获胜的上限，因此未知状态对应的结果都是猫获胜。</p>
<p>如果在简化问题中，从初始状态开始游戏的结果是老鼠获胜，即老鼠先到达食物，则在原始问题中，需要计算从初始状态至老鼠到达食物的移动次数，只有当移动次数不超过1000时，老鼠才能获胜，否则猫获胜。</p>
<p>为了计算从初始状态至老鼠到达食物的移动次数，在拓扑排序的过程中除了记录每个状态的结果以外，还需要记录从边界情况到达每个状态的移动次数，等价于从每个状态到边界情况的移动次数。每个状态对应的移动次数计算方法如下：</p>
<ul>
<li>边界情况可以直接确定胜负，因此移动次数为0；</li>
<li>如果状态 $s_1$和状态 $s_2$相邻（即状态 $s_2$是状态 $s_1$的上一轮的状态之一），且状态 $s_1$的结果和移动次数已知，记状态 $s_1$的移动次数为 x，如果可以确定状态 $s_2$的结果，则状态 $s_2$的移动次数为 x+1。</li>
</ul>
<h5 id="证明">证明</h5>
<p>对于上述解法的正确性证明，需要证明两点，一是未知状态的正确性，二是移动次数的正确性。</p>
<p>证明一：未知状态的正确性</p>
<p>遍历结束之后，如果一个状态的结果未知，则该状态满足以下两个条件：</p>
<ul>
<li>从该状态出发，任何移动都无法到达该状态的移动方的必胜状态；</li>
<li>从该状态出发，存在一种移动可以到达未知状态。</li>
</ul>
<p>对于结果未知的状态，如果其实际结果是该状态的移动方必胜，则一定存在一个下一轮状态，为当前状态的移动方的必胜状态，在根据下一轮状态的结果标记当前状态的结果时会将当前状态标记为当前状态的移动方的必胜状态，和结果未知矛盾。</p>
<p>对于结果未知的状态，如果其实际结果是该状态的移动方必败，则所有的下一轮状态都为当前状态的移动方的必败状态，在根据下一轮状态的结果标记当前状态的结果时会将当前状态标记为当前状态的移动方的必败状态，和结果未知矛盾。</p>
<p>因此，对于结果不是任何一方必胜的状态，实际结果一定是未知。根据游戏规则，未知状态表示在该状态下当猫和老鼠都按照最优策略参与游戏时，双方都无法在有限的移动次数内到达食物所在的单元格，移动次数一定会超过老鼠获胜的上限，因此未知状态对应的结果都是猫获胜。</p>
<h5 id="证明二：移动次数的正确性">证明二：移动次数的正确性</h5>
<p>在考虑移动次数的情况下，每个玩家的最优策略应满足以下三点：</p>
<ul>
<li>当自己可以到达必胜状态时，应将移动次数最小化；</li>
<li>当自己无法到达必胜状态时，如果可以避免自己到达必败状态，则应到达未知状态；</li>
<li>当无法避免自己到达必败状态时，应将移动次数最大化。</li>
</ul>
<p>由于拓扑排序的实现方式是广度优先搜索，因此拓扑排序的过程中遍历状态的顺序为移动次数递增的顺序。</p>
<p>边界情况的移动次数为 0。从已知状态出发计算未知状态的结果和移动次数，将已知状态记为$s_1$，未知状态记为 $s_2$，且状态 s_1 和状态 s_2相邻（即状态 s_2是状态 $s_1$的上一轮的状态之一），记状态 $s_1$的移动次数为 x，考虑以下两种情况。</p>
<ul>
<li>
<p>如果状态$s_2$ 的移动方和状态 $s_1$的获胜方相同，则状态 $s_2$的移动方会移动到状态 $s_1$从而确保胜利，因此状态 $s_2$的移动方必胜，移动次数为 x+1，且该移动次数为状态 $s_2$到边界情况的最少移动次数。</p>
<p><strong>假设存在另一个已知状态$s_3$的获胜方和状态$s_1$相同且状态$s_3$的移动次数小于 x，则状态$s_3$在状态$s_1$之前被遍历，在遍历到状态$s_3$时就会更新状态$s_2$的结果，和遍历到状态$s_1$时状态$s_2$的结果未知矛盾。因此状态$s_2$的最少移动次数为 x+1。</strong></p>
</li>
<li>
<p>如果状态 $s_2$的移动方和状态 $s_1$的获胜方不同，则只有当状态 $s_2$的所有相邻状态都已知是状态 $s_2$的移动方的必败状态时，才能确定状态 $s_2$ 的移动方必败。如果在遍历到状态 $s_1$ 时可以确定状态 $s_2$的结果为移动方必败，则在遍历到状态 $s_1$之前，状态 $s_2$ 的所有相邻状态都已经遍历过，即状态 $s_1$ 是最后一个遍历到的状态 $s_2$的相邻状态，因此在状态 $s_2$ 的所有相邻状态中，状态 $s_1$的移动次数最多，状态 $s_2$的移动次数是 x+1符合必败状态下将移动次数最大化。</p>
</li>
</ul>
<h5 id="代码-16">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MOUSE_TURN = <span class="number">0</span></span><br><span class="line">CAT_TURN = <span class="number">1</span></span><br><span class="line">UNKNOWN = <span class="number">0</span></span><br><span class="line">MOUSE_WIN = <span class="number">1</span></span><br><span class="line">CAT_WIN = <span class="number">2</span></span><br><span class="line">MAX_MOVES = <span class="number">1000</span></span><br><span class="line">DIRS = ((-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMouseWin</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], catJump: <span class="built_in">int</span>, mouseJump: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPos</span>(<span class="params">row: <span class="built_in">int</span>, col: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">return</span> row * cols + col</span><br><span class="line"></span><br><span class="line">        startMouse = startCat = food = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                    startMouse = getPos(i, j)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                    startCat = getPos(i, j)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">                    food = getPos(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算每个状态的度</span></span><br><span class="line">        total = rows * cols</span><br><span class="line">        degrees = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)]</span><br><span class="line">        <span class="keyword">for</span> mouse <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            mouseRow, mouseCol = <span class="built_in">divmod</span>(mouse, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[mouseRow][mouseCol] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> cat <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">                catRow, catCol = <span class="built_in">divmod</span>(cat, cols)</span><br><span class="line">                <span class="keyword">if</span> grid[catRow][catCol] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                degrees[mouse][cat][MOUSE_TURN] += <span class="number">1</span></span><br><span class="line">                degrees[mouse][cat][CAT_TURN] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                    row, col, jump = mouseRow + dx, mouseCol + dy, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="number">0</span> &lt;= row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols <span class="keyword">and</span> grid[row][col] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> jump &lt;= mouseJump:</span><br><span class="line">                        nextMouse = getPos(row, col)</span><br><span class="line">                        nextCat = getPos(catRow, catCol)</span><br><span class="line">                        degrees[nextMouse][nextCat][MOUSE_TURN] += <span class="number">1</span></span><br><span class="line">                        row += dx</span><br><span class="line">                        col += dy</span><br><span class="line">                        jump += <span class="number">1</span></span><br><span class="line">                    row, col, jump = catRow + dx, catCol + dy, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="number">0</span> &lt;= row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols <span class="keyword">and</span> grid[row][col] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> jump &lt;= catJump:</span><br><span class="line">                        nextMouse = getPos(mouseRow, mouseCol)</span><br><span class="line">                        nextCat = getPos(row, col)</span><br><span class="line">                        degrees[nextMouse][nextCat][CAT_TURN] += <span class="number">1</span></span><br><span class="line">                        row += dx</span><br><span class="line">                        col += dy</span><br><span class="line">                        jump += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        results = [[[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)]</span><br><span class="line">        q = deque()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 猫和老鼠在同一个单元格，猫获胜</span></span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            row, col = <span class="built_in">divmod</span>(pos, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results[pos][pos][MOUSE_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[pos][pos][MOUSE_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            results[pos][pos][CAT_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[pos][pos][CAT_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            q.append((pos, pos, MOUSE_TURN))</span><br><span class="line">            q.append((pos, pos, CAT_TURN))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 猫和食物在同一个单元格，猫获胜</span></span><br><span class="line">        <span class="keyword">for</span> mouse <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            mouseRow, mouseCol = <span class="built_in">divmod</span>(mouse, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[mouseRow][mouseCol] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> mouse == food:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results[mouse][food][MOUSE_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[mouse][food][MOUSE_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            results[mouse][food][CAT_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[mouse][food][CAT_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            q.append((mouse, food, MOUSE_TURN))</span><br><span class="line">            q.append((mouse, food, CAT_TURN))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜</span></span><br><span class="line">        <span class="keyword">for</span> cat <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            catRow, catCol = <span class="built_in">divmod</span>(cat, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[catRow][catCol] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> cat == food:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results[food][cat][MOUSE_TURN][<span class="number">0</span>] = MOUSE_WIN</span><br><span class="line">            results[food][cat][MOUSE_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            results[food][cat][CAT_TURN][<span class="number">0</span>] = MOUSE_WIN</span><br><span class="line">            results[food][cat][CAT_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            q.append((food, cat, MOUSE_TURN))</span><br><span class="line">            q.append((food, cat, CAT_TURN))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPrevStates</span>(<span class="params">mouse: <span class="built_in">int</span>, cat: <span class="built_in">int</span>, turn: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>]]:</span><br><span class="line">            mouseRow, mouseCol = <span class="built_in">divmod</span>(mouse, cols)</span><br><span class="line">            catRow, catCol = <span class="built_in">divmod</span>(cat, cols)</span><br><span class="line">            prevTurn = CAT_TURN <span class="keyword">if</span> turn == MOUSE_TURN <span class="keyword">else</span> MOUSE_TURN</span><br><span class="line">            maxJump = mouseJump <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> catJump</span><br><span class="line">            startRow = mouseRow <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> catRow</span><br><span class="line">            startCol = mouseCol <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> catCol</span><br><span class="line">            prevStates = [(mouse, cat, prevTurn)]</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                i, j, jump = startRow + dx, startCol + dy, <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="number">0</span> &lt;= i &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; cols <span class="keyword">and</span> grid[i][j] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> jump &lt;= maxJump:</span><br><span class="line">                    prevMouseRow = i <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> mouseRow</span><br><span class="line">                    prevMouseCol = j <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> mouseCol</span><br><span class="line">                    prevCatRow = catRow <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> i</span><br><span class="line">                    prevCatCol = catCol <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> j</span><br><span class="line">                    prevMouse = getPos(prevMouseRow, prevMouseCol)</span><br><span class="line">                    prevCat = getPos(prevCatRow, prevCatCol)</span><br><span class="line">                    prevStates.append((prevMouse, prevCat, prevTurn))</span><br><span class="line">                    i += dx</span><br><span class="line">                    j += dy</span><br><span class="line">                    jump += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> prevStates</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            mouse, cat, turn = q.popleft()</span><br><span class="line">            result = results[mouse][cat][turn][<span class="number">0</span>]</span><br><span class="line">            moves = results[mouse][cat][turn][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> prevMouse, prevCat, prevTurn <span class="keyword">in</span> getPrevStates(mouse, cat, turn):</span><br><span class="line">                <span class="keyword">if</span> results[prevMouse][prevCat][prevTurn][<span class="number">0</span>] == UNKNOWN:</span><br><span class="line">                    <span class="keyword">if</span> result == MOUSE_WIN <span class="keyword">and</span> prevTurn == MOUSE_TURN <span class="keyword">or</span> result == CAT_WIN <span class="keyword">and</span> prevTurn == CAT_TURN:</span><br><span class="line">                        results[prevMouse][prevCat][prevTurn][<span class="number">0</span>] = result</span><br><span class="line">                        results[prevMouse][prevCat][prevTurn][<span class="number">1</span>] = moves + <span class="number">1</span></span><br><span class="line">                        q.append((prevMouse, prevCat, prevTurn))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        degrees[prevMouse][prevCat][prevTurn] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> degrees[prevMouse][prevCat][prevTurn] == <span class="number">0</span>:</span><br><span class="line">                            loseResult = CAT_WIN <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> MOUSE_WIN</span><br><span class="line">                            results[prevMouse][prevCat][prevTurn][<span class="number">0</span>] = loseResult</span><br><span class="line">                            results[prevMouse][prevCat][prevTurn][<span class="number">1</span>] = moves + <span class="number">1</span></span><br><span class="line">                            q.append((prevMouse, prevCat, prevTurn))</span><br><span class="line">        <span class="keyword">return</span> results[startMouse][startCat][MOUSE_TURN][<span class="number">0</span>] == MOUSE_WIN <span class="keyword">and</span> results[startMouse][startCat][MOUSE_TURN][<span class="number">1</span>] &lt;= MAX_MOVES</span><br></pre></td></tr></table></figure>
<h5 id="作者-8">作者</h5>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-leetcode-solution-e5io/">https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-leetcode-solution-e5io/</a></p>
<h4 id="2、博弈树搜索（暴力法）">2、博弈树搜索（暴力法）</h4>
<h5 id="介绍-2">介绍</h5>
<p>基本思路就是深度优先搜索整个博弈树，同时使用记忆化的方法（即记录搜索过的状态避免重复搜索），再加上剪枝策略：当前状态如果有胜利的走法，那么就无需继续向下搜索了。一个小优化是，搜索顺序对剪枝的效率有很大影响，所以这里设置了一个顺序，老鼠先搜索距离食物距离更近的点，猫先搜索距离老鼠和食物更近的点。</p>
<h5 id="代码-17">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    DIR = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMouseWin</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], catJump: <span class="built_in">int</span>, mouseJump: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            grid[i] = <span class="built_in">list</span>(grid[i])</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">                <span class="keyword">if</span> y == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                    cat = (i, j)</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> y == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                    mouse = (i, j)</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> y == <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">                    food = (i, j)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cat, mouse, t</span>):</span><br><span class="line">            <span class="comment"># 猫的位置、老鼠位置，回合数</span></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">128</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            win = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 老鼠的回合</span></span><br><span class="line">            <span class="keyword">if</span> t % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                x, y = mouse</span><br><span class="line">                nxt = <span class="built_in">list</span>()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.DIR:</span><br><span class="line">                    nx, ny = x, y</span><br><span class="line">                    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(mouseJump + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> (nx != cat[<span class="number">0</span>] <span class="keyword">or</span> ny != cat[<span class="number">1</span>]):</span><br><span class="line">                            <span class="keyword">if</span> grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">                            nxt.append((nx, ny))</span><br><span class="line">                        nx += dx</span><br><span class="line">                        ny += dy</span><br><span class="line">              	<span class="comment"># 按照（nx，ny）与食物位置的曼哈顿距离进行升序排列</span></span><br><span class="line">                nxt.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (i - j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, food)))))<span class="comment"># 使用lambda可以定义一个匿名函数。</span></span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> nxt:</span><br><span class="line">                    <span class="comment"># 老鼠获得食物，获胜</span></span><br><span class="line">                    win = grid[nx][ny] == <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> <span class="keyword">not</span> dfs(cat, (nx, ny), t + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> win: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 猫的回合</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x, y = cat</span><br><span class="line">                nxt = <span class="built_in">list</span>()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.DIR:</span><br><span class="line">                    nx, ny = x, y</span><br><span class="line">                    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(catJump + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m:</span><br><span class="line">                            <span class="keyword">if</span> grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">                            nxt.append((nx, ny))</span><br><span class="line">                        nx += dx</span><br><span class="line">                        ny += dy</span><br><span class="line">                <span class="comment"># 按照（nx，ny）与食物位置和老鼠位置的曼哈顿距离的最小值进行升序排列</span></span><br><span class="line">                nxt.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">min</span>(<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (i - j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, food)))), <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (i - j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, mouse))))))</span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> nxt:</span><br><span class="line">                    <span class="comment"># 猫获得食物或抓住老鼠，获胜</span></span><br><span class="line">                    win = (nx == mouse[<span class="number">0</span>] <span class="keyword">and</span> ny == mouse[<span class="number">1</span>]) <span class="keyword">or</span> grid[nx][ny] == <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> <span class="keyword">not</span> dfs((nx, ny), mouse, t + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> win: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> win</span><br><span class="line">        <span class="keyword">return</span> dfs(cat, mouse, <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(max(catJump,mouseJump)^{max_deep})$，这里最大搜索深度$max_deep$设置为 128，当然这是理论上界，实际上剪枝和记忆化后远远达不到这个上界</p>
<p>PS：注意这里不能按照题目给的 1000 回合进行搜索，这样必定会超时，不加优化策略的情况下可以设置为 128 （即地图大小 64 的两倍，不过目前还没有严谨的证明 “128 回合老鼠还没有获胜那就必定获胜”），更不严谨的，可以设置最大回合数为“猫与食物距离”的 16 倍（测试得到，无法保证正确性）。</p>
<p>空间复杂度: $O(n×m×max_deep)$，状态空间为地图大小和回合数的乘积</p>
<h5 id="作者-9">作者</h5>
<p>meteordream，链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-meteordream-be5y/">https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-meteordream-be5y/</a></p>
<h4 id="3、极大极小博弈">3、极大极小博弈</h4>
<p>对于老鼠来说，最好的情况是自己赢，我们认定该情景是-1分；其次好的情况是平局，我们认定该情景是0分；最差的情况是猫赢，我们认定该情景是1分。也就是说对于老鼠来说，想要得分尽可能小，而对于猫来说，想要得分尽可能大，这就是经典的最大最小博弈了。</p>
<p>平局分析：认定走了足够到遍历所有该去的尝试赢的走法的点，仍然无法结束。实际状态最多有 $8 * 8 * 8 * 8 * 2$ 种，可以用题目描述的1000作为界，但是会超出时间限制。猜测128为回合阈值，如果TLE可以调小一点，大于64，不会证明, 不保证正确性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIRS = (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMouseWin</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], catJump: <span class="built_in">int</span>, mouseJump: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        mm, nn = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">                match grid[x][y]:</span><br><span class="line">                    case <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                        cat = x, y</span><br><span class="line">                    case <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">                        food = x, y</span><br><span class="line">                    case <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                        mouse = x, y</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">m, c, i</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            极大极小博弈，</span></span><br><span class="line"><span class="string">            老鼠尽量找自己获胜的，其次接受平局</span></span><br><span class="line"><span class="string">            猫尽量找自己获胜的，其次接受平局</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            :param m: 老鼠的位置</span></span><br><span class="line"><span class="string">            :param c: 猫的位置</span></span><br><span class="line"><span class="string">            :param i: 回合</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> m == c <span class="keyword">or</span> c == food <span class="keyword">or</span> i &gt; <span class="number">128</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> m == food:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            is_cat = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 猫回合</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                pos, jump = c, catJump</span><br><span class="line">                is_cat = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos, jump = m, mouseJump</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                <span class="keyword">for</span> jp <span class="keyword">in</span> <span class="built_in">range</span>(jump + <span class="number">1</span>):</span><br><span class="line">                    nx, ny = pos[<span class="number">0</span>] + dx * jp, pos[<span class="number">1</span>] + dy * jp</span><br><span class="line">                    <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= mm <span class="keyword">or</span> ny &gt;= nn <span class="keyword">or</span> grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> is_cat <span class="keyword">and</span> dfs((nx, ny), c, i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> is_cat <span class="keyword">and</span> <span class="keyword">not</span> dfs(m, (nx, ny), i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> is_cat</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(mouse, cat, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="作者-10">作者</h5>
<p>himymBen，链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/python-ji-xiao-ji-da-bo-yi-by-himymben-ukbk/">https://leetcode.cn/problems/cat-and-mouse-ii/solution/python-ji-xiao-ji-da-bo-yi-by-himymben-ukbk/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-9</title>
    <url>/2022/05/09/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-9/</url>
    <content><![CDATA[<h2 id="问题介绍">问题介绍</h2>
<h3 id="题目：增减字符串匹配">题目：增减字符串匹配</h3>
<p>由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:</p>
<p>​    如果 <code>perm[i] &lt; perm[i + 1] </code>，那么<code> s[i] == 'I'</code></p>
<p>​    如果 <code>perm[i] &gt; perm[i + 1]</code> ，那么<code>s[i] == 'D'</code></p>
<p>给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。</p>
<h3 id="示例-6">示例</h3>
<ol>
<li>输入：<code>s = &quot;IDID&quot;</code></li>
</ol>
<p>输出：<code>[0,4,1,3,2]</code></p>
<ol start="2">
<li>
<p>输入：<code>s = &quot;III&quot;</code></p>
<p>输出：<code>[0,1,2,3]</code></p>
</li>
<li>
<p>输入：<code>s = &quot;DDI&quot;</code></p>
</li>
</ol>
<p>输出：<code>[3,2,0,1]</code></p>
<h3 id="提示-2">提示</h3>
<ol>
<li>$ 1 \leq s.length \leq 10^5 $</li>
<li>s 只包含字符 “I” 或 “D”</li>
</ol>
<h3 id="来源-6">来源</h3>
<p>力扣（LeetCode）链接：<a href="https://leetcode.cn/problems/di-string-match">https://leetcode.cn/problems/di-string-match</a></p>
<h2 id="问题解答-6">问题解答</h2>
<h3 id="思路-5">思路</h3>
<p>可以发现“III”的输出是增序，“DDD”是降序。所以某一位置出现I可以表示该位置为未分配的数字中的最小值，D则可以表示该位置为未分配的数字中的最大值。按照这样的想法，使用双指针，一个指向最小值，一个指向最大值，按照字符串s的顺序添加进列表即可。</p>
<h3 id="代码-9">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diStringMatch</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        s = s + <span class="string">&#x27;I&#x27;</span> <span class="comment"># 因为字符串长度为n，而实际有n+1个数，所以可以加一个I或D使得字符串一个字符对应一个数</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = length</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> s[n] == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                result.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(j)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Tranformer模型细节及pytorch实现</title>
    <url>/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="Transformer模型的基本结构">Transformer模型的基本结构</h2>
<p>下图是Transformer用于中英文翻译的整体结构：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>从上图可以看到Transformer由编码器和解码器两个部分组成，Encoder和Decoder均可以有多个进行堆叠。</p>
<h3 id="工作流程">工作流程</h3>
<p>以上面的中英文翻译为例来介绍Transformer的工作流程：</p>
<p><strong>第一步</strong>：获取输入句子的每一个单词的表示向量 X。向量X由该单词的 Embedding和单词位置的 Embedding 相加得到。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/2.png" alt></p>
<p>注：想了解词嵌入的可以去看文档：<a href="https://wenku.baidu.com/view/891928f17c192279168884868762caaedd33ba7a.html">深度学习-Embedding（词嵌入）</a></p>
<p><strong>第二步</strong>：将得到的单词表示向量矩阵 (如上图所示，每一行是一个单词的表示 x) 输入 Encoder 中后可以得到句子所有单词的编码信息矩阵 C，如下图。单词向量矩阵用 $X_n\times d$表示， n 是句子中单词个数，d 是表示向量的维度 (Transformer论文中 d=512)。其中每一个 Encoder block 输出的矩阵维度与输入完全一致。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/3.png" alt></p>
<p><strong>第三步</strong>：将 Encoder 输出的编码信息矩阵 C传递到 Decoder 中，Decoder  依次会根据当前翻译过的单词 1~ i 来翻译下一个单词 i+1，如下图所示。在使用的过程中，翻译到单词 i+1 的时候需要通过 Mask (掩盖) 操作遮盖住 i+1 之后的单词，从而避免通过i+1后面的单词翻译单词i+1。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/4.png" alt></p>
<p>上图 Decoder 接收了 Encoder 的编码矩阵 C，然后首先输入一个翻译开始符 &lt;Begin&gt;，预测第一个单词 “I”；然后输入翻译开始符 &lt;Begin&gt;和单词 “I”，预测单词 “have”，以此类推。</p>
<p>如果加上Encoder和Decoder的细节，便可以得到下图经典的Transformer模型结构图：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/5.jpeg" alt></p>
<h2 id="Transformer模型各结构细节">Transformer模型各结构细节</h2>
<p>下面将根据Transformer的工作流程介绍每个部分的细节。</p>
<h3 id="Positional-Encoding">Positional Encoding</h3>
<p>Transformer 模型没有循环神经网络那样可以通过迭代来挖掘输入的顺序关系，所以在用Transformer进行相关需要顺序关系的任务时，必须提供每个字的位置信息给 Transformer，这样它才能识别出输入数据的顺序关系。</p>
<p>Positional Encoding也就是位置嵌入，位置嵌入的维度为 [max_sequence_length, embedding_dimension]，位置嵌入的第二个维度与词向量的维度是相同的，都是 embedding_dimension。max_sequence_length属于超参数，指的是限定每个句子最长由多少个词构成。</p>
<p>注意，以中英文翻译为例，一般以字为单位训练 Transformer 模型，因此初始化字编码的大小为 [vocab_size, embedding_dimension]，vocab_size为字库的大小，embedding_dimension为字向量的维度，对应到 PyTorch 代码中，其实就是 <code>nn.Embedding(vocab_size, embedding_dimension)</code></p>
<p>论文中使用了 sin 和 cos 函数的线性变换来提供给模型位置信息:</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/5.png" alt></p>
<p>其中，pos 表示单词在句子中的位置，范围是[0,max_sequence_length]；d 表示位置嵌入的维度，即等于embedding_dimension；2i 表示偶数的维度，2i+1 表示奇数维度（即 $2i≤d, 2i+1≤d$）。</p>
<p>Transformer通过sin和cos函数对位置信息进行处理，从而产生不同的周期性变化（同一维度，不同位置时，其编码呈现周期性），而位置嵌入在 embedding_dimension维度上随着维度序号增大，周期变化会越来越慢，最终产生一种包含位置信息的纹理，正如论文原文中第六页讲的，位置嵌入函数的周期从$2\pi$到$10000* 2\pi$变化，而每一个位置在 embedding_dimension维度上都会得到不同周期的sin和cos函数的取值组合，从而产生独一的纹理位置信息（同一位置，不同维度时，呈现独一的变化趋势），最终使得模型学到位置之间的依赖关系和自然语言的时序特性。以下两图展示了上面所说的两者变化情况：</p>
<p>固定d=512，embedding_dimension第1个和第50个维度的前100个位置值编码变化图：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/6.png" alt></p>
<p>固定d=512，第1个、第10个和第50个位置的embedding_dimension从1到100对应的位置编码变化图：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/7.png" alt></p>
<h3 id="Self-Attention-Mechanism">Self -Attention Mechanism</h3>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/8.png" alt></p>
<p>上图就是Self-Attention 的结构，它的输入有三个矩阵：<strong>查询矩阵Q</strong>、<strong>键矩阵K</strong>、<strong>值矩阵V</strong>。在实际中，Self-Attention 接收的是输入是单词的表示向量x组成的矩阵X， 或者上一个 Encoder block 的输出。而Q、K、V正是通过 Self-Attention 的输入进行线性变换得到的。</p>
<p>Self-Attention 的输入用矩阵X进行表示，则可以使用线性变阵矩阵WQ、WK、WV计算得到Q、K、V。计算如下图所示，注意 X、Q、K、V 的每一行都表示一个单词。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/9.png" alt></p>
<p>得到矩阵 Q、K、V之后就可以计算出 Self-Attention 的输出了，计算的公式如下：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/10.png" alt></p>
<ul>
<li>公式中先计算矩阵Q和K每一行向量的内积，为了防止内积过大，因此除以$d_k$ 的平方根。</li>
<li>Q乘以K的转置后，得到的矩阵行列数都为 n，n 为句子单词数，因此这个矩阵可以表示单词之间的注意力大小。</li>
<li>得到$QK^T$之后，使用 Softmax 计算每一个单词对于其他单词的注意力大小，公式中的 Softmax 是对矩阵的每一行进行 Softmax，即每一行的和都变为 1。</li>
<li>得到 Softmax 矩阵之后可以和V相乘，得到最终的输出Z，这就相当于根据注意力来对单词相应位置进行加权和。</li>
</ul>
<h3 id="Multi-Head-Attention">Multi-Head Attention</h3>
<p>Multi-Head Attention 是由多个 Self-Attention 组合形成的，下图是论文中 Multi-Head Attention 的结构图。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/11.png" alt></p>
<p>从上图可以看到 Multi-Head Attention 包含多个 Self-Attention 层，首先将输入X分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵$Z_1\dots Z_h$。得到 h个输出矩阵之后，Multi-Head Attention 将它们拼接在一起 (Concat)，然后传入一个Linear层，得到 Multi-Head Attention 最终的输出Z。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/12.png" alt></p>
<h3 id="Padding-Mask">Padding Mask</h3>
<p>Self-Attention的计算过程中，通常使用mini-batch来计算，也就是一次计算多句话，即输入X的维度是 [batch_size, sequence_length]，sequence_length是句子长度，所以一个 mini-batch 是由多个不等长的句子组成的，为了输入模型中可以统一处理，需要按照这个 mini-batch 中最大的句长对剩余的句子进行补齐，一般用0进行填充，这个过程叫做 padding。但这时在进行 softmax 就会产生问题。因为$e^0=1$是有值的，这样 softmax 中被 padding 的部分也会参与运算，这可能会产生很大的隐患。因此需要做一个 mask 操作，让这些无效的区域不参与运算，一般是给无效区域加一个很大的负数偏置，即</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/13.png" alt="png"></p>
<h3 id="Encoder">Encoder</h3>
<p>下图是Encoder的结构图及其部分细节。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/14.png" alt="png"></p>
<p>运算过程：输入$x_1$、$x_2$经 self-attention 层之后得到$z_1$、$z_2$，然后和输入$x_1$、$x_2$进行残差连接，经过 LayerNorm 后输出给全连接层。全连接层也有一个残差连接和一个 LayerNorm，最后得到该Encoder Block的输出。（每个 Encoder Block 中的 FeedForward 层权重都是共享的）</p>
<h4 id="残差连接">残差连接</h4>
<p>通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/15.png" alt="png"></p>
<h4 id="Layer-Normalization">Layer Normalization</h4>
<p>Layer Normalization的作用是把神经网络中隐藏层归一为标准正态分布，并假设独立同分布，以起到加快训练速度，加速收敛的作用。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/16.png" alt="image-20220506150346432"></p>
<p>即用每一列的每一个元素减去这列的均值，再除以这列的标准差，从而得到归一化后的数值，加$\epsilon$是为了防止分母为 0。</p>
<h4 id="Feed-Forward">Feed Forward</h4>
<p>Feed Forward 层是一个两层的全连接层，第一层的激活函数为 Relu，第二层不使用激活函数，对应的公式如下，其中X是输入且Feed Forward 最终得到的输出矩阵的维度与X一致。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/17.png" alt="image-20220506150346432"></p>
<h3 id="Decoder">Decoder</h3>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/18.png" alt="image"></p>
<p>上图红色部分为 Transformer 的 Decoder Block 结构，与 Encoder Block 相似，但也存在一些区别：</p>
<ul>
<li>包含两个 Multi-Head Attention 层。</li>
<li>第一个 Multi-Head Attention 层采用了 Masked 操作。</li>
<li>第二个 Multi-Head Attention 层的K、V矩阵使用 Encoder 的编码信息矩阵C进行计算，而Q则使用上一个Decoder block 的输出计算。</li>
<li>最后有一个 Softmax 层，用于计算下一个翻译单词的概率。</li>
</ul>
<h4 id="Masked-Multi-Head-Attention">Masked Multi-Head Attention</h4>
<p>Decoder block 的第一个 Multi-Head Attention 采用了 Masked 操作，因为在翻译的过程中是顺序翻译的，即翻译完第 i 个单词，才可以翻译第 i+1 个单词。通过 Masked 操作可以防止第 i 个单词知道 i+1 个单词之后的信息。结构如图所示：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/8.png" alt></p>
<p>上图中的mask是唯一不同于其他多头注意力的地方，实现方式是通过设置一个特殊矩阵，如图所示：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/19.png" alt="image-20220506153029789"></p>
<p>这样，预测当前词时，不会用到该词以后的词的信息。值为-inf是因为，之后再做softmax就能把-inf变为0，从而使得其权重为0。</p>
<h2 id="Transformer的PyTorch实现">Transformer的PyTorch实现</h2>
<p>完成以下实验需要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,Dataset</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h3 id="Positional-Encoding-2">Positional Encoding</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sinusoid_encoding_table</span>(<span class="params">n_position, d_model</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_angle</span>(<span class="params">position, hid_idx</span>):</span><br><span class="line">        <span class="keyword">return</span> position / np.power(<span class="number">10000</span>, <span class="number">2</span> * (hid_idx // <span class="number">2</span>) / d_model)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_posi_angle_vec</span>(<span class="params">position</span>):</span><br><span class="line">        <span class="keyword">return</span> [cal_angle(position, hid_j) <span class="keyword">for</span> hid_j <span class="keyword">in</span> <span class="built_in">range</span>(d_model)]</span><br><span class="line"></span><br><span class="line">    sinusoid_table = np.array([get_posi_angle_vec(pos_i) <span class="keyword">for</span> pos_i <span class="keyword">in</span> <span class="built_in">range</span>(n_position)])</span><br><span class="line">    </span><br><span class="line">    sinusoid_table[:, <span class="number">0</span>::<span class="number">2</span>] = np.sin(sinusoid_table[:, <span class="number">0</span>::<span class="number">2</span>])  <span class="comment"># dim 2i</span></span><br><span class="line">    </span><br><span class="line">    sinusoid_table[:, <span class="number">1</span>::<span class="number">2</span>] = np.cos(sinusoid_table[:, <span class="number">1</span>::<span class="number">2</span>])  <span class="comment"># dim 2i+1</span></span><br><span class="line">    <span class="keyword">return</span> torch.FloatTensor(sinusoid_table)</span><br></pre></td></tr></table></figure>
<h2 id="参考-2">参考</h2>
<p>1、<a href="https://blog.csdn.net/qq_38410428/article/details/112348321">Transformer模型详解（图解最完整版）</a></p>
<p>2、<a href="https://wmathor.com/index.php/archives/1438/">Transformer 详解</a></p>
<p>3、<a href="https://blog.csdn.net/qq_37236745/article/details/107352273">Transformer的PyTorch实现（超详细）</a></p>
]]></content>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Autoformer</title>
    <url>/2022/05/05/Autoformer/</url>
    <content><![CDATA[<h2 id="论文介绍">论文介绍</h2>
<p>论文题目：Autoformer: Decomposition Transformers with Auto-Correlation for Long-Term Series Forecasting（基于深度分解架构和自相关机制的长期序列预测模型）</p>
<p><img src="/2022/05/05/Autoformer/1.png" alt="1"></p>
<p>链接：<a href="https://arxiv.org/abs/2106.13008">https://arxiv.org/abs/2106.13008</a></p>
<h2 id="研究背景">研究背景</h2>
<p>时间序列预测已经被广泛用于能源、交通、气象等众多领域。在实际应用中，尽可能延长预测时效是一个迫切的需求，如能源、交通的长期规划，和气象灾害的早期预警等。</p>
<p>因此，<strong>长期时间序列预测</strong>问题：待预测的序列长度远远大于输入长度，即基于有限的信息预测更长远的未来，在上述需求的大背景下此预测问题极具挑战性。</p>
<p>同时，之前基于Transformer的时间序列预测模型都是通过自注意力机制（self-attention）来捕捉时刻间的依赖，在时序预测上取得了一些进展。但是在长期序列预测中，存在以下不足：</p>
<ul>
<li>
<p>长序列中的复杂时间模式使得<strong>注意力机制难以发现可靠的时序依赖</strong>。</p>
</li>
<li>
<p>由于自注意力机制的二次复杂度问题，实际使用中模型不得不使用其稀疏版本，这会<strong>限制信息利用效率</strong>，影响预测效果。</p>
</li>
</ul>
<p>本文的解决办法是：全面革新Transformer，提出了名为Autoformer的模型，主要包含以下创新：</p>
<ul>
<li>
<p>突破将序列分解作为预处理的传统方法，提出<strong>深度分解架构</strong>，能够从复杂时间模式中分解出可预测性更强的组分，从而更利于预测。</p>
</li>
<li>
<p>基于随机过程理论，提出<strong>自相关机制</strong>，代替只能建立点向连接的注意力机制，实现序列级连接，打破信息利用瓶颈。</p>
</li>
</ul>
<p><img src="/2022/05/05/Autoformer/2.png" alt="2"></p>
<p>在长期预测问题中，Autoformer在能源、交通、经济、气象、疾病五大时序领域大幅超越之前SOTA，实现<strong>38%</strong> 的相对效果提升。</p>
<h2 id="Autoformer">Autoformer</h2>
<p>Autoformer全面革新Transformer，并建立深度分解架构，主要结构包括内部的序列分解单元、自相关机制以及对应的编-解码器。整体结构如下图所示：</p>
<p><img src="/2022/05/05/Autoformer/3.png" alt="3"></p>
<h3 id="序列分解模块">序列分解模块</h3>
<p>序列分解模块把序列看成两部分组成：趋势项和季节项，趋势项反映了序列整体变化的趋势，季节项则反映序列在时间上波动的情况。本文是基于滑动平均思想，平滑时间序列，分离周期项与趋势项：</p>
<p><img src="/2022/05/05/Autoformer/4.png" alt="4"></p>
<p>注：这里的padding是为了保证进行滑动平均得到的趋势项与原序列具有相同的长度。</p>
<p>由上面的Autoformer的整体结构图所示，我们可以发现序列分解模块是嵌入到了模型的内部。了解时序预测的都知道，序列分解在时序预测过程中大多属于预处理阶段，模型再在预处理后的序列进行预测。本文打破了该惯例，将其更新为深度模型的基本内部块，而这种设计使Autoformer具有复杂时间序列的渐进分解能力，更易发现潜藏在复杂时序中规律。</p>
<h3 id="自相关机制">自相关机制</h3>
<p>自相关模块是通过计算序列自相关系数，发现周期依赖项，然后再平移时间做相似子序列的聚合。整体结构如下图所示，其中红色框部分为周期依赖发现，绿色框部分为时延聚合。</p>
<p><img src="/2022/05/05/Autoformer/5.png" alt="image-20220505105859201"></p>
<h4 id="基于周期的依赖发现">基于周期的依赖发现</h4>
<p>自相关系数表示序列${ {X_t} }$与延迟$\tau$时刻的序列${ {X_{x-\tau} } }$之间的相似性。</p>
<p><img src="/2022/05/05/Autoformer/6.png" alt="image-20220505110940247"></p>
<p>这里可以将这种时延相似性看作未归一化的周期估计的置信度，即周期长度为${\tau}$的置信度为$R(\tau)$。</p>
<p><img src="/2022/05/05/Autoformer/7.png" alt="image-20220505140533140"></p>
<p>通过这样的运作，置信度大的周期长度，说明<strong>原序列与此序列之间的相似性越大，从而建立序列与序列的依赖</strong>。</p>
<p>注：这里Roll操作是将左移出去的序列补充到右边空出来的部分，是因为自相关系数计算需要序列是无穷序列，而实际上的序列都是有限序列，所以通过将原序列看成一个周期为L(原序列长度)的周期序列便可以将序列长度无穷化。</p>
<p>这里原序列与延迟${\tau}$的序列计算自相关系数，而${\tau}$的范围是1至L，因此一次自相关机制就需要做L次自相关计算。为了提高效率，本文基于Winer-Khinchin理论，用快速傅里叶变换（FFT）计算自相关系数，使得复杂度仅为O(LlogL)，大大减少了运行时间。对Winer-Khinchin理论和快速傅里叶变换感兴趣的，可以阅读博客：<a href="https://upupming.site/2018/12/27/fourier-transform/#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">傅里叶变换</a>。</p>
<p><img src="/2022/05/05/Autoformer/8.png" alt="image-20220505141934939"></p>
<h4 id="时延聚合">时延聚合</h4>
<p>聚合相似子序列以得到输出序列。</p>
<p>步骤：</p>
<p><img src="/2022/05/05/Autoformer/9.png" alt="image-20220505141356314"></p>
<ol>
<li>这里从L个延迟$\tau$时刻的子序列中选取自相关系数最大的k个子序列。k的选取按照规则：$k = \lfloor c \times \log L\rfloor $</li>
<li>通过softmax将自相关系数映射成概率，值越大，与原序列相似度越大。</li>
<li>依该概率对各延迟τ时刻序列进行加权叠加，最后得到输出序列。</li>
</ol>
<h4 id="创新点">创新点</h4>
<p>自相关模块不同于之前Transformer中的自注意一类的模块，后者更关注与point-wise之间的依赖性，而前者更关注series-wise之间的依赖性。对比图如下：</p>
<p><img src="/2022/05/05/Autoformer/10.png" alt="image-20220505142427595"></p>
<ul>
<li>
<p><strong>Full Attention</strong>：所有引起注意的点都会起作用，来决定当前的预测值。但时间效率低，从而出现了各种稀疏变种。</p>
</li>
<li>
<p><strong>Sparse Attention</strong>：通过top-k选择，将注意退化为稀疏注意，从而使得只关注最引起注意的部分。</p>
</li>
<li>
<p><strong>LogSparse Attention</strong>：只选择距离满足条件的引起注意的点。</p>
</li>
<li>
<p><strong>Auto-Correlation</strong>：自相关机制则不关注点与点的关系，而是实现了序列与序列之间的高效连接，即建立当前预测序列与已知序列的子序列的关系，从而可以更好地利用时序的特点，进行有效信息聚合，打破信息利用瓶颈。同时，自相关机制采用FFT的方法进行相关系数计算，提高了模型的时间效率。</p>
</li>
<li>
<p>同时，本文设计了多头的自相关机制，从而无缝替换自注意力机制。</p>
</li>
</ul>
<h3 id="编-解码器架构">编-解码器架构</h3>
<p>Autoformer没有改变Transformer的编-解码器架构，只是更新了编码器与解码器以利于长时间序列预测任务。</p>
<h4 id="编码器">编码器</h4>
<p><img src="/2022/05/05/Autoformer/11.png" alt="image-20220505144442359"></p>
<p>输入是过去I个时间点长度的序列$X_{en}\in R^{I\times d}$，d为输入的特征数。输出是${S_{en}^{l,2} }$，$l$表示第$l$个编码层。假设有N个编码层，第$l$个编码层可以表示为：$X_{en}^{l}=Encoder(X_{en}^{l-1})$，内部细节如下：</p>
<p><img src="/2022/05/05/Autoformer/12.png" alt="img"></p>
<p>从上述描述中可以看出编码器重点关注时间序列的季节项，输出的是输入的过去时间序列的季节性信息，它将被用做互信息，帮助解码器调整预测结果。</p>
<h4 id="解码器">解码器</h4>
<p><img src="/2022/05/05/Autoformer/13.png" alt="image-20220505150755766"></p>
<p>输入分为三部分：初始季节项$X_{des}\in R^{(\frac{I}{2}+O)\times d}$、初始周期项$X_{det}\in R^{(\frac{I}{2}+O)\times d}$、编码器输出。d：输入特征数、O为预测的时间长度。</p>
<p><img src="/2022/05/05/Autoformer/15.png" alt="image"></p>
<p>解码器包括两个部分：1、对趋势项使用累加操作；2、对季节项使用堆叠自相关机制来挖掘依赖。</p>
<p>假设我们有M个解码层，N个编码层，第$l$个解码层可以表示为：$X_{de}^{l}=Decoder(X_{de}^{l-1}, X_{en}^N)$，其中内部细节为：</p>
<p><img src="/2022/05/05/Autoformer/14.png" alt="image"></p>
<p>最后预测序列等于：$predction = W_{s}*X_{de}^M+\tau_{de}^M$</p>
<h2 id="后续实验与分析">后续实验与分析</h2>
<h3 id="实验">实验</h3>
<p>在6个真实世界的基准上对Autoformer进行了广泛的评估，涵盖了5个主流的时间序列预测应用:能源、交通、经济、天气和疾病。在具有不同预测长度$O\in{96,192,336,720}$的多元结果。</p>
<p><img src="/2022/05/05/Autoformer/16.png" alt="image-20220505153207603"></p>
<p>本文在各种输入-输出设置下，对比了自相关机制与各种自注意力机制，比如，经典Transformer中Full Attention，Informer中PropSparse Attention等。本文提出的自相关机制依然取得了最优的结果</p>
<p><img src="/2022/05/05/Autoformer/17.png" alt="image-20220505153207603"></p>
<h3 id="模型分析">模型分析</h3>
<p><strong>渐进式分解效果：</strong> 随着序列分解单元的数量增加，模型的学到的趋势项会越来越接近数据真实结果，周期项可以更好的捕捉序列变化情况，这验证了渐进式分解的作用。</p>
<p><img src="/2022/05/05/Autoformer/18.png" alt="image-20220505153207603"></p>
<p><strong>时序依赖可视化：</strong> 通过对比可以发现，Autoformer中自相关机制可以正确发掘出每个周期中的下降过程，并且<strong>没有误识别和漏识别</strong>，而自注意力机制存在错误和缺漏。</p>
<p><img src="/2022/05/05/Autoformer/19.png" alt="image-20220505153207603"></p>
<p><strong>效率分析：</strong> 在显存占用和运行时间两个指标上，自相关机制均表现出了优秀的空间时间效率，两个层面均超过自注意力机制，表现出高效$O(L\log L)$的复杂度。</p>
<p><img src="/2022/05/05/Autoformer/20.png" alt="image-20220505153207603"></p>
<h2 id="参考">参考</h2>
<p>1、<a href="https://mp.weixin.qq.com/s/t0aAUYfurprtu7RPl5mqwg">Autoformer:基于深度分解架构和自相关机制的长期序列预测模型</a></p>
<p>2、<a href="https://zhuanlan.zhihu.com/p/472624073">[时序] Autoformer：基于深度分解架构和自相关机制的长期序列预测模型</a></p>
<p>3、<a href="https://blog.csdn.net/yaohaishen/article/details/118611746">Autoformer-时序模型的突破</a></p>
]]></content>
      <tags>
        <tag>论文精读</tag>
      </tags>
  </entry>
  <entry>
    <title>LGBM学习记录</title>
    <url>/2022/04/22/LGBM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="GBDT-Gradient-Boosting-Decision-Tree">GBDT (Gradient Boosting Decision Tree)</h3>
<p>主要思想是利用弱分类器（决策树）迭代训练以得到最优模型，该模型具有<strong>训练效果好、不易过拟合</strong>等优点。</p>
<p>目前已有的 GBDT 工具基本都是基于预排序的决策树算法(如 Xgboost)。这种构建决策树的算法基本思想是：</p>
<p>首先，对所有特征都按照特征的数值进行预排序。其次，在遍历分割点的时候用O(n)的代价找到一个特征上的最好分割点。最后，找到一个特征的分割点后，将数据分裂成左右子节点。</p>
<p>这样的预排序算法的优点是：能精确地找到分割点。缺点也很明显：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次，时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</p>
<h3 id="LGBM（LightGBM）">LGBM（LightGBM）</h3>
<p>LightGBM 的动机：常用的机器学习算法，例如神经网络等算法，都可以用 mini-batch 的方式训练，训练数据的大小不会受到内存限制。而 GBDT 在每一次迭代的时候，都需要遍历整个训练数据集多次。如果把整个训练数据装进内存则会限制训练数据集的大小；如果不装进内存，反复遍历训练数据集又会消耗大量时间。尤其面对工业上海量的数据，普通的 GBDT 算法是不能满足其需求的。LightGBM 提出的主要原因就是为了解决 GBDT 在海量数据上遇到的问题，让 GBDT 可以更好地用于工业实践。</p>
<p>LGBM与传统算法相比具有的优点：更快的训练效率；低内存使用；更高的准确率；支持并行化学习；可处理大规模数据；原生支持类别特征，不需要对类别特征再进行0-1编码。</p>
<h4 id="Histogram-算法">Histogram 算法</h4>
<p>直方图算法的基本思想是先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p>
<p>在计算上的代价也大幅降低，预排序算法每遍历一个特征值就需要计算一次分裂的增益，而直方图算法只需要计算k次（k为超参数），时间复杂度从O(data * feature)优化到O(k * features)。</p>
<p>Histogram 算法由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</p>
<h4 id="Leaf-wise">Leaf-wise</h4>
<p>LGBM抛弃了大多数 GBDT 工具使用的按层生长 (level-wise) 的决策树生长策略，而使用了带有深度限制的按叶子生长 (leaf-wise) 算法。Level-wise 过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上 Level-wise 是一种低效的算法，因为它不加区分的对待同一层的叶子，而实际上很多叶子的分裂增益较低，没必要进行搜索和分裂，从而带来了很多没必要的开销。</p>
<p>Leaf-wise 则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同 Level-wise 相比，在分裂次数相同的情况下，Leaf-wise 可以降低更多的误差，得到更好的精度。Leaf-wise 的缺点是可能会长出比较深的决策树，产生过拟合。因此 LightGBM 在 Leaf-wise 之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p>
<h4 id="Gradient-based-One-Side-Sampling-GOSS">Gradient-based One-Side Sampling(GOSS)</h4>
<p>GOSS技术是去掉了很大一部分梯度很小的数据，只使用剩下的去估计信息增益，避免低梯度长尾部分的影响。由于梯度大的数据在计算信息增益的时候更重要，所以GOSS在小很多的数据上仍然可以取得相当准确的估计值。</p>
<h4 id="Exclusive-Feature-Bundling-EFB">Exclusive Feature Bundling(EFB)</h4>
<p>EFB技术是指捆绑互斥的特征（如他们经常同时取值为0），以减少特征的数量。对互斥特征寻找最佳的捆绑方式是一个NP难问题，不过贪婪算法可以取得相当好的近似率，因此可以在不显著影响分裂点选择的准确性的情况下，显著地减少特征数量。</p>
<h3 id="模型创建">模型创建</h3>
<h4 id="LGBM">LGBM</h4>
<h5 id="方式1：使用lgb的风格">方式1：使用lgb的风格</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LGBM <span class="keyword">as</span> lgb</span><br><span class="line">params_lgb_ = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;regression&#x27;</span>, </span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.1</span>, </span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">50</span>, </span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">6</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.8</span>, </span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.8</span>, </span><br><span class="line">    &#125;</span><br><span class="line">model_lgb = lgb.cv(</span><br><span class="line">    params_lgb_, train_data, num_boost_round=<span class="number">50000</span>, nfold=<span class="number">5</span>, stratified=<span class="literal">False</span>, shuffle=<span class="literal">True</span>, metrics=<span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">    early_stopping_rounds=<span class="number">50</span>, verbose_eval=<span class="number">50</span>, show_stdv=<span class="literal">True</span>, seed=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="方式二：使用sklearn风格">方式二：使用sklearn风格</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LGBM <span class="keyword">as</span> lgb</span><br><span class="line">params_test1 = &#123;<span class="string">&#x27;num_leaves&#x27;</span>:[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]&#125;</span><br><span class="line">model_lgb = lgb.LGBMRegressor(objective=<span class="string">&#x27;regression&#x27;</span>,</span><br><span class="line">                              max_depth = <span class="number">3</span>,</span><br><span class="line">                              learning_rate=<span class="number">0.1</span>, </span><br><span class="line">                              n_estimators=<span class="number">3938</span>,</span><br><span class="line">                              metric=<span class="string">&#x27;rmse&#x27;</span>, </span><br><span class="line">                              bagging_fraction = <span class="number">0.8</span>,</span><br><span class="line">                              feature_fraction = <span class="number">0.8</span>)</span><br><span class="line">gsearch1 = GridSearchCV(estimator=model_lgb, </span><br><span class="line">                        param_grid=params_test1, </span><br><span class="line">                        scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>, </span><br><span class="line">                        cv=<span class="number">5</span>, </span><br><span class="line">                        verbose=<span class="number">1</span>, </span><br><span class="line">                        n_jobs=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LGBMRegressor参数">LGBMRegressor参数</h3>
<p><strong>boosting_type</strong> ：‘gbdt’,‘rf’</p>
<p><strong>n_jobs</strong>  几核cpu</p>
<p><strong>silent</strong> 默认选择True，选择False会输出很多建模中的细节，作用不大还刷屏。</p>
<p><em>注</em>：上面三个参数是要在开始前就确定的</p>
<p><strong>learning_rate</strong>：学习率，初始状态建议选择较大的学习率，设置为0.1.</p>
<p><strong>n_estimators</strong>：树的数量，初始状态适配lr = 0.1</p>
<p><em>注</em>：这两个参数作用于树的数量，不关心树的内部。，这两个参数需要联调</p>
<p><strong>max_depth</strong>：每棵树的最大深度，防止过拟合。初始状态设置3~8。</p>
<p><strong>num_leaves</strong> :每棵树的最多叶子数，因为CART是二叉树，所以叶子数量最大值为2 <strong>depth，所以num_leaves要小于该值才有意义。</strong></p>
<p>min_child_samples**：又称为min_data_in_leaf，指要想建立一个叶子所需要的的最少样本数，增大它可以降低过拟合。**</p>
<p>min_child_weight**：又称为min_sum_hessian_in_leaf，指要想建立一个叶子，该叶子需要提供的最小hessian值。这两个参数都是对新建叶子设置了门槛，可以降低叶子数量，减小过拟合。**</p>
<p>feature_fraction**：每次新建一棵树时，随机使用多少的特征。**</p>
<p><strong>bagging_fraction</strong>：每次进行bagging时，随机使用多少的样本。</p>
<p><strong>bagging_freq</strong>：每建立多少棵树，就进行一次bagging。</p>
<p><strong>reg_alpha</strong>：L1正则化参数</p>
<p><strong>reg_lambda</strong>：L2正则化参数</p>
<p><em>注</em>：上面的参数是调整每棵树的属性</p>
<p><strong>基本调参思路，首先设置lr=0.1确定树的数量，然后调整每颗树的内部参数到最佳。确定树的内部参数后，用该参数，降低lr，反调lr和树的数量。</strong></p>
]]></content>
      <tags>
        <tag>LightGBM</tag>
      </tags>
  </entry>
  <entry>
    <title>时序预测方法总结</title>
    <url>/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="自回归移动平均模型（ARMA）">自回归移动平均模型（ARMA）</h3>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="image-20220315184103757"></p>
<p>ARMA属于时间序列参数模型。假设$x_t$表示t时刻的时间序列的值，p和q表示时间窗的大小，$\varepsilon_t$表示t时刻的白噪声，$\alpha_1,\dots,\alpha_p$和$\beta_1,\dots,\beta_q$表示权重系数，则：</p>
<p>MA(q)可以表示为：$X_t=\sum_{i=1}^{q}\beta_i\varepsilon_{t-i}+\varepsilon_{t}$，MA模型研究时间序列在t时刻的值与$t-1, t-2, …$ 时刻随机干扰值的相关关系；MA模型主要考察外部影响对变量的影响情况和相应的记忆期限。</p>
<p>AR§可以表示为：$X_t=\sum_{i=1}^{p}\alpha_iX_{t-i}+\varepsilon_t$，AR模型研究第t时刻的序列值受$t-1, t-2, …$时刻的序列值以及当前随机干扰值的影响；AR模型主要考察变量的记忆特征和记忆衰减情况；</p>
<p>ARMA(p,q)可以表示为：$X_t=\sum_{i=1}^{p}\alpha_iX_{t-i}+\sum_{i=1}^{q}\beta_i\varepsilon_{t-i}+\varepsilon_t$，由自回归模型（AR）和移动平均模型（MA模型）为基础“混合”构成。</p>
<h4 id="特点">特点</h4>
<ul>
<li>
<p>ARMA方法作为基于统计的传统时间序列预测方法，其优点是复杂度低、计算速度快。但是针对现实世界复杂的时间序列，传统的单一统计学模型的准确率相对来说会比机器学习差。</p>
</li>
<li>
<p>传统的时间序列预测方法非常依赖参数模型的选择，能 否正确选择参数模型在很大程度上决定了预测结果的准确率。</p>
</li>
<li>
<p>只能适用于单变量时序预测</p>
</li>
</ul>
<h4 id="意义">意义</h4>
<p>传统时间序列预测模型也有其重要的意义：</p>
<ul>
<li>可以作为预测的基准模型，为项目提供一个准确率的基准线，来帮助评估其他模型。</li>
<li>前置清洗作用，时序模型由于其较好的可解释性，可以帮助剔除一些异常值。</li>
<li>作为集成模型中的一块，参与时序集成模型的训练。</li>
</ul>
<h4 id="改进1：ARIMA模型">改进1：ARIMA模型</h4>
<p>ARIMA模型是ARMA模型的推广。当时间序列${X_t}$不满足平稳性时, 我们通常使用<strong>差分</strong>的技巧使序列变得平稳, 然后再应用ARMA模型。使得ARMA模型可以应用于非平稳序列中。但ARIMA模型在长时间序列预测工作表现较差。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt="img"></p>
<h4 id="改进2：VARMA模型">改进2：VARMA模型</h4>
<p>解决ARMA只能适用于单变量时序的局限性。</p>
<p>m维ARMA(p,q)序列，即$VARMA(p,q)$：$X_t=\sum_{j=1}^p A_jX_j+\varepsilon_t-\sum_{j=1}^q B_j\varepsilon_{t-j}$</p>
<p>平稳可逆的VARMA模型具有平稳解，但需要估计出VARMA(p,q)模型的参数$A_1,\dots,A_p,B_1,\dots,B_q$，这是很麻烦的事情。</p>
<p>若q=0，模型退化为m维AR§模型，记为VAR§；</p>
<p>若p=0，模型退化为m维MA(q)模型，记为VMA(q)；</p>
<h4 id="参考-3">参考</h4>
<p><a href="https://www.jianshu.com/p/6250e60fa28a">多维时间序列——ARMA模型简介、VAR模型</a>、<a href="https://cloud.tencent.com/developer/article/1666552">【时序预测】一文梳理时间序列预测——ARMA模型</a>、<a href="https://www.jianshu.com/p/e52a4b82654e">时间序列模型简介</a></p>
<h3 id="支持向量机（SVM）">支持向量机（SVM）</h3>
<p>支持向量机在回归上的应用之一便是时序预测。为了使用SVR进行非线性回归，使用核函数将输入空间$x(i)$映射到高维特征空间$w(x(i))$。<strong>核函数的使用</strong>是SVR应用的关键。它提供了将非线性数据映射到本质上是线性的“特征”空间的能力。为了使SVR能在时序预测上取得好的效果，也出现了很多改进，如LSSVM、ASVM、$\varepsilon$-DSVM等。</p>
<p>在广泛使用SVR技术的时间序列预测应用中，将SVR视为时间序列预测方法的根本原因是预测问题的非线性方面。传统的基于模型的技术在预测非线性系统生成的时间序列方面通常不如SVR。而当时基于传统人工神经网络（ANN）的多层感知器等模型的性能不一定比SVR好。这可能是由于其固有的局限性，即无法保证网络优化的全局最小值。通过设计，SVR保证了这种全局最小解，并且通常在泛化能力方面具有优越性。随着深度学习的发展，SVR在非线性回归上的优势逐渐减低。</p>
<h4 id="参考-4">参考</h4>
<p>N. I. Sapankevych and R. Sankar, “Time series prediction using support vector machines: A survey,” IEEE Comput. Intell. Mag., vol. 4, no. 2,pp. 24–38, May 2009.</p>
<h3 id="径向基-RBF-函数神经网络">径向基(RBF)函数神经网络</h3>
<p>基函数神经网络是一类特殊的前馈神经网络模型。这类网络的前提是，要逼近的函数可以写成一些基函数的线性展开，并且只用在网络中产生一个隐藏层。基函数神经网络的一个主要优点是：可以使用线性自适应算法（如最小均方（LMS）和递归最小二乘（RLS）算法）来执行学习过程。基函数神经网络的例子包括径向、多项式和小波。这些基函数对输出单元执行非线性数据转换，以产生任意输出函数。</p>
<p>RBF神经网络的基本思想是：用RBF作为隐单元的“基”来构成隐空间，从而将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和。**所以，隐含层的作用是把向量从低维度映射到高维度，这样低维度线性不可分的情况到高维度就可以线性可分了，类似核函数的思想。**这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p>
<p>基函数神经网络用于时序预测，一方面因为它们具有良好的非线性拟合能力，另一方面通过非线性的基函数来实现非线性到线性的映射，从而增加神经网络的性能。</p>
<h4 id="参考-5">参考</h4>
<p><a href="https://www.cnblogs.com/pinking/p/9349695.html">RBF（径向基）神经网络</a></p>
<h3 id="CNN">CNN</h3>
<p>CNN用于时序数据的主要目的是提取时序数据上的特征，在一般情况下，CNN更常用于时序分类问题。</p>
<p>将CNN应用于时间序列预测的想法是学习能代表序列中某些重复模式的过滤器，并使用这些过滤器预测未来值。由于CNN的分层结构，它们可以很好地处理含噪序列，在随后的每一层中丢弃噪声，只提取有意义的模式。</p>
<p>针对时序数据的非线性，提高CNN学习非线性依赖关系能力的一种方法是使用大量的层和过滤器，但往往会遇到学习非线性的能力和过拟合之间的权衡问题。</p>
<h4 id="改进1：TCN（时间卷积网络）">改进1：TCN（时间卷积网络）</h4>
<p>TCN的体系结构与深度前馈神经网络相同，只是每一层的激活值是通过使用前一层的值来计算的。扩张卷积用于选择前一层神经元的哪些值将影响下一层神经元的值。因此，这种扩大的卷积运算捕获了局部和时间信息。</p>
<p>膨胀卷积：膨胀卷积允许卷积时的输入存在间隔采样，采样率受参数d控制。  最下面一层的d=1，表示输入时每个点都采样，中间层d=2，表示输入时每2个点采样一个作为输入。一般来讲，越高的层级使用的d的大小越大。所以，膨胀卷积使得有效窗口的大小随着层数呈指数型增长。这样卷积网络用比较少的层，就可以获得很大的感受野。</p>
<h5 id="优点：">优点：</h5>
<ol>
<li>并行性。可以并行处理数据。</li>
<li>灵活的感受野。TCN的感受野的大小受层数、卷积核大小、扩张系数等决定。可以根据不同的任务不同的特性灵活定制。</li>
<li>稳定的梯度。TCN不太存在梯度消失和爆炸问题。</li>
<li>内存更低。RNN需要将每步的信息都保存下来，从而占据大量的内存，TCN在一层里面卷积核是共享的，内存使用更低。</li>
</ol>
<h5 id="缺点">缺点</h5>
<p>TCN是卷积神经网络的变种，虽然使用扩展卷积可以扩大感受野，但相比于Transformer可以提取任意长度的相关信息的特性还是差了点。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt="image-20220317163822436"></p>
<h4 id="参考-6">参考</h4>
<p><a href="https://arxiv.org/abs/1703.04691">A. Borovykh, S. Bohte, and C. W. Oosterlee, “Conditional time series forecasting with convolutional neural networks,” 2017, arXiv:1703. 04691.</a>、<a href="https://blog.csdn.net/qq_27586341/article/details/90751794/">TCN-时间卷积网络</a></p>
<h3 id="RNN">RNN</h3>
<p>模型的输入是时间序列，其呈现出一个共同的特征，即数据之间存在时间依赖性。传统的神经网络不能考虑到这种依赖关系，RNN正是为了解决这个问题而出现的。</p>
<img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/4.png" alt="image-20220318105605529" width="50%" height="50%">
<h4 id="改进1：LSTM">改进1：LSTM</h4>
<p>标准的基本RNN存在消失梯度问题，即梯度随着层数的增加而减小。实际上，对于具有大量层的深层RNN，梯度实际上变为零，从而阻止了网络的学习。因此，这些网络只具有短期记忆，在处理需要记忆完整序列中包含的所有信息的长序列时，不会获得良好的结果。长短时记忆（LSTM）递归网络的出现是为了解决梯度消失问题。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/5.png" alt="preview"></p>
<h4 id="改进2：GRU">改进2：GRU</h4>
<p>GRU也是长期记忆网络，由于LSTM网络的高计算成本，GRU在作为LSTM的简化版本出现。GRU是在实际应用中对于许多不同的问题都是健壮和有用的。GRU在RNN的基础上使用门控机制使得捕获远程依赖成为可能，同时相对于LSTM有三个门，但GRU通过减少门的数量，使得模型更简单，计算速度更快。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/6.png" alt="image-20220317162500255"></p>
<h4 id="改进3：双向机制（BRNN、BiLSTM）">改进3：双向机制（BRNN、BiLSTM）</h4>
<p>RNN和LSTM都只能依据之前时刻的时序信息来预测下一时刻的输出，但在有些问题中，<strong>当前时刻的输出不仅和之前的状态有关，还可能和未来的状态有关系</strong>。为了获取时间序列在某一时刻前后序列的信息，出现了BRNN等带双向的递归神经网络。主要缺点是在预测之前需要整个数据序列的信息，计算量大。</p>
<h4 id="改进4：DRNN">改进4：DRNN</h4>
<p><strong>DRNN可以增强模型的表达能力，主要是将每个时刻上的循环体重复多次</strong>，每一层循环体中参数是共享的，但不同层之间的参数可以不同。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/7.png" alt="image-20220318110734017"></p>
<h4 id="参考：">参考：</h4>
<p><a href="https://zhuanlan.zhihu.com/p/123211148">史上最详细循环神经网络讲解（RNN/LSTM/GRU）</a>、Torres J F, Hadjout D, Sebaa A, et al. Deep learning for time series forecasting: a survey[J]. Big Data, 2021, 9(1): 3-21.</p>
<h3 id="自编码器">自编码器</h3>
<img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/8.png" alt="image-20220319094312851" width="50%" height="50%">
<p>自编码器(autoencoder) 是神经网络的一种，该网络可以看作由两部分组成：一个编码器函数$h = f(x) $和一个生成重构的解码器$r = g(h)$。自编码器是一种无监督的神经网络模型，它可以学习到输入数据的隐含特征，这称为编码，同时用学习到的新特征可以重构出原始输入数据，称之为解码。从直观上来看，自编码器可以用于特征降维，其相比PCA性能更强。除了进行特征降维，自编码器学习到的新特征可以送入有监督学习模型中，所以自编码器可以起到特征提取器的作用。</p>
<h4 id="改进1：SAE-堆栈自编码器">改进1：SAE(堆栈自编码器)</h4>
<p>即通过堆叠多层的自编码来学习更多的特征，将它用于时序主要还是像CNN那样方便提取特征。</p>
<h4 id="参考-7">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/31742653">简单易懂的自动编码器</a></p>
<h3 id="隐马尔可夫模型（HMM）">隐马尔可夫模型（HMM）</h3>
<p>隐马尔可夫模型是关于时序（顺序）的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列，称为状态序列；每个状态生成一个观测，而由此产生的观测的随机序列，称为观测序列。序列的每一个位置又可以看作是一个时刻。基本原理：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；</p>
<p>隐马尔可夫模型的基本假设：</p>
<p>1.齐次马尔科夫性假设：即假设隐藏的马尔科夫链在任意时刻t的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关；</p>
<p>2.观测独立性假设：即假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测即状态无关。</p>
<h4 id="参考-8">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/29938926">隐马尔可夫模型HMM</a></p>
<h3 id="深度置信网络（DBN）">深度置信网络（DBN）</h3>
<p>假设有一个二部图，每一层的节点之间没有链接，一层是可视层，即输入数据层(v)，一层是隐藏层(h)，如果假设所有的节点都是随机二值变量节点（只能取0或者1值），同时假设全概率分布p(v,h)满足Boltzmann 分布，则称这个模型是受限玻尔茨曼机 (RBM)。</p>
<p>深度置信网络：当输入v的时候，通过p(h|v)可以得到隐藏层h，而得到隐藏层h之后，通过p(v|h)又能得到可视层，通过调整参数，使得从隐藏层得到的可视层v1与原来的可视层v如果一样，那么得到的隐藏层就是可视层另外一种表达，因此隐藏层可以作为可视层输入数据的特征。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/9.png" alt="img"></p>
<p>如果把隐藏层的层数增加，同时在靠近可视层的部分使用贝叶斯信念网络（即有向图模型），而在最远离可视层的部分使用RBM，便可以得到DBN。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/10.png" alt="image-20220321105813797"></p>
<h4 id="特点-2">特点</h4>
<p>RBM能够将输入分类到一个特征空间，因此多个RBM层可以在DBN中提取高层特征。学习方式：<strong>逐层贪婪训练</strong>。</p>
<h4 id="参考-9">参考</h4>
<p><a href="https://blog.csdn.net/kellyroslyn/article/details/82668733">DBN(深度置信网络）</a></p>
<h3 id="GAN">GAN</h3>
<p>生成性对抗网络可分为判别网络和生成网络。经过训练的判别网络能够通过学习给定输入输出的条件概率分布来预测给定输入输出。而经过训练的生成网络通过学习输入和输出的联合分布，能够生成与训练样本具有相似分布的样本。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/11.png" alt="image-20220321145501389"></p>
<p>GAN用于时序预测主要因为生成对抗的思想，通过预测网络（如LSTM）与判别网络（如CNN）之间的相互对抗来提升预测网络的预测精度，从而获得较好的预测精度。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/12.png" alt="image-20220321150651996"></p>
<h4 id="参考-10">参考</h4>
<p>Zhou X, Pan Z, Hu G, et al. Stock market prediction on high-frequency  data using generative adversarial nets[J]. Mathematical Problems in  Engineering, 2018.</p>
<h3 id="Transformers">Transformers</h3>
<p>Transformers对序列数据中的长期依赖关系和交互具有强大的建模能力，因此可以适合于时间序列建模。 利用在输入嵌入中加入的位置编码，对序列信息进行建模。</p>
<p>从网络结构和应用领域的角度看时间序列建模Transformers：</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/13.png" alt="image-20220322162918132"></p>
<h4 id="位置编码">位置编码</h4>
<p>Vanilla Positional Encoding：该编码可以从时间序列中提取一些位置信息，但它们不能充分利用时间序列数据的重要特征。</p>
<p>Learnable Positional Encoding：从时间序列中学习适当的位置编码</p>
<p>Timestamp Encoding：使用数据对应的现实时间戳信息</p>
<h4 id="自注意力机制">自注意力机制</h4>
<p>在神经网络模型处理大量输入信息的过程中，利用注意力机制，可以做到只选择一些关键的的输入信息进行处理，来<strong>提高神经网络的效率</strong>。自注意力机制是注意力机制的变体，其<strong>减少了对外部信息的依赖，更擅长捕捉数据或特征的内部相关性</strong>。Transformer的核心是自注意力机制。它可以看作是一个全连通层，其权值是根据输入的两两相似度动态生成的。因此，它与全连接层共享相同的最大路径长度，但参数量要少得多，这使得它适合于建模长期依赖关系。</p>
<h4 id="参考-11">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/265108616">Attention注意力机制与self-attention自注意力机制</a>、Wen Q, Zhou T, Zhang C, et al. Transformers in Time Series: A Survey[J]. arXiv preprint arXiv:2202.07125, 2022.</p>
]]></content>
      <tags>
        <tag>Knowledge summary</tag>
      </tags>
  </entry>
</search>
