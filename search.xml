<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Autoformer</title>
    <url>/2022/05/05/Autoformer/</url>
    <content><![CDATA[<h2 id="论文介绍">论文介绍</h2>
<p>论文题目：Autoformer: Decomposition Transformers with Auto-Correlation for Long-Term Series Forecasting（基于深度分解架构和自相关机制的长期序列预测模型）</p>
<p><img src="/2022/05/05/Autoformer/1.png" alt="1"></p>
<p>链接：<a href="https://arxiv.org/abs/2106.13008">https://arxiv.org/abs/2106.13008</a></p>
<h2 id="研究背景">研究背景</h2>
<p>时间序列预测已经被广泛用于能源、交通、气象等众多领域。在实际应用中，尽可能延长预测时效是一个迫切的需求，如能源、交通的长期规划，和气象灾害的早期预警等。</p>
<p>因此，<strong>长期时间序列预测</strong>问题：待预测的序列长度远远大于输入长度，即基于有限的信息预测更长远的未来，在上述需求的大背景下此预测问题极具挑战性。</p>
<p>同时，之前基于Transformer的时间序列预测模型都是通过自注意力机制（self-attention）来捕捉时刻间的依赖，在时序预测上取得了一些进展。但是在长期序列预测中，存在以下不足：</p>
<ul>
<li>
<p>长序列中的复杂时间模式使得<strong>注意力机制难以发现可靠的时序依赖</strong>。</p>
</li>
<li>
<p>由于自注意力机制的二次复杂度问题，实际使用中模型不得不使用其稀疏版本，这会<strong>限制信息利用效率</strong>，影响预测效果。</p>
</li>
</ul>
<p>本文的解决办法是：全面革新Transformer，提出了名为Autoformer的模型，主要包含以下创新：</p>
<ul>
<li>
<p>突破将序列分解作为预处理的传统方法，提出<strong>深度分解架构</strong>，能够从复杂时间模式中分解出可预测性更强的组分，从而更利于预测。</p>
</li>
<li>
<p>基于随机过程理论，提出<strong>自相关机制</strong>，代替只能建立点向连接的注意力机制，实现序列级连接，打破信息利用瓶颈。</p>
</li>
</ul>
<p><img src="/2022/05/05/Autoformer/2.png" alt="2"></p>
<p>在长期预测问题中，Autoformer在能源、交通、经济、气象、疾病五大时序领域大幅超越之前SOTA，实现<strong>38%</strong> 的相对效果提升。</p>
<h2 id="autoformer">Autoformer</h2>
<p>Autoformer全面革新Transformer，并建立深度分解架构，主要结构包括内部的序列分解单元、自相关机制以及对应的编-解码器。整体结构如下图所示：</p>
<p><img src="/2022/05/05/Autoformer/3.png" alt="3"></p>
<h3 id="序列分解模块">序列分解模块</h3>
<p>序列分解模块把序列看成两部分组成：趋势项和季节项，趋势项反映了序列整体变化的趋势，季节项则反映序列在时间上波动的情况。本文是基于滑动平均思想，平滑时间序列，分离周期项与趋势项：</p>
<p><img src="/2022/05/05/Autoformer/4.png" alt="4"></p>
<p>注：这里的padding是为了保证进行滑动平均得到的趋势项与原序列具有相同的长度。</p>
<p>由上面的Autoformer的整体结构图所示，我们可以发现序列分解模块是嵌入到了模型的内部。了解时序预测的都知道，序列分解在时序预测过程中大多属于预处理阶段，模型再在预处理后的序列进行预测。本文打破了该惯例，将其更新为深度模型的基本内部块，而这种设计使Autoformer具有复杂时间序列的渐进分解能力，更易发现潜藏在复杂时序中规律。</p>
<h3 id="自相关机制">自相关机制</h3>
<p>自相关模块是通过计算序列自相关系数，发现周期依赖项，然后再平移时间做相似子序列的聚合。整体结构如下图所示，其中红色框部分为周期依赖发现，绿色框部分为时延聚合。</p>
<p><img src="/2022/05/05/Autoformer/5.png" alt="image-20220505105859201"></p>
<h4 id="基于周期的依赖发现">基于周期的依赖发现</h4>
<p>自相关系数表示序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>X</mi><mi>t</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ {X_t} \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>与延迟<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>时刻的序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>X</mi><mrow><mi>x</mi><mo>−</mo><mi>τ</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ {X_{x-\tau} } \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>之间的相似性。</p>
<p><img src="/2022/05/05/Autoformer/6.png" alt="image-20220505110940247"></p>
<p>这里可以将这种时延相似性看作未归一化的周期估计的置信度，即周期长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">{\tau}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></span>的置信度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(\tau)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span>。</p>
<p><img src="/2022/05/05/Autoformer/7.png" alt="image-20220505140533140"></p>
<p>通过这样的运作，置信度大的周期长度，说明<strong>原序列与此序列之间的相似性越大，从而建立序列与序列的依赖</strong>。</p>
<p>注：这里Roll操作是将左移出去的序列补充到右边空出来的部分，是因为自相关系数计算需要序列是无穷序列，而实际上的序列都是有限序列，所以通过将原序列看成一个周期为L(原序列长度)的周期序列便可以将序列长度无穷化。</p>
<p>这里原序列与延迟<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">{\tau}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></span>的序列计算自相关系数，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">{\tau}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></span>的范围是1至L，因此一次自相关机制就需要做L次自相关计算。为了提高效率，本文基于Winer-Khinchin理论，用快速傅里叶变换（FFT）计算自相关系数，使得复杂度仅为O(LlogL)，大大减少了运行时间。对Winer-Khinchin理论和快速傅里叶变换感兴趣的，可以阅读博客：<a href="https://upupming.site/2018/12/27/fourier-transform/#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">傅里叶变换</a>。</p>
<p><img src="/2022/05/05/Autoformer/8.png" alt="image-20220505141934939"></p>
<h4 id="时延聚合">时延聚合</h4>
<p>聚合相似子序列以得到输出序列。</p>
<p>步骤：</p>
<p><img src="/2022/05/05/Autoformer/9.png" alt="image-20220505141356314"></p>
<ol>
<li>这里从L个延迟<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>时刻的子序列中选取自相关系数最大的k个子序列。k的选取按照规则：$k = \lfloor c \times \log L\rfloor $</li>
<li>通过softmax将自相关系数映射成概率，值越大，与原序列相似度越大。</li>
<li>依该概率对各延迟τ时刻序列进行加权叠加，最后得到输出序列。</li>
</ol>
<h4 id="创新点">创新点</h4>
<p>自相关模块不同于之前Transformer中的自注意一类的模块，后者更关注与point-wise之间的依赖性，而前者更关注series-wise之间的依赖性。对比图如下：</p>
<p><img src="/2022/05/05/Autoformer/10.png" alt="image-20220505142427595"></p>
<ul>
<li>
<p><strong>Full Attention</strong>：所有引起注意的点都会起作用，来决定当前的预测值。但时间效率低，从而出现了各种稀疏变种。</p>
</li>
<li>
<p><strong>Sparse Attention</strong>：通过top-k选择，将注意退化为稀疏注意，从而使得只关注最引起注意的部分。</p>
</li>
<li>
<p><strong>LogSparse Attention</strong>：只选择距离满足条件的引起注意的点。</p>
</li>
<li>
<p><strong>Auto-Correlation</strong>：自相关机制则不关注点与点的关系，而是实现了序列与序列之间的高效连接，即建立当前预测序列与已知序列的子序列的关系，从而可以更好地利用时序的特点，进行有效信息聚合，打破信息利用瓶颈。同时，自相关机制采用FFT的方法进行相关系数计算，提高了模型的时间效率。</p>
</li>
<li>
<p>同时，本文设计了多头的自相关机制，从而无缝替换自注意力机制。</p>
</li>
</ul>
<h3 id="编-解码器架构">编-解码器架构</h3>
<p>Autoformer没有改变Transformer的编-解码器架构，只是更新了编码器与解码器以利于长时间序列预测任务。</p>
<h4 id="编码器">编码器</h4>
<p><img src="/2022/05/05/Autoformer/11.png" alt="image-20220505144442359"></p>
<p>输入是过去I个时间点长度的序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>e</mi><mi>n</mi></mrow></msub><mo>∈</mo><msup><mi>R</mi><mrow><mi>I</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X_{en}\in R^{I\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>，d为输入的特征数。输出是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>S</mi><mrow><mi>e</mi><mi>n</mi></mrow><mrow><mi>l</mi><mo separator="true">,</mo><mn>2</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">{S_{en}^{l,2} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0961079999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>个编码层。假设有N个编码层，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>个编码层可以表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mrow><mi>e</mi><mi>n</mi></mrow><mi>l</mi></msubsup><mo>=</mo><mi>E</mi><mi>n</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><msubsup><mi>X</mi><mrow><mi>e</mi><mi>n</mi></mrow><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_{en}^{l}=Encoder(X_{en}^{l-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，内部细节如下：</p>
<p><img src="/2022/05/05/Autoformer/12.png" alt="img"></p>
<p>从上述描述中可以看出编码器重点关注时间序列的季节项，输出的是输入的过去时间序列的季节性信息，它将被用做互信息，帮助解码器调整预测结果。</p>
<h4 id="解码器">解码器</h4>
<p><img src="/2022/05/05/Autoformer/13.png" alt="image-20220505150755766"></p>
<p>输入分为三部分：初始季节项<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>d</mi><mi>e</mi><mi>s</mi></mrow></msub><mo>∈</mo><msup><mi>R</mi><mrow><mo stretchy="false">(</mo><mfrac><mi>I</mi><mn>2</mn></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">)</mo><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X_{des}\in R^{(\frac{I}{2}+O)\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.973465em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.973465em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span><span class="mclose mtight">)</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>、初始周期项<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>d</mi><mi>e</mi><mi>t</mi></mrow></msub><mo>∈</mo><msup><mi>R</mi><mrow><mo stretchy="false">(</mo><mfrac><mi>I</mi><mn>2</mn></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">)</mo><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X_{det}\in R^{(\frac{I}{2}+O)\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.973465em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.973465em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span><span class="mclose mtight">)</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>、编码器输出。d：输入特征数、O为预测的时间长度。</p>
<p><img src="/2022/05/05/Autoformer/15.png" alt="image"></p>
<p>解码器包括两个部分：1、对趋势项使用累加操作；2、对季节项使用堆叠自相关机制来挖掘依赖。</p>
<p>假设我们有M个解码层，N个编码层，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>个解码层可以表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mrow><mi>d</mi><mi>e</mi></mrow><mi>l</mi></msubsup><mo>=</mo><mi>D</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><msubsup><mi>X</mi><mrow><mi>d</mi><mi>e</mi></mrow><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>X</mi><mrow><mi>e</mi><mi>n</mi></mrow><mi>N</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_{de}^{l}=Decoder(X_{de}^{l-1}, X_{en}^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.132216em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1905469999999998em;vertical-align:-0.3013079999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8892389999999999em;"><span style="top:-2.3986920000000005em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中内部细节为：</p>
<p><img src="/2022/05/05/Autoformer/14.png" alt="image"></p>
<p>最后预测序列等于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><msub><mi>W</mi><mi>s</mi></msub><mo>∗</mo><msubsup><mi>X</mi><mrow><mi>d</mi><mi>e</mi></mrow><mi>M</mi></msubsup><mo>+</mo><msubsup><mi>τ</mi><mrow><mi>d</mi><mi>e</mi></mrow><mi>M</mi></msubsup></mrow><annotation encoding="application/x-tex">predction = W_{s}*X_{de}^M+\tau_{de}^M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1244389999999997em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1244389999999997em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="后续实验与分析">后续实验与分析</h2>
<h3 id="实验">实验</h3>
<p>在6个真实世界的基准上对Autoformer进行了广泛的评估，涵盖了5个主流的时间序列预测应用:能源、交通、经济、天气和疾病。在具有不同预测长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>96</mn><mo separator="true">,</mo><mn>192</mn><mo separator="true">,</mo><mn>336</mn><mo separator="true">,</mo><mn>720</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">O\in\{96,192,336,720\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">9</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mord">0</span><span class="mclose">}</span></span></span></span>的多元结果。</p>
<p><img src="/2022/05/05/Autoformer/16.png" alt="image-20220505153207603"></p>
<p>本文在各种输入-输出设置下，对比了自相关机制与各种自注意力机制，比如，经典Transformer中Full Attention，Informer中PropSparse Attention等。本文提出的自相关机制依然取得了最优的结果</p>
<p><img src="/2022/05/05/Autoformer/17.png" alt="image-20220505153207603"></p>
<h3 id="模型分析">模型分析</h3>
<p><strong>渐进式分解效果：</strong> 随着序列分解单元的数量增加，模型的学到的趋势项会越来越接近数据真实结果，周期项可以更好的捕捉序列变化情况，这验证了渐进式分解的作用。</p>
<p><img src="/2022/05/05/Autoformer/18.png" alt="image-20220505153207603"></p>
<p><strong>时序依赖可视化：</strong> 通过对比可以发现，Autoformer中自相关机制可以正确发掘出每个周期中的下降过程，并且<strong>没有误识别和漏识别</strong>，而自注意力机制存在错误和缺漏。</p>
<p><img src="/2022/05/05/Autoformer/19.png" alt="image-20220505153207603"></p>
<p><strong>效率分析：</strong> 在显存占用和运行时间两个指标上，自相关机制均表现出了优秀的空间时间效率，两个层面均超过自注意力机制，表现出高效<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>log</mi><mo>⁡</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L\log L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>的复杂度。</p>
<p><img src="/2022/05/05/Autoformer/20.png" alt="image-20220505153207603"></p>
<h2 id="参考">参考</h2>
<p>1、<a href="https://mp.weixin.qq.com/s/t0aAUYfurprtu7RPl5mqwg">Autoformer:基于深度分解架构和自相关机制的长期序列预测模型</a></p>
<p>2、<a href="https://zhuanlan.zhihu.com/p/472624073">[时序] Autoformer：基于深度分解架构和自相关机制的长期序列预测模型</a></p>
<p>3、<a href="https://blog.csdn.net/yaohaishen/article/details/118611746">Autoformer-时序模型的突破</a></p>
]]></content>
      <tags>
        <tag>论文精读</tag>
      </tags>
  </entry>
  <entry>
    <title>LGBM学习记录</title>
    <url>/2022/04/22/LGBM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="gbdt-gradient-boosting-decision-tree">GBDT (Gradient Boosting Decision Tree)</h3>
<p>主要思想是利用弱分类器（决策树）迭代训练以得到最优模型，该模型具有<strong>训练效果好、不易过拟合</strong>等优点。</p>
<p>目前已有的 GBDT 工具基本都是基于预排序的决策树算法(如 Xgboost)。这种构建决策树的算法基本思想是：</p>
<p>首先，对所有特征都按照特征的数值进行预排序。其次，在遍历分割点的时候用O(n)的代价找到一个特征上的最好分割点。最后，找到一个特征的分割点后，将数据分裂成左右子节点。</p>
<p>这样的预排序算法的优点是：能精确地找到分割点。缺点也很明显：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次，时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</p>
<h3 id="lgbm-lightgbm">LGBM（LightGBM）</h3>
<p>LightGBM 的动机：常用的机器学习算法，例如神经网络等算法，都可以用 mini-batch 的方式训练，训练数据的大小不会受到内存限制。而 GBDT 在每一次迭代的时候，都需要遍历整个训练数据集多次。如果把整个训练数据装进内存则会限制训练数据集的大小；如果不装进内存，反复遍历训练数据集又会消耗大量时间。尤其面对工业上海量的数据，普通的 GBDT 算法是不能满足其需求的。LightGBM 提出的主要原因就是为了解决 GBDT 在海量数据上遇到的问题，让 GBDT 可以更好地用于工业实践。</p>
<p>LGBM与传统算法相比具有的优点：更快的训练效率；低内存使用；更高的准确率；支持并行化学习；可处理大规模数据；原生支持类别特征，不需要对类别特征再进行0-1编码。</p>
<h4 id="histogram-算法">Histogram 算法</h4>
<p>直方图算法的基本思想是先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p>
<p>在计算上的代价也大幅降低，预排序算法每遍历一个特征值就需要计算一次分裂的增益，而直方图算法只需要计算k次（k为超参数），时间复杂度从O(data * feature)优化到O(k * features)。</p>
<p>Histogram 算法由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</p>
<h4 id="leaf-wise">Leaf-wise</h4>
<p>LGBM抛弃了大多数 GBDT 工具使用的按层生长 (level-wise) 的决策树生长策略，而使用了带有深度限制的按叶子生长 (leaf-wise) 算法。Level-wise 过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上 Level-wise 是一种低效的算法，因为它不加区分的对待同一层的叶子，而实际上很多叶子的分裂增益较低，没必要进行搜索和分裂，从而带来了很多没必要的开销。</p>
<p>Leaf-wise 则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同 Level-wise 相比，在分裂次数相同的情况下，Leaf-wise 可以降低更多的误差，得到更好的精度。Leaf-wise 的缺点是可能会长出比较深的决策树，产生过拟合。因此 LightGBM 在 Leaf-wise 之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p>
<h4 id="gradient-based-one-side-sampling-goss">Gradient-based One-Side Sampling(GOSS)</h4>
<p>GOSS技术是去掉了很大一部分梯度很小的数据，只使用剩下的去估计信息增益，避免低梯度长尾部分的影响。由于梯度大的数据在计算信息增益的时候更重要，所以GOSS在小很多的数据上仍然可以取得相当准确的估计值。</p>
<h4 id="exclusive-feature-bundling-efb">Exclusive Feature Bundling(EFB)</h4>
<p>EFB技术是指捆绑互斥的特征（如他们经常同时取值为0），以减少特征的数量。对互斥特征寻找最佳的捆绑方式是一个NP难问题，不过贪婪算法可以取得相当好的近似率，因此可以在不显著影响分裂点选择的准确性的情况下，显著地减少特征数量。</p>
<h3 id="模型创建">模型创建</h3>
<h4 id="lgbm">LGBM</h4>
<h5 id="方式1：使用lgb的风格">方式1：使用lgb的风格</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LGBM <span class="keyword">as</span> lgb</span><br><span class="line">params_lgb_ = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;regression&#x27;</span>, </span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.1</span>, </span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">50</span>, </span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">6</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.8</span>, </span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.8</span>, </span><br><span class="line">    &#125;</span><br><span class="line">model_lgb = lgb.cv(</span><br><span class="line">    params_lgb_, train_data, num_boost_round=<span class="number">50000</span>, nfold=<span class="number">5</span>, stratified=<span class="literal">False</span>, shuffle=<span class="literal">True</span>, metrics=<span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">    early_stopping_rounds=<span class="number">50</span>, verbose_eval=<span class="number">50</span>, show_stdv=<span class="literal">True</span>, seed=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="方式二：使用sklearn风格">方式二：使用sklearn风格</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LGBM <span class="keyword">as</span> lgb</span><br><span class="line">params_test1 = &#123;<span class="string">&#x27;num_leaves&#x27;</span>:[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]&#125;</span><br><span class="line">model_lgb = lgb.LGBMRegressor(objective=<span class="string">&#x27;regression&#x27;</span>,</span><br><span class="line">                              max_depth = <span class="number">3</span>,</span><br><span class="line">                              learning_rate=<span class="number">0.1</span>, </span><br><span class="line">                              n_estimators=<span class="number">3938</span>,</span><br><span class="line">                              metric=<span class="string">&#x27;rmse&#x27;</span>, </span><br><span class="line">                              bagging_fraction = <span class="number">0.8</span>,</span><br><span class="line">                              feature_fraction = <span class="number">0.8</span>)</span><br><span class="line">gsearch1 = GridSearchCV(estimator=model_lgb, </span><br><span class="line">                        param_grid=params_test1, </span><br><span class="line">                        scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>, </span><br><span class="line">                        cv=<span class="number">5</span>, </span><br><span class="line">                        verbose=<span class="number">1</span>, </span><br><span class="line">                        n_jobs=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="lgbmregressor参数">LGBMRegressor参数</h3>
<p><strong>boosting_type</strong> ：‘gbdt’,‘rf’</p>
<p><strong>n_jobs</strong>  几核cpu</p>
<p><strong>silent</strong> 默认选择True，选择False会输出很多建模中的细节，作用不大还刷屏。</p>
<p><em>注</em>：上面三个参数是要在开始前就确定的</p>
<p><strong>learning_rate</strong>：学习率，初始状态建议选择较大的学习率，设置为0.1.</p>
<p><strong>n_estimators</strong>：树的数量，初始状态适配lr = 0.1</p>
<p><em>注</em>：这两个参数作用于树的数量，不关心树的内部。，这两个参数需要联调</p>
<p><strong>max_depth</strong>：每棵树的最大深度，防止过拟合。初始状态设置3~8。</p>
<p><strong>num_leaves</strong> :每棵树的最多叶子数，因为CART是二叉树，所以叶子数量最大值为2 <strong>depth，所以num_leaves要小于该值才有意义。</strong></p>
<p>min_child_samples**：又称为min_data_in_leaf，指要想建立一个叶子所需要的的最少样本数，增大它可以降低过拟合。**</p>
<p>min_child_weight**：又称为min_sum_hessian_in_leaf，指要想建立一个叶子，该叶子需要提供的最小hessian值。这两个参数都是对新建叶子设置了门槛，可以降低叶子数量，减小过拟合。**</p>
<p>feature_fraction**：每次新建一棵树时，随机使用多少的特征。**</p>
<p><strong>bagging_fraction</strong>：每次进行bagging时，随机使用多少的样本。</p>
<p><strong>bagging_freq</strong>：每建立多少棵树，就进行一次bagging。</p>
<p><strong>reg_alpha</strong>：L1正则化参数</p>
<p><strong>reg_lambda</strong>：L2正则化参数</p>
<p><em>注</em>：上面的参数是调整每棵树的属性</p>
<p><strong>基本调参思路，首先设置lr=0.1确定树的数量，然后调整每颗树的内部参数到最佳。确定树的内部参数后，用该参数，降低lr，反调lr和树的数量。</strong></p>
]]></content>
      <tags>
        <tag>LightGBM</tag>
      </tags>
  </entry>
  <entry>
    <title>时序预测方法总结</title>
    <url>/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="自回归移动平均模型-arma">自回归移动平均模型（ARMA）</h3>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="image-20220315184103757"></p>
<p>ARMA属于时间序列参数模型。假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示t时刻的时间序列的值，p和q表示时间窗的大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\varepsilon_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示t时刻的白噪声，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>α</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_1,\dots,\alpha_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>β</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">\beta_1,\dots,\beta_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示权重系数，则：</p>
<p>MA(q)可以表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></msubsup><msub><mi>β</mi><mi>i</mi></msub><msub><mi>ε</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>ε</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">X_t=\sum_{i=1}^{q}\beta_i\varepsilon_{t-i}+\varepsilon_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，MA模型研究时间序列在t时刻的值与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">t-1, t-2, …</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 时刻随机干扰值的相关关系；MA模型主要考察外部影响对变量的影响情况和相应的记忆期限。</p>
<p>AR§可以表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msub><mi>α</mi><mi>i</mi></msub><msub><mi>X</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>ε</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">X_t=\sum_{i=1}^{p}\alpha_iX_{t-i}+\varepsilon_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，AR模型研究第t时刻的序列值受<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">t-1, t-2, …</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>时刻的序列值以及当前随机干扰值的影响；AR模型主要考察变量的记忆特征和记忆衰减情况；</p>
<p>ARMA(p,q)可以表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msub><mi>α</mi><mi>i</mi></msub><msub><mi>X</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></msubsup><msub><mi>β</mi><mi>i</mi></msub><msub><mi>ε</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>ε</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">X_t=\sum_{i=1}^{p}\alpha_iX_{t-i}+\sum_{i=1}^{q}\beta_i\varepsilon_{t-i}+\varepsilon_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，由自回归模型（AR）和移动平均模型（MA模型）为基础“混合”构成。</p>
<h4 id="特点">特点</h4>
<ul>
<li>
<p>ARMA方法作为基于统计的传统时间序列预测方法，其优点是复杂度低、计算速度快。但是针对现实世界复杂的时间序列，传统的单一统计学模型的准确率相对来说会比机器学习差。</p>
</li>
<li>
<p>传统的时间序列预测方法非常依赖参数模型的选择，能 否正确选择参数模型在很大程度上决定了预测结果的准确率。</p>
</li>
<li>
<p>只能适用于单变量时序预测</p>
</li>
</ul>
<h4 id="意义">意义</h4>
<p>传统时间序列预测模型也有其重要的意义：</p>
<ul>
<li>可以作为预测的基准模型，为项目提供一个准确率的基准线，来帮助评估其他模型。</li>
<li>前置清洗作用，时序模型由于其较好的可解释性，可以帮助剔除一些异常值。</li>
<li>作为集成模型中的一块，参与时序集成模型的训练。</li>
</ul>
<h4 id="改进1：arima模型">改进1：ARIMA模型</h4>
<p>ARIMA模型是ARMA模型的推广。当时间序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>X</mi><mi>t</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{X_t\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>不满足平稳性时, 我们通常使用<strong>差分</strong>的技巧使序列变得平稳, 然后再应用ARMA模型。使得ARMA模型可以应用于非平稳序列中。但ARIMA模型在长时间序列预测工作表现较差。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt="img"></p>
<h4 id="改进2：varma模型">改进2：VARMA模型</h4>
<p>解决ARMA只能适用于单变量时序的局限性。</p>
<p>m维ARMA(p,q)序列，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>A</mi><mi>R</mi><mi>M</mi><mi>A</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">VARMA(p,q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msub><mi>A</mi><mi>j</mi></msub><msub><mi>X</mi><mi>j</mi></msub><mo>+</mo><msub><mi>ε</mi><mi>t</mi></msub><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></msubsup><msub><mi>B</mi><mi>j</mi></msub><msub><mi>ε</mi><mrow><mi>t</mi><mo>−</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X_t=\sum_{j=1}^p A_jX_j+\varepsilon_t-\sum_{j=1}^q B_j\varepsilon_{t-j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>平稳可逆的VARMA模型具有平稳解，但需要估计出VARMA(p,q)模型的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>p</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>B</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">A_1,\dots,A_p,B_1,\dots,B_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，这是很麻烦的事情。</p>
<p>若q=0，模型退化为m维AR§模型，记为VAR§；</p>
<p>若p=0，模型退化为m维MA(q)模型，记为VMA(q)；</p>
<h4 id="参考">参考</h4>
<p><a href="https://www.jianshu.com/p/6250e60fa28a">多维时间序列——ARMA模型简介、VAR模型</a>、<a href="https://cloud.tencent.com/developer/article/1666552">【时序预测】一文梳理时间序列预测——ARMA模型</a>、<a href="https://www.jianshu.com/p/e52a4b82654e">时间序列模型简介</a></p>
<h3 id="支持向量机-svm">支持向量机（SVM）</h3>
<p>支持向量机在回归上的应用之一便是时序预测。为了使用SVR进行非线性回归，使用核函数将输入空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>映射到高维特征空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(x(i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。<strong>核函数的使用</strong>是SVR应用的关键。它提供了将非线性数据映射到本质上是线性的“特征”空间的能力。为了使SVR能在时序预测上取得好的效果，也出现了很多改进，如LSSVM、ASVM、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>-DSVM等。</p>
<p>在广泛使用SVR技术的时间序列预测应用中，将SVR视为时间序列预测方法的根本原因是预测问题的非线性方面。传统的基于模型的技术在预测非线性系统生成的时间序列方面通常不如SVR。而当时基于传统人工神经网络（ANN）的多层感知器等模型的性能不一定比SVR好。这可能是由于其固有的局限性，即无法保证网络优化的全局最小值。通过设计，SVR保证了这种全局最小解，并且通常在泛化能力方面具有优越性。随着深度学习的发展，SVR在非线性回归上的优势逐渐减低。</p>
<h4 id="参考">参考</h4>
<p>N. I. Sapankevych and R. Sankar, “Time series prediction using support vector machines: A survey,” IEEE Comput. Intell. Mag., vol. 4, no. 2,pp. 24–38, May 2009.</p>
<h3 id="径向基-rbf-函数神经网络">径向基(RBF)函数神经网络</h3>
<p>基函数神经网络是一类特殊的前馈神经网络模型。这类网络的前提是，要逼近的函数可以写成一些基函数的线性展开，并且只用在网络中产生一个隐藏层。基函数神经网络的一个主要优点是：可以使用线性自适应算法（如最小均方（LMS）和递归最小二乘（RLS）算法）来执行学习过程。基函数神经网络的例子包括径向、多项式和小波。这些基函数对输出单元执行非线性数据转换，以产生任意输出函数。</p>
<p>RBF神经网络的基本思想是：用RBF作为隐单元的“基”来构成隐空间，从而将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和。**所以，隐含层的作用是把向量从低维度映射到高维度，这样低维度线性不可分的情况到高维度就可以线性可分了，类似核函数的思想。**这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p>
<p>基函数神经网络用于时序预测，一方面因为它们具有良好的非线性拟合能力，另一方面通过非线性的基函数来实现非线性到线性的映射，从而增加神经网络的性能。</p>
<h4 id="参考">参考</h4>
<p><a href="https://www.cnblogs.com/pinking/p/9349695.html">RBF（径向基）神经网络</a></p>
<h3 id="cnn">CNN</h3>
<p>CNN用于时序数据的主要目的是提取时序数据上的特征，在一般情况下，CNN更常用于时序分类问题。</p>
<p>将CNN应用于时间序列预测的想法是学习能代表序列中某些重复模式的过滤器，并使用这些过滤器预测未来值。由于CNN的分层结构，它们可以很好地处理含噪序列，在随后的每一层中丢弃噪声，只提取有意义的模式。</p>
<p>针对时序数据的非线性，提高CNN学习非线性依赖关系能力的一种方法是使用大量的层和过滤器，但往往会遇到学习非线性的能力和过拟合之间的权衡问题。</p>
<h4 id="改进1：tcn-时间卷积网络">改进1：TCN（时间卷积网络）</h4>
<p>TCN的体系结构与深度前馈神经网络相同，只是每一层的激活值是通过使用前一层的值来计算的。扩张卷积用于选择前一层神经元的哪些值将影响下一层神经元的值。因此，这种扩大的卷积运算捕获了局部和时间信息。</p>
<p>膨胀卷积：膨胀卷积允许卷积时的输入存在间隔采样，采样率受参数d控制。  最下面一层的d=1，表示输入时每个点都采样，中间层d=2，表示输入时每2个点采样一个作为输入。一般来讲，越高的层级使用的d的大小越大。所以，膨胀卷积使得有效窗口的大小随着层数呈指数型增长。这样卷积网络用比较少的层，就可以获得很大的感受野。</p>
<h5 id="优点：">优点：</h5>
<ol>
<li>并行性。可以并行处理数据。</li>
<li>灵活的感受野。TCN的感受野的大小受层数、卷积核大小、扩张系数等决定。可以根据不同的任务不同的特性灵活定制。</li>
<li>稳定的梯度。TCN不太存在梯度消失和爆炸问题。</li>
<li>内存更低。RNN需要将每步的信息都保存下来，从而占据大量的内存，TCN在一层里面卷积核是共享的，内存使用更低。</li>
</ol>
<h5 id="缺点">缺点</h5>
<p>TCN是卷积神经网络的变种，虽然使用扩展卷积可以扩大感受野，但相比于Transformer可以提取任意长度的相关信息的特性还是差了点。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt="image-20220317163822436"></p>
<h4 id="参考">参考</h4>
<p><a href="https://arxiv.org/abs/1703.04691">A. Borovykh, S. Bohte, and C. W. Oosterlee, “Conditional time series forecasting with convolutional neural networks,” 2017, arXiv:1703. 04691.</a>、<a href="https://blog.csdn.net/qq_27586341/article/details/90751794/">TCN-时间卷积网络</a></p>
<h3 id="rnn">RNN</h3>
<p>模型的输入是时间序列，其呈现出一个共同的特征，即数据之间存在时间依赖性。传统的神经网络不能考虑到这种依赖关系，RNN正是为了解决这个问题而出现的。</p>
<img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/4.png" alt="image-20220318105605529" width="50%" height="50%">
<h4 id="改进1：lstm">改进1：LSTM</h4>
<p>标准的基本RNN存在消失梯度问题，即梯度随着层数的增加而减小。实际上，对于具有大量层的深层RNN，梯度实际上变为零，从而阻止了网络的学习。因此，这些网络只具有短期记忆，在处理需要记忆完整序列中包含的所有信息的长序列时，不会获得良好的结果。长短时记忆（LSTM）递归网络的出现是为了解决梯度消失问题。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/5.png" alt="preview"></p>
<h4 id="改进2：gru">改进2：GRU</h4>
<p>GRU也是长期记忆网络，由于LSTM网络的高计算成本，GRU在作为LSTM的简化版本出现。GRU是在实际应用中对于许多不同的问题都是健壮和有用的。GRU在RNN的基础上使用门控机制使得捕获远程依赖成为可能，同时相对于LSTM有三个门，但GRU通过减少门的数量，使得模型更简单，计算速度更快。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/6.png" alt="image-20220317162500255"></p>
<h4 id="改进3：双向机制-brnn-bilstm">改进3：双向机制（BRNN、BiLSTM）</h4>
<p>RNN和LSTM都只能依据之前时刻的时序信息来预测下一时刻的输出，但在有些问题中，<strong>当前时刻的输出不仅和之前的状态有关，还可能和未来的状态有关系</strong>。为了获取时间序列在某一时刻前后序列的信息，出现了BRNN等带双向的递归神经网络。主要缺点是在预测之前需要整个数据序列的信息，计算量大。</p>
<h4 id="改进4：drnn">改进4：DRNN</h4>
<p><strong>DRNN可以增强模型的表达能力，主要是将每个时刻上的循环体重复多次</strong>，每一层循环体中参数是共享的，但不同层之间的参数可以不同。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/7.png" alt="image-20220318110734017"></p>
<h4 id="参考：">参考：</h4>
<p><a href="https://zhuanlan.zhihu.com/p/123211148">史上最详细循环神经网络讲解（RNN/LSTM/GRU）</a>、Torres J F, Hadjout D, Sebaa A, et al. Deep learning for time series forecasting: a survey[J]. Big Data, 2021, 9(1): 3-21.</p>
<h3 id="自编码器">自编码器</h3>
<img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/8.png" alt="image-20220319094312851" width="50%" height="50%">
<p>自编码器(autoencoder) 是神经网络的一种，该网络可以看作由两部分组成：一个编码器函数$h = f(x) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和一个生成重构的解码器</mtext></mrow><annotation encoding="application/x-tex">和一个生成重构的解码器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">解</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">器</span></span></span></span>r = g(h)$。自编码器是一种无监督的神经网络模型，它可以学习到输入数据的隐含特征，这称为编码，同时用学习到的新特征可以重构出原始输入数据，称之为解码。从直观上来看，自编码器可以用于特征降维，其相比PCA性能更强。除了进行特征降维，自编码器学习到的新特征可以送入有监督学习模型中，所以自编码器可以起到特征提取器的作用。</p>
<h4 id="改进1：sae-堆栈自编码器">改进1：SAE(堆栈自编码器)</h4>
<p>即通过堆叠多层的自编码来学习更多的特征，将它用于时序主要还是像CNN那样方便提取特征。</p>
<h4 id="参考">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/31742653">简单易懂的自动编码器</a></p>
<h3 id="隐马尔可夫模型-hmm">隐马尔可夫模型（HMM）</h3>
<p>隐马尔可夫模型是关于时序（顺序）的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列，称为状态序列；每个状态生成一个观测，而由此产生的观测的随机序列，称为观测序列。序列的每一个位置又可以看作是一个时刻。基本原理：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；</p>
<p>隐马尔可夫模型的基本假设：</p>
<p>1.齐次马尔科夫性假设：即假设隐藏的马尔科夫链在任意时刻t的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关；</p>
<p>2.观测独立性假设：即假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测即状态无关。</p>
<h4 id="参考">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/29938926">隐马尔可夫模型HMM</a></p>
<h3 id="深度置信网络-dbn">深度置信网络（DBN）</h3>
<p>假设有一个二部图，每一层的节点之间没有链接，一层是可视层，即输入数据层(v)，一层是隐藏层(h)，如果假设所有的节点都是随机二值变量节点（只能取0或者1值），同时假设全概率分布p(v,h)满足Boltzmann 分布，则称这个模型是受限玻尔茨曼机 (RBM)。</p>
<p>深度置信网络：当输入v的时候，通过p(h|v)可以得到隐藏层h，而得到隐藏层h之后，通过p(v|h)又能得到可视层，通过调整参数，使得从隐藏层得到的可视层v1与原来的可视层v如果一样，那么得到的隐藏层就是可视层另外一种表达，因此隐藏层可以作为可视层输入数据的特征。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/9.png" alt="img"></p>
<p>如果把隐藏层的层数增加，同时在靠近可视层的部分使用贝叶斯信念网络（即有向图模型），而在最远离可视层的部分使用RBM，便可以得到DBN。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/10.png" alt="image-20220321105813797"></p>
<h4 id="特点">特点</h4>
<p>RBM能够将输入分类到一个特征空间，因此多个RBM层可以在DBN中提取高层特征。学习方式：<strong>逐层贪婪训练</strong>。</p>
<h4 id="参考">参考</h4>
<p><a href="https://blog.csdn.net/kellyroslyn/article/details/82668733">DBN(深度置信网络）</a></p>
<h3 id="gan">GAN</h3>
<p>生成性对抗网络可分为判别网络和生成网络。经过训练的判别网络能够通过学习给定输入输出的条件概率分布来预测给定输入输出。而经过训练的生成网络通过学习输入和输出的联合分布，能够生成与训练样本具有相似分布的样本。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/11.png" alt="image-20220321145501389"></p>
<p>GAN用于时序预测主要因为生成对抗的思想，通过预测网络（如LSTM）与判别网络（如CNN）之间的相互对抗来提升预测网络的预测精度，从而获得较好的预测精度。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/12.png" alt="image-20220321150651996"></p>
<h4 id="参考">参考</h4>
<p>Zhou X, Pan Z, Hu G, et al. Stock market prediction on high-frequency  data using generative adversarial nets[J]. Mathematical Problems in  Engineering, 2018.</p>
<h3 id="transformers">Transformers</h3>
<p>Transformers对序列数据中的长期依赖关系和交互具有强大的建模能力，因此可以适合于时间序列建模。 利用在输入嵌入中加入的位置编码，对序列信息进行建模。</p>
<p>从网络结构和应用领域的角度看时间序列建模Transformers：</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/13.png" alt="image-20220322162918132"></p>
<h4 id="位置编码">位置编码</h4>
<p>Vanilla Positional Encoding：该编码可以从时间序列中提取一些位置信息，但它们不能充分利用时间序列数据的重要特征。</p>
<p>Learnable Positional Encoding：从时间序列中学习适当的位置编码</p>
<p>Timestamp Encoding：使用数据对应的现实时间戳信息</p>
<h4 id="自注意力机制">自注意力机制</h4>
<p>在神经网络模型处理大量输入信息的过程中，利用注意力机制，可以做到只选择一些关键的的输入信息进行处理，来<strong>提高神经网络的效率</strong>。自注意力机制是注意力机制的变体，其<strong>减少了对外部信息的依赖，更擅长捕捉数据或特征的内部相关性</strong>。Transformer的核心是自注意力机制。它可以看作是一个全连通层，其权值是根据输入的两两相似度动态生成的。因此，它与全连接层共享相同的最大路径长度，但参数量要少得多，这使得它适合于建模长期依赖关系。</p>
<h4 id="参考">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/265108616">Attention注意力机制与self-attention自注意力机制</a>、Wen Q, Zhou T, Zhang C, et al. Transformers in Time Series: A Survey[J]. arXiv preprint arXiv:2202.07125, 2022.</p>
]]></content>
      <tags>
        <tag>Knowledge summary</tag>
      </tags>
  </entry>
</search>
