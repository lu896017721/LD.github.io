<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Autoformer</title>
    <url>/2022/05/05/Autoformer/</url>
    <content><![CDATA[<h2 id="论文介绍">论文介绍</h2>
<p>论文题目：Autoformer: Decomposition Transformers with Auto-Correlation for Long-Term Series Forecasting（基于深度分解架构和自相关机制的长期序列预测模型）</p>
<p><img src="/2022/05/05/Autoformer/1.png" alt="1"></p>
<p>链接：<a href="https://arxiv.org/abs/2106.13008">https://arxiv.org/abs/2106.13008</a></p>
<h2 id="研究背景">研究背景</h2>
<p>时间序列预测已经被广泛用于能源、交通、气象等众多领域。在实际应用中，尽可能延长预测时效是一个迫切的需求，如能源、交通的长期规划，和气象灾害的早期预警等。</p>
<p>因此，<strong>长期时间序列预测</strong>问题：待预测的序列长度远远大于输入长度，即基于有限的信息预测更长远的未来，在上述需求的大背景下此预测问题极具挑战性。</p>
<p>同时，之前基于Transformer的时间序列预测模型都是通过自注意力机制（self-attention）来捕捉时刻间的依赖，在时序预测上取得了一些进展。但是在长期序列预测中，存在以下不足：</p>
<ul>
<li>
<p>长序列中的复杂时间模式使得<strong>注意力机制难以发现可靠的时序依赖</strong>。</p>
</li>
<li>
<p>由于自注意力机制的二次复杂度问题，实际使用中模型不得不使用其稀疏版本，这会<strong>限制信息利用效率</strong>，影响预测效果。</p>
</li>
</ul>
<p>本文的解决办法是：全面革新Transformer，提出了名为Autoformer的模型，主要包含以下创新：</p>
<ul>
<li>
<p>突破将序列分解作为预处理的传统方法，提出<strong>深度分解架构</strong>，能够从复杂时间模式中分解出可预测性更强的组分，从而更利于预测。</p>
</li>
<li>
<p>基于随机过程理论，提出<strong>自相关机制</strong>，代替只能建立点向连接的注意力机制，实现序列级连接，打破信息利用瓶颈。</p>
</li>
</ul>
<p><img src="/2022/05/05/Autoformer/2.png" alt="2"></p>
<p>在长期预测问题中，Autoformer在能源、交通、经济、气象、疾病五大时序领域大幅超越之前SOTA，实现<strong>38%</strong> 的相对效果提升。</p>
<h2 id="Autoformer">Autoformer</h2>
<p>Autoformer全面革新Transformer，并建立深度分解架构，主要结构包括内部的序列分解单元、自相关机制以及对应的编-解码器。整体结构如下图所示：</p>
<p><img src="/2022/05/05/Autoformer/3.png" alt="3"></p>
<h3 id="序列分解模块">序列分解模块</h3>
<p>序列分解模块把序列看成两部分组成：趋势项和季节项，趋势项反映了序列整体变化的趋势，季节项则反映序列在时间上波动的情况。本文是基于滑动平均思想，平滑时间序列，分离周期项与趋势项：</p>
<p><img src="/2022/05/05/Autoformer/4.png" alt="4"></p>
<p>注：这里的padding是为了保证进行滑动平均得到的趋势项与原序列具有相同的长度。</p>
<p>由上面的Autoformer的整体结构图所示，我们可以发现序列分解模块是嵌入到了模型的内部。了解时序预测的都知道，序列分解在时序预测过程中大多属于预处理阶段，模型再在预处理后的序列进行预测。本文打破了该惯例，将其更新为深度模型的基本内部块，而这种设计使Autoformer具有复杂时间序列的渐进分解能力，更易发现潜藏在复杂时序中规律。</p>
<h3 id="自相关机制">自相关机制</h3>
<p>自相关模块是通过计算序列自相关系数，发现周期依赖项，然后再平移时间做相似子序列的聚合。整体结构如下图所示，其中红色框部分为周期依赖发现，绿色框部分为时延聚合。</p>
<p><img src="/2022/05/05/Autoformer/5.png" alt="image-20220505105859201"></p>
<h4 id="基于周期的依赖发现">基于周期的依赖发现</h4>
<p>自相关系数表示序列${ {X_t} }$与延迟$\tau$时刻的序列${ {X_{x-\tau} } }$之间的相似性。</p>
<p><img src="/2022/05/05/Autoformer/6.png" alt="image-20220505110940247"></p>
<p>这里可以将这种时延相似性看作未归一化的周期估计的置信度，即周期长度为${\tau}$的置信度为$R(\tau)$。</p>
<p><img src="/2022/05/05/Autoformer/7.png" alt="image-20220505140533140"></p>
<p>通过这样的运作，置信度大的周期长度，说明<strong>原序列与此序列之间的相似性越大，从而建立序列与序列的依赖</strong>。</p>
<p>注：这里Roll操作是将左移出去的序列补充到右边空出来的部分，是因为自相关系数计算需要序列是无穷序列，而实际上的序列都是有限序列，所以通过将原序列看成一个周期为L(原序列长度)的周期序列便可以将序列长度无穷化。</p>
<p>这里原序列与延迟${\tau}$的序列计算自相关系数，而${\tau}$的范围是1至L，因此一次自相关机制就需要做L次自相关计算。为了提高效率，本文基于Winer-Khinchin理论，用快速傅里叶变换（FFT）计算自相关系数，使得复杂度仅为O(LlogL)，大大减少了运行时间。对Winer-Khinchin理论和快速傅里叶变换感兴趣的，可以阅读博客：<a href="https://upupming.site/2018/12/27/fourier-transform/#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">傅里叶变换</a>。</p>
<p><img src="/2022/05/05/Autoformer/8.png" alt="image-20220505141934939"></p>
<h4 id="时延聚合">时延聚合</h4>
<p>聚合相似子序列以得到输出序列。</p>
<p>步骤：</p>
<p><img src="/2022/05/05/Autoformer/9.png" alt="image-20220505141356314"></p>
<ol>
<li>这里从L个延迟$\tau$时刻的子序列中选取自相关系数最大的k个子序列。k的选取按照规则：$k = \lfloor c \times \log L\rfloor $</li>
<li>通过softmax将自相关系数映射成概率，值越大，与原序列相似度越大。</li>
<li>依该概率对各延迟τ时刻序列进行加权叠加，最后得到输出序列。</li>
</ol>
<h4 id="创新点">创新点</h4>
<p>自相关模块不同于之前Transformer中的自注意一类的模块，后者更关注与point-wise之间的依赖性，而前者更关注series-wise之间的依赖性。对比图如下：</p>
<p><img src="/2022/05/05/Autoformer/10.png" alt="image-20220505142427595"></p>
<ul>
<li>
<p><strong>Full Attention</strong>：所有引起注意的点都会起作用，来决定当前的预测值。但时间效率低，从而出现了各种稀疏变种。</p>
</li>
<li>
<p><strong>Sparse Attention</strong>：通过top-k选择，将注意退化为稀疏注意，从而使得只关注最引起注意的部分。</p>
</li>
<li>
<p><strong>LogSparse Attention</strong>：只选择距离满足条件的引起注意的点。</p>
</li>
<li>
<p><strong>Auto-Correlation</strong>：自相关机制则不关注点与点的关系，而是实现了序列与序列之间的高效连接，即建立当前预测序列与已知序列的子序列的关系，从而可以更好地利用时序的特点，进行有效信息聚合，打破信息利用瓶颈。同时，自相关机制采用FFT的方法进行相关系数计算，提高了模型的时间效率。</p>
</li>
<li>
<p>同时，本文设计了多头的自相关机制，从而无缝替换自注意力机制。</p>
</li>
</ul>
<h3 id="编-解码器架构">编-解码器架构</h3>
<p>Autoformer没有改变Transformer的编-解码器架构，只是更新了编码器与解码器以利于长时间序列预测任务。</p>
<h4 id="编码器">编码器</h4>
<p><img src="/2022/05/05/Autoformer/11.png" alt="image-20220505144442359"></p>
<p>输入是过去I个时间点长度的序列$X_{en}\in R^{I\times d}$，d为输入的特征数。输出是${S_{en}^{l,2} }$，$l$表示第$l$个编码层。假设有N个编码层，第$l$个编码层可以表示为：$X_{en}^{l}=Encoder(X_{en}^{l-1})$，内部细节如下：</p>
<p><img src="/2022/05/05/Autoformer/12.png" alt="img"></p>
<p>从上述描述中可以看出编码器重点关注时间序列的季节项，输出的是输入的过去时间序列的季节性信息，它将被用做互信息，帮助解码器调整预测结果。</p>
<h4 id="解码器">解码器</h4>
<p><img src="/2022/05/05/Autoformer/13.png" alt="image-20220505150755766"></p>
<p>输入分为三部分：初始季节项$X_{des}\in R^{(\frac{I}{2}+O)\times d}$、初始周期项$X_{det}\in R^{(\frac{I}{2}+O)\times d}$、编码器输出。d：输入特征数、O为预测的时间长度。</p>
<p><img src="/2022/05/05/Autoformer/15.png" alt="image"></p>
<p>解码器包括两个部分：1、对趋势项使用累加操作；2、对季节项使用堆叠自相关机制来挖掘依赖。</p>
<p>假设我们有M个解码层，N个编码层，第$l$个解码层可以表示为：$X_{de}^{l}=Decoder(X_{de}^{l-1}, X_{en}^N)$，其中内部细节为：</p>
<p><img src="/2022/05/05/Autoformer/14.png" alt="image"></p>
<p>最后预测序列等于：$predction = W_{s}*X_{de}^M+\tau_{de}^M$</p>
<h2 id="后续实验与分析">后续实验与分析</h2>
<h3 id="实验">实验</h3>
<p>在6个真实世界的基准上对Autoformer进行了广泛的评估，涵盖了5个主流的时间序列预测应用:能源、交通、经济、天气和疾病。在具有不同预测长度$O\in{96,192,336,720}$的多元结果。</p>
<p><img src="/2022/05/05/Autoformer/16.png" alt="image-20220505153207603"></p>
<p>本文在各种输入-输出设置下，对比了自相关机制与各种自注意力机制，比如，经典Transformer中Full Attention，Informer中PropSparse Attention等。本文提出的自相关机制依然取得了最优的结果</p>
<p><img src="/2022/05/05/Autoformer/17.png" alt="image-20220505153207603"></p>
<h3 id="模型分析">模型分析</h3>
<p><strong>渐进式分解效果：</strong> 随着序列分解单元的数量增加，模型的学到的趋势项会越来越接近数据真实结果，周期项可以更好的捕捉序列变化情况，这验证了渐进式分解的作用。</p>
<p><img src="/2022/05/05/Autoformer/18.png" alt="image-20220505153207603"></p>
<p><strong>时序依赖可视化：</strong> 通过对比可以发现，Autoformer中自相关机制可以正确发掘出每个周期中的下降过程，并且<strong>没有误识别和漏识别</strong>，而自注意力机制存在错误和缺漏。</p>
<p><img src="/2022/05/05/Autoformer/19.png" alt="image-20220505153207603"></p>
<p><strong>效率分析：</strong> 在显存占用和运行时间两个指标上，自相关机制均表现出了优秀的空间时间效率，两个层面均超过自注意力机制，表现出高效$O(L\log L)$的复杂度。</p>
<p><img src="/2022/05/05/Autoformer/20.png" alt="image-20220505153207603"></p>
<h2 id="参考">参考</h2>
<p>1、<a href="https://mp.weixin.qq.com/s/t0aAUYfurprtu7RPl5mqwg">Autoformer:基于深度分解架构和自相关机制的长期序列预测模型</a></p>
<p>2、<a href="https://zhuanlan.zhihu.com/p/472624073">[时序] Autoformer：基于深度分解架构和自相关机制的长期序列预测模型</a></p>
<p>3、<a href="https://blog.csdn.net/yaohaishen/article/details/118611746">Autoformer-时序模型的突破</a></p>
]]></content>
      <tags>
        <tag>论文精读</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop八股文</title>
    <url>/2023/03/26/Hadoop%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JAVA八股文-JAVA基础</title>
    <url>/2023/03/26/JAVA%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h1><a href="https://www.javalearn.cn/#/doc/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%A2%98?id=java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98">Java 基础面试题</a></h1>
<p><strong>2023月3月26日</strong>：Java 是编译执行的语言，还是解释执行的语言?</p>
<p><img src="/2023/03/26/JAVA%E5%85%AB%E8%82%A1%E6%96%87/image-20230326204001362.png" alt="image-20230326204001362"></p>
<p>JAVA是一种混合型语言，因为所有的Java代码都需要经过javac编译为.class文件，但主要是由于java现在拥有了<a href="https://so.csdn.net/so/search?q=jit&amp;spm=1001.2101.3001.7020">jit</a>，会将热点代码的.class文件直接编译为二进制本地代码。同时java代码编译后的.class文件还是不能直接运行在操作系统上，还需要经过jvm解释为二进制代码。</p>
<p>进度：关键字</p>
]]></content>
      <tags>
        <tag>JAVA, 面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>LGBM学习记录</title>
    <url>/2022/04/22/LGBM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="GBDT-Gradient-Boosting-Decision-Tree">GBDT (Gradient Boosting Decision Tree)</h3>
<p>主要思想是利用弱分类器（决策树）迭代训练以得到最优模型，该模型具有<strong>训练效果好、不易过拟合</strong>等优点。</p>
<p>目前已有的 GBDT 工具基本都是基于预排序的决策树算法(如 Xgboost)。这种构建决策树的算法基本思想是：</p>
<p>首先，对所有特征都按照特征的数值进行预排序。其次，在遍历分割点的时候用O(n)的代价找到一个特征上的最好分割点。最后，找到一个特征的分割点后，将数据分裂成左右子节点。</p>
<p>这样的预排序算法的优点是：能精确地找到分割点。缺点也很明显：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次，时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</p>
<h3 id="LGBM（LightGBM）">LGBM（LightGBM）</h3>
<p>LightGBM 的动机：常用的机器学习算法，例如神经网络等算法，都可以用 mini-batch 的方式训练，训练数据的大小不会受到内存限制。而 GBDT 在每一次迭代的时候，都需要遍历整个训练数据集多次。如果把整个训练数据装进内存则会限制训练数据集的大小；如果不装进内存，反复遍历训练数据集又会消耗大量时间。尤其面对工业上海量的数据，普通的 GBDT 算法是不能满足其需求的。LightGBM 提出的主要原因就是为了解决 GBDT 在海量数据上遇到的问题，让 GBDT 可以更好地用于工业实践。</p>
<p>LGBM与传统算法相比具有的优点：更快的训练效率；低内存使用；更高的准确率；支持并行化学习；可处理大规模数据；原生支持类别特征，不需要对类别特征再进行0-1编码。</p>
<h4 id="Histogram-算法">Histogram 算法</h4>
<p>直方图算法的基本思想是先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p>
<p>在计算上的代价也大幅降低，预排序算法每遍历一个特征值就需要计算一次分裂的增益，而直方图算法只需要计算k次（k为超参数），时间复杂度从O(data * feature)优化到O(k * features)。</p>
<p>Histogram 算法由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</p>
<h4 id="Leaf-wise">Leaf-wise</h4>
<p>LGBM抛弃了大多数 GBDT 工具使用的按层生长 (level-wise) 的决策树生长策略，而使用了带有深度限制的按叶子生长 (leaf-wise) 算法。Level-wise 过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上 Level-wise 是一种低效的算法，因为它不加区分的对待同一层的叶子，而实际上很多叶子的分裂增益较低，没必要进行搜索和分裂，从而带来了很多没必要的开销。</p>
<p>Leaf-wise 则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同 Level-wise 相比，在分裂次数相同的情况下，Leaf-wise 可以降低更多的误差，得到更好的精度。Leaf-wise 的缺点是可能会长出比较深的决策树，产生过拟合。因此 LightGBM 在 Leaf-wise 之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p>
<h4 id="Gradient-based-One-Side-Sampling-GOSS">Gradient-based One-Side Sampling(GOSS)</h4>
<p>GOSS技术是去掉了很大一部分梯度很小的数据，只使用剩下的去估计信息增益，避免低梯度长尾部分的影响。由于梯度大的数据在计算信息增益的时候更重要，所以GOSS在小很多的数据上仍然可以取得相当准确的估计值。</p>
<h4 id="Exclusive-Feature-Bundling-EFB">Exclusive Feature Bundling(EFB)</h4>
<p>EFB技术是指捆绑互斥的特征（如他们经常同时取值为0），以减少特征的数量。对互斥特征寻找最佳的捆绑方式是一个NP难问题，不过贪婪算法可以取得相当好的近似率，因此可以在不显著影响分裂点选择的准确性的情况下，显著地减少特征数量。</p>
<h3 id="模型创建">模型创建</h3>
<h4 id="LGBM">LGBM</h4>
<h5 id="方式1：使用lgb的风格">方式1：使用lgb的风格</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LGBM <span class="keyword">as</span> lgb</span><br><span class="line">params_lgb_ = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;regression&#x27;</span>, </span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.1</span>, </span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">50</span>, </span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">6</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.8</span>, </span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.8</span>, </span><br><span class="line">    &#125;</span><br><span class="line">model_lgb = lgb.cv(</span><br><span class="line">    params_lgb_, train_data, num_boost_round=<span class="number">50000</span>, nfold=<span class="number">5</span>, stratified=<span class="literal">False</span>, shuffle=<span class="literal">True</span>, metrics=<span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">    early_stopping_rounds=<span class="number">50</span>, verbose_eval=<span class="number">50</span>, show_stdv=<span class="literal">True</span>, seed=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="方式二：使用sklearn风格">方式二：使用sklearn风格</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LGBM <span class="keyword">as</span> lgb</span><br><span class="line">params_test1 = &#123;<span class="string">&#x27;num_leaves&#x27;</span>:[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]&#125;</span><br><span class="line">model_lgb = lgb.LGBMRegressor(objective=<span class="string">&#x27;regression&#x27;</span>,</span><br><span class="line">                              max_depth = <span class="number">3</span>,</span><br><span class="line">                              learning_rate=<span class="number">0.1</span>, </span><br><span class="line">                              n_estimators=<span class="number">3938</span>,</span><br><span class="line">                              metric=<span class="string">&#x27;rmse&#x27;</span>, </span><br><span class="line">                              bagging_fraction = <span class="number">0.8</span>,</span><br><span class="line">                              feature_fraction = <span class="number">0.8</span>)</span><br><span class="line">gsearch1 = GridSearchCV(estimator=model_lgb, </span><br><span class="line">                        param_grid=params_test1, </span><br><span class="line">                        scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>, </span><br><span class="line">                        cv=<span class="number">5</span>, </span><br><span class="line">                        verbose=<span class="number">1</span>, </span><br><span class="line">                        n_jobs=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LGBMRegressor参数">LGBMRegressor参数</h3>
<p><strong>boosting_type</strong> ：‘gbdt’,‘rf’</p>
<p><strong>n_jobs</strong>  几核cpu</p>
<p><strong>silent</strong> 默认选择True，选择False会输出很多建模中的细节，作用不大还刷屏。</p>
<p><em>注</em>：上面三个参数是要在开始前就确定的</p>
<p><strong>learning_rate</strong>：学习率，初始状态建议选择较大的学习率，设置为0.1.</p>
<p><strong>n_estimators</strong>：树的数量，初始状态适配lr = 0.1</p>
<p><em>注</em>：这两个参数作用于树的数量，不关心树的内部。，这两个参数需要联调</p>
<p><strong>max_depth</strong>：每棵树的最大深度，防止过拟合。初始状态设置3~8。</p>
<p><strong>num_leaves</strong> :每棵树的最多叶子数，因为CART是二叉树，所以叶子数量最大值为2 <strong>depth，所以num_leaves要小于该值才有意义。</strong></p>
<p>min_child_samples**：又称为min_data_in_leaf，指要想建立一个叶子所需要的的最少样本数，增大它可以降低过拟合。**</p>
<p>min_child_weight**：又称为min_sum_hessian_in_leaf，指要想建立一个叶子，该叶子需要提供的最小hessian值。这两个参数都是对新建叶子设置了门槛，可以降低叶子数量，减小过拟合。**</p>
<p>feature_fraction**：每次新建一棵树时，随机使用多少的特征。**</p>
<p><strong>bagging_fraction</strong>：每次进行bagging时，随机使用多少的样本。</p>
<p><strong>bagging_freq</strong>：每建立多少棵树，就进行一次bagging。</p>
<p><strong>reg_alpha</strong>：L1正则化参数</p>
<p><strong>reg_lambda</strong>：L2正则化参数</p>
<p><em>注</em>：上面的参数是调整每棵树的属性</p>
<p><strong>基本调参思路，首先设置lr=0.1确定树的数量，然后调整每颗树的内部参数到最佳。确定树的内部参数后，用该参数，降低lr，反调lr和树的数量。</strong></p>
]]></content>
      <tags>
        <tag>LightGBM</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-11-30</title>
    <url>/2022/11/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-11-30/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<h3 id="题目：最大频率栈">题目：最大频率栈</h3>
<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>
<p>实现 <code>FreqStack</code> 类:</p>
<ul>
<li><code>FreqStack()</code> 构造一个空的堆栈。</li>
<li><code>void push(int val)</code> 将一个整数 <code>val</code> 压入栈顶。</li>
<li><code>int pop()</code>删除并返回堆栈中出现频率最高的元素。 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
<h3 id="示例">示例</h3>
<h4 id="1、">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line">解释：</span><br><span class="line">FreqStack = new FreqStack();</span><br><span class="line">freqStack.push (5);//堆栈为 [5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7,5,7]</span><br><span class="line">freqStack.push (4);//堆栈是 [5,7,5,7,4]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5,7,4,5]</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></pre></td></tr></table></figure>
<h3 id="提示">提示:</h3>
<ul>
<li>0 &lt;= val &lt;= 109</li>
<li>push 和 pop 的操作数不大于 $2 * 10^4$。</li>
<li>输入保证在调用 pop之前堆栈中至少有一个元素。</li>
</ul>
<h3 id="来源">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">https://leetcode.cn/problems/maximum-frequency-stack/description/</a></p>
<h2 id="问题解答">问题解答</h2>
<h4 id="哈希表和栈">哈希表和栈</h4>
<p>在本题中，每次需要优先弹出频率最大的元素，如果频率最大元素有多个，则优先弹出靠近栈顶的元素。因此，我们可以考虑将栈序列分解为多个频率不同的栈序列，每个栈维护同一频率的元素。当元素入栈时频率增加，将元素加入到更高频率的栈中，低频率栈中的元素不需要出栈。当元素出栈时，将频率最高的栈的栈顶元素出栈即可。</p>
<p>详细的，我们用一个哈希表 freq 来记录每个元素出现的次数。设当前最大频率为 maxFreq，为 1∼maxFreq1  中的每种频率单独设置一个栈。为了方便描述，记 freq[x] 为 x 的频率，group[i] 为频率为 i 的栈。</p>
<ul>
<li>当元素 xxx 入栈时，令 freq[x]+1，然后将 x 放入 group[freq[x]]中，更新 maxFreq=max⁡(maxFreq,freq[x])。此时，group[1]∼group[freq[x]] 的每一个栈中都包含 x。</li>
<li>元素出栈时，获取 x=group[maxFreq].top() 作为出栈元素，令 freq[x]−1，若 x 出栈后 group[maxFreq] 为空，则令 maxFreq−1。</li>
</ul>
<h4 id="代码">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumOfAverages</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        prefix = <span class="built_in">list</span>(accumulate(nums, initial=<span class="number">0</span>))</span><br><span class="line">        dp = [<span class="number">0.0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = prefix[i] / i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, k + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, j - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(j - <span class="number">1</span>, i):</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[x] + (prefix[i] - prefix[x]) / (i - x))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析">复杂度分析</h4>
<ul>
<li>时间复杂度：对于 push 和 pop 操作，时间复杂度为 O(1)。</li>
<li>空间复杂度：O(n)，其中 n 是 FreqStack 中元素的个数。</li>
</ul>
<h4 id="作者">作者</h4>
<p>力扣官方题解<br>
链接：<a href="https://leetcode.cn/problems/maximum-frequency-stack/solutions/1997251/zui-da-pin-lu-zhan-by-leetcode-solution-moay/">https://leetcode.cn/problems/maximum-frequency-stack/solutions/1997251/zui-da-pin-lu-zhan-by-leetcode-solution-moay/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-12-14</title>
    <url>/2022/12/14/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-14/</url>
    <content><![CDATA[<h2 id="问题描述-2">问题描述</h2>
<h3 id="题目：检查边长度限制的路径是否存在">题目：检查边长度限制的路径是否存在</h3>
<p>给你一个 n 个点组成的无向图边集 edgeList ，其中 $edgeList[i] = [u_i, v_i, dis_i]$ 表示点 $u_i$ 和点 $v_i$ 之间有一条长度为 $dis_i$ 的边。请注意，两个点之间可能有 <strong>超过一条边</strong> 。</p>
<p>给你一个查询数组queries ，其中 $queries[j] = [p_j, q_j, limit_j]$ ，你的任务是对于每个查询 queries[j] ，判断是否存在从 $p_j$ 到 $q_j$ 的路径，且这条路径上的每一条边都 <strong>严格小于</strong> $limit_j$ 。</p>
<p>请你返回一个 <strong>布尔数组</strong> answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。</p>
<h3 id="示例-2">示例</h3>
<h4 id="1、image-20221214191001089">1、<img src="/2022/12/14/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-14/1.png" alt="image-20221214191001089"></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]</span><br><span class="line">输出：[false,true]</span><br><span class="line">解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。</span><br><span class="line">对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。</span><br><span class="line">对于第二个查询，有一条路径（0 -&gt; 1 -&gt; 2）两条边都小于 5 ，所以这个查询我们返回 true 。</span><br></pre></td></tr></table></figure>
<h4 id="2、">2、</h4>
<p><img src="/2022/12/14/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-14/2.png" alt="image-20221214191051019"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]</span><br><span class="line">输出：[true,false]</span><br><span class="line">解释：上图为给定数据。</span><br></pre></td></tr></table></figure>
<h3 id="提示-2">提示:</h3>
<ul>
<li>2 &lt;= n &lt;= $10^5$</li>
<li>1 &lt;= edgeList.length, queries.length &lt;= $10^5$</li>
<li>edgeList[i].length == 3</li>
<li>queries[j].length == 3</li>
<li>0 &lt;= $u_i$, $v_i$, $p_j$, $q_j$ &lt;= n - 1</li>
<li>$u_i$ != $v_i$</li>
<li>$p_j$ != $q_j$</li>
<li>1 &lt;= $dis_i$, $limit_j$ &lt;= $10^5$</li>
<li>两个点之间可能有 <strong>多条</strong> 边。</li>
</ul>
<h3 id="来源-2">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/">https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/</a></p>
<h2 id="问题解答-2">问题解答</h2>
<h4 id="离线查询-并查集">离线查询 + 并查集</h4>
<p>注：并查集：<a href="https://oi-wiki.org/ds/dsu/">https://oi-wiki.org/ds/dsu/</a></p>
<p>给定一个查询时，我们可以遍历 edgeList 中的所有边，依次将长度小于 limit 的边加入到并查集中，然后使用并查集查询 p 和 q 是否属于同一个集合。如果 p 和 q 属于同一个集合，则说明存在从 p 到 q 的路径，且这条路径上的每一条边的长度都严格小于 limit，查询返回 true，否则查询返回 false。</p>
<p>如果 queries 的 limit 是非递减的，显然上一次查询的并查集里的边都是满足当前查询的 limit 要求的，我们只需要将剩余的长度小于 limit 的边加入并查集中即可。基于此，我们首先将 edgeList 按边长度从小到大进行排序，然后将 queries 按 limit 从小到大进行排序，使用 k 指向上一次查询中不满足 limit 要求的长度最小的边，显然初始时 k=0。</p>
<p>我们依次遍历 queries：如果 k 指向的边的长度小于对应查询的 limit，则将该边加入并查集中，然后将 k 加 1，直到 k 指向的边不满足要求；最后根据并查集查询对应的 p 和 q 是否属于同一集合来保存查询的结果。</p>
<h4 id="代码-2">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distanceLimitedPathsExist</span>(<span class="params">self, n: <span class="built_in">int</span>, edgeList: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">bool</span>]:</span><br><span class="line">        edgeList.sort(key=<span class="keyword">lambda</span> e: e[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 并查集模板</span></span><br><span class="line">        fa = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> fa[x] != x:</span><br><span class="line">                fa[x] = find(fa[x])</span><br><span class="line">            <span class="keyword">return</span> fa[x]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">from_: <span class="built_in">int</span>, to: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            fa[find(from_)] = find(to)</span><br><span class="line"></span><br><span class="line">        ans, k = [<span class="literal">False</span>] * <span class="built_in">len</span>(queries), <span class="number">0</span></span><br><span class="line">        <span class="comment"># 查询的下标按照 limit 从小到大排序，方便离线</span></span><br><span class="line">        <span class="keyword">for</span> i, (p, q, limit) <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">enumerate</span>(queries), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>][<span class="number">2</span>]):</span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="built_in">len</span>(edgeList) <span class="keyword">and</span> edgeList[k][<span class="number">2</span>] &lt; limit:</span><br><span class="line">                merge(edgeList[k][<span class="number">0</span>], edgeList[k][<span class="number">1</span>])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            ans[i] = find(p) == find(q)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-2">复杂度分析</h4>
<ul>
<li>时间复杂度：$O \big ( E \log E + m \log m + (E + m) \log n + n \big )$，其中 E 是 edgeList 的长度，m是 queries 的长度，n 是点数。对 edgeList 和 queries 进行排序分别需要 $O(Elog⁡E)$ 和 $O(mlog⁡m)$，并查集初始化需要 O(n)，并查集查询和合并总共需要 $O \big ((E+m)\log n \big )$。</li>
<li>空间复杂度：$O(\log E + m + n)$。保存并查集需要 O(n)O(n)O(n) 的空间，保存 index 需要 O(m) 的空间，以及排序需要的栈空间。</li>
</ul>
<h4 id="作者-2">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solutions/2018397/jian-cha-bian-chang-du-xian-zhi-de-lu-ji-cdr5/">https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solutions/2018397/jian-cha-bian-chang-du-xian-zhi-de-lu-ji-cdr5/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-9-28</title>
    <url>/2022/09/28/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-11-28/</url>
    <content><![CDATA[<h2 id="问题描述-3">问题描述</h2>
<h3 id="题目：最大平均值和的分组">题目：最大平均值和的分组</h3>
<p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>
<p>返回我们所能得到的最大分数是多少。答案误差在$10^6$内被视为是正确的。</p>
<h3 id="示例-3">示例</h3>
<h4 id="1、-2">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [9,1,2,3,9], k = 3</span><br><span class="line">输出: 20.00000</span><br><span class="line">解释: </span><br><span class="line">nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. </span><br><span class="line">我们也可以把 nums 分成[9, 1], [2], [3, 9]. </span><br><span class="line">这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.</span><br></pre></td></tr></table></figure>
<h4 id="2、-2">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 4</span><br><span class="line">输出: 20.50000</span><br></pre></td></tr></table></figure>
<h3 id="提示-3">提示:</h3>
<ul>
<li>1 &lt;= nums.length &lt;= 100</li>
<li>1 &lt;= nums[i] &lt;= 104</li>
<li>1 &lt;= k &lt;= nums.length</li>
</ul>
<h3 id="来源-3">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/largest-sum-of-averages/solutions/1993132/zui-da-ping-jun-zhi-he-de-fen-zu-by-leet-09xt/">https://leetcode.cn/problems/largest-sum-of-averages/solutions/1993132/zui-da-ping-jun-zhi-he-de-fen-zu-by-leet-09xt/</a></p>
<h2 id="问题解答-3">问题解答</h2>
<h3 id="动态规划">动态规划</h3>
<p>命题：平均值和最大的分组的子数组数目必定是 k。</p>
<p>证明：假设一种分组的子数组数目小于 k，那么它必然有一个子数组的元素数目 $c&gt;1$，即仍然可以进行切分。设该子数组的平均值为 m，左侧第一个元素为 x，那么将该子数组第一个元素切分之后，平均值和为$\frac{m×c−x}{c−1}+x=\frac{c}{c−1}×m+\frac{c−2}{c−1}×x&gt;m$，因此再次切分后平均值和会增加，所以平均值和最大的分组的子数组数目必定是 k。</p>
<p>为了方便计算子数组的平均值，我们使用一个数组 prefix 来保存数组 nums 的前缀和。我们使用 $dp[i][j]$表示 nums 在区间 $[0,i−1]$ 被切分成 j 个子数组的最大平均值和，显然 $i≥j$，计算分两种情况讨论：</p>
<ul>
<li>当 $j=1$ 时，$dp[i][j]$ 是对应区间 $[0,i−1]$ 的平均值；</li>
<li>当 $j&gt;1$ 时，我们将可以将区间 $[0,i−1]$ 分成 $[0,x−1]$ 和 $[x,i−1]$ 两个部分，其中 $x≥j−1$，那么 $dp[i][j]$ 等于所有这些合法的切分方式的平均值和的最大值。</li>
</ul>
<p>因此转移方程为：<br>
$dp[i][j]=\left{\begin{matrix}\frac{\sum^{i-1}<em>{r=0}nums[r]}{i},j=1\\max</em>{x\geq j-1}{dp[x][j-1]+\frac{\sum^{i-1}_{r=x}nums[r]}{i-x}},j&gt;1 \end{matrix}\right.$</p>
<p>假设数组 nums 的长度为 n，那么 $dp[n][k]$ 表示数组 nums 分成 k 个子数组后的最大平均值和，即最大分数。由于 $dp[i][j]$ 的计算只利用到 j−1的数据，因此也可以使用一维数组对 $dp[i][j]$进行计算，在计算过程中，要注意对 i 进行逆序遍历。</p>
<h4 id="代码-3">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumOfAverages</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        prefix = <span class="built_in">list</span>(accumulate(nums, initial=<span class="number">0</span>))</span><br><span class="line">        dp = [<span class="number">0.0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = prefix[i] / i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, k + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, j - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(j - <span class="number">1</span>, i):</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[x] + (prefix[i] - prefix[x]) / (i - x))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-3">复杂度分析</h4>
<ul>
<li>时间复杂度：$O(k×n2)$，其中 k 是分组的最大子数组数目，n 是数组 nums 的长度。计算前缀和需要 $O(n)$ 的时间，动态规划需要计算 $O(k×n)$ 个状态，每个状态的计算时间是 $O(n)$。</li>
<li>空间复杂度：$O(k×n)$ 或 $O(n)$，其中 k 是分组的最大子数组数目，n 是数组 nums 的长度。二维数组实现的空间复杂度是 $O(k×n)$，一维数组实现的空间复杂度是 $O(n)$。</li>
</ul>
<h4 id="作者-3">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/largest-sum-of-averages/solutions/1993132/zui-da-ping-jun-zhi-he-de-fen-zu-by-leet-09xt/">https://leetcode.cn/problems/largest-sum-of-averages/solutions/1993132/zui-da-ping-jun-zhi-he-de-fen-zu-by-leet-09xt/</a></p>
<h3 id="前缀和-记忆化搜索">前缀和 + 记忆化搜索</h3>
<p>我们可以先预处理得到前缀和数组 s，方便快速得到子数组的和。</p>
<p>然后设计一个函数 $dfs(i,k)$，表示从数组下标 i 开始，最多分成 k 组的最大平均值和。答案即为 $dfs(0,k)$。</p>
<p>函数 $dfs(i,k)$ 的执行逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 i=n 时，表示已经遍历到数组末尾，此时返回 0。</span><br><span class="line">当 k=1 时，表示只剩下一组，此时返回从下标 开始到数组末尾的平均值。</span><br><span class="line">否则，我们在 [i,..n−1] 的范围内枚举分组的结束位置 j，计算从下标 i 到下标 j 的平均值，以及从下标 j+1 开始，最多分成 k−1 组的最大平均值和。取其中的最大值作为答案。</span><br></pre></td></tr></table></figure>
<p>为了避免重复计算，我们可以用数组 f 记忆化函数 $dfs(i,k)$ 的返回值。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumOfAverages</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, k</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (s[-<span class="number">1</span>] - s[i]) / (n - i)</span><br><span class="line"></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line"></span><br><span class="line">                t = (s[j + <span class="number">1</span>] - s[i]) / (j - i + <span class="number">1</span>) + dfs(j + <span class="number">1</span>, k - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, t)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        s = <span class="built_in">list</span>(accumulate(nums, initial=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, k)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-4">复杂度分析</h4>
<p>时间复杂度 $O(n^2×k)$，空间复杂度 $O(n×k)$。其中 n 表示数组 nums 的长度。</p>
<h4 id="作者-4">作者</h4>
<p>ylb，链接：<a href="https://leetcode.cn/problems/largest-sum-of-averages/solutions/1995066/by-lcbin-5efy/">https://leetcode.cn/problems/largest-sum-of-averages/solutions/1995066/by-lcbin-5efy/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-12-2</title>
    <url>/2022/12/02/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-2/</url>
    <content><![CDATA[<h2 id="问题描述-4">问题描述</h2>
<h3 id="题目：移动所有球到每个盒子所需的最小操作数">题目：移动所有球到每个盒子所需的最小操作数</h3>
<p>有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 ‘1’ 表示盒子里有 一个 小球。</p>
<p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>
<p>返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的最小操作数。</p>
<p>每个 answer[i] 都需要根据盒子的初始状态进行计算。</p>
<h3 id="示例-4">示例</h3>
<h4 id="1、-3">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：boxes = &quot;110&quot;</span><br><span class="line">输出：[1,1,3]</span><br><span class="line">解释：每个盒子对应的最小操作数如下：</span><br><span class="line">1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。</span><br><span class="line">2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。</span><br><span class="line">3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。</span><br></pre></td></tr></table></figure>
<h4 id="2、-3">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：boxes = &quot;001011&quot;</span><br><span class="line">输出：[11,8,5,4,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="提示-4">提示:</h3>
<ul>
<li>n == boxes.length</li>
<li>1 &lt;= n &lt;= 2000</li>
<li>boxes[i]为 '0’或 ‘1’</li>
</ul>
<h3 id="来源-4">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/">https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/</a></p>
<h2 id="问题解答-4">问题解答</h2>
<h4 id="规律迭代法">规律迭代法</h4>
<p>本题很容易可以想到用暴力法，即计算在每一个盒子，其他到该盒子的总和。这里换一种思路，其实由于每个 answer[i] 都需要根据盒子的初始状态进行计算，所以相邻盒子之间有着某种关系。下图进行证明：</p>
<p>设当前盒子的状态为下图，即当前盒子里的状态为c，在它前面总共有a个球，在它后面总共有b个钱，总共移动次数为d，前面移动次数总和为d1，后面为d2，则$d=d1+d2$。</p>
<p><img src="/2022/12/02/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-2/image-20221202175646812.png" alt="image-20221202175646812"></p>
<p>则下一个盒子状态为：</p>
<p><img src="/2022/12/02/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-2/image-20221202175849534.png" alt="image-20221202175849534"></p>
<p>该移动次数为$d’=d1+a+c+(d2-(b-c1)-c1)=d1+d2+a+c-b=d+a+c-b$，这里面$d1+a+c$表示前半部分由于盒子向后移动一次，前面a个球得多移动一次，且上一个盒子里面的c个球也得移动一次。$d2-(b-c1)-c1$表示后半部分剩下的b-c1个盒子里球的移动次数要减少一次，且当前盒子c1不用移动，相对上一个盒子也减少了c1。至此可以说明下一个盒子（从左到右）的移动次数与上一个盒子的移动次数有关。所以可以计算出第一个盒子的次数，后面就可以直接迭代得到所有盒子的移动次数。</p>
<h4 id="代码-5">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, boxes: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        answer = [<span class="number">0</span>]</span><br><span class="line">        boxes = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> boxes]</span><br><span class="line">        <span class="keyword">for</span> idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(boxes):</span><br><span class="line">            answer[<span class="number">0</span>] += idx*<span class="built_in">int</span>(data)</span><br><span class="line">        </span><br><span class="line">        boxes = <span class="built_in">list</span>(accumulate(boxes, initial=<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(boxes)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            a = boxes[i-<span class="number">1</span>]</span><br><span class="line">            c = boxes[i] - boxes[i-<span class="number">1</span>]</span><br><span class="line">            b = boxes[-<span class="number">1</span>] - boxes[i]</span><br><span class="line">            d = answer[i-<span class="number">1</span>] - b + a + c</span><br><span class="line">            answer.append(d)</span><br><span class="line">        <span class="keyword">return</span>  answer</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-5">复杂度分析</h4>
<ul>
<li>时间复杂度：时间复杂度为 O(n)，n为盒子个数。</li>
<li>空间复杂度：O(n)，其中 n 为盒子个数。</li>
</ul>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-12</title>
    <url>/2022/05/12/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-12/</url>
    <content><![CDATA[<h2 id="问题描述-5">问题描述</h2>
<h3 id="题目：序列化和反序列化二叉搜索树">题目：序列化和反序列化二叉搜索树</h3>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>
<p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。编码的字符串应尽可能紧凑。</p>
<h3 id="示例-5">示例</h3>
<ol>
<li>
<p>输入：root = [2,1,3]</p>
<p>输出：[2,1,3]</p>
</li>
<li>
<p>输入：root = [ ]</p>
<p>输出：[ ]</p>
</li>
</ol>
<h3 id="提示-5">提示</h3>
<ul>
<li>树中节点数范围是 [0, 104]</li>
<li>0 &lt;= Node.val &lt;= 104</li>
<li>题目数据保证输入的树是一棵二叉搜索树。</li>
</ul>
<h3 id="来源-5">来源</h3>
<p>力扣（LeetCode） 链接：<a href="https://leetcode.cn/problems/serialize-and-deserialize-bst">https://leetcode.cn/problems/serialize-and-deserialize-bst</a></p>
<h2 id="问题解答-5">问题解答</h2>
<h3 id="暴力法">暴力法</h3>
<h4 id="想法">想法</h4>
<p>二叉树就是由根节点、左子节点和右子节点组成，所以想序列化二叉搜索树就相当于保存好根节点的值和左右子节点的索引。所以按照中序遍历方式遍历整个二叉树，并按照以下规则进行转换成字符串：‘#节点索引v节点值l左子节点索引r右子节点索引r’。</p>
<p>反序列化就先得到所有定位字符的位置，然后创建所有节点，并命名为相应的索引，最后根据字符串给各个节点附上左子节点和右子节点。</p>
<p>不足：没有用到二叉搜索树的条件，这种方法对任意二叉树均可使用。</p>
<h4 id="代码-6">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">encoder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> +  <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_num = self.num</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(temp_num) + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> +  <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;r&#x27;</span> + encoder(root.right) </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    temp_num = self.num</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(temp_num) + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(<span class="number">0</span>) + <span class="string">&#x27;r&#x27;</span> + encoder(root.left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_num = self.num</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    left_num = self.num</span><br><span class="line">                    temp = encoder(root.left) </span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                    a = <span class="string">&#x27;#&#x27;</span> + <span class="built_in">str</span>(temp_num)  + <span class="string">&#x27;v&#x27;</span> + <span class="built_in">str</span>(root.val) + <span class="string">&#x27;l&#x27;</span> + <span class="built_in">str</span>(left_num) + <span class="string">&#x27;r&#x27;</span> + <span class="built_in">str</span>(self.num) + <span class="string">&#x27;r&#x27;</span> + temp</span><br><span class="line">                    <span class="keyword">return</span> a + encoder(root.right)</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> encoder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(data)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        node_pos = <span class="built_in">list</span>([])</span><br><span class="line">        node_v = <span class="built_in">list</span>([])</span><br><span class="line">        node_l = <span class="built_in">list</span>([])</span><br><span class="line">        node_r = <span class="built_in">list</span>([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node_pos.append(i)</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                node_v.append(i)</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                node_l.append(i)</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                node_r.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(node_pos):</span><br><span class="line">            nums = <span class="built_in">int</span>(data[j+<span class="number">1</span>:node_v[i]])</span><br><span class="line">            values = <span class="built_in">int</span>(data[node_v[i]+<span class="number">1</span>:node_l[i]])</span><br><span class="line">            <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(nums)] = TreeNode(values)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(node_pos):</span><br><span class="line">            nums = <span class="built_in">int</span>(data[j+<span class="number">1</span>:node_v[i]])</span><br><span class="line">            places_left = <span class="built_in">int</span>(data[node_l[i]+<span class="number">1</span>:node_r[<span class="number">2</span>*i]]) </span><br><span class="line">            places_right = <span class="built_in">int</span>(data[node_r[<span class="number">2</span>*i]+<span class="number">1</span>:node_r[<span class="number">2</span>*i+<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">if</span> places_left != <span class="number">0</span>: </span><br><span class="line">                <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(nums)].left = <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(places_left)]</span><br><span class="line">            <span class="keyword">if</span> places_right != <span class="number">0</span>: </span><br><span class="line">                <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(nums)].right = <span class="built_in">globals</span>()[<span class="string">&#x27;node&#x27;</span>+<span class="built_in">str</span>(places_right)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">globals</span>()[<span class="string">&#x27;node1&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<p>二叉搜索树它或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
<p><img src="/2022/05/12/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-12/1.png" alt="image-20220512190914590"></p>
<p>二叉搜索树的特殊之处在于其中序遍历是有序的，可以利用这一点来优化时间和空间复杂度。</p>
<h4 id="思路">思路</h4>
<p>给定一棵二叉树的「先序遍历」和「中序遍历」可以恢复这颗二叉树。给定一棵二叉树的「后序遍历」和「中序遍历」也可以恢复这颗二叉树。而对于二叉搜索树，给定「先序遍历」或者「后序遍历」，对其经过排序即可得到「中序遍历」。因此，仅对二叉搜索树做「先序遍历」或者「后序遍历」，即可达到序列化和反序列化的要求。此题解采用「后序遍历」的方法。</p>
<p>序列化时，只需要对二叉搜索树进行后序遍历，再将数组编码成字符串即可。</p>
<p>反序列化时，需要先将字符串解码成后序遍历的数组。在将后序遍历的数组恢复成二叉搜索树时，不需要先排序得到中序遍历的数组再根据中序和后序遍历的数组来恢复二叉树，而可以根据有序性直接由后序遍历的数组恢复二叉搜索树。后序遍历得到的数组中，根结点的值位于数组末尾，左子树的节点均小于根节点的值，右子树的节点均大于根节点的值，可以根据这些性质设计递归函数恢复二叉搜索树。</p>
<h4 id="代码-7">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            postOrder(root.left)</span><br><span class="line">            postOrder(root.right)</span><br><span class="line">            arr.append(root.val)</span><br><span class="line">        postOrder(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, arr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span><br><span class="line">        arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, data.split()))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">lower: <span class="built_in">int</span>, upper: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">            <span class="keyword">if</span> arr == [] <span class="keyword">or</span> arr[-<span class="number">1</span>] &lt; lower <span class="keyword">or</span> arr[-<span class="number">1</span>] &gt; upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            val = arr.pop()</span><br><span class="line">            root = TreeNode(val)</span><br><span class="line">            root.right = construct(val, upper)</span><br><span class="line">            root.left = construct(lower, val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> construct(-inf, inf)</span><br></pre></td></tr></table></figure>
<h4 id="作者-5">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-5m9r4/">https://leetcode.cn/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-5m9r4/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-12-5</title>
    <url>/2022/12/05/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-5/</url>
    <content><![CDATA[<h2 id="问题描述-6">问题描述</h2>
<h3 id="题目：从仓库到码头运输箱子">题目：从仓库到码头运输箱子</h3>
<p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 <strong>箱子数目的限制</strong> 和 <strong>总重量的限制</strong> 。</p>
<p>给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和maxWeight ，其中 boxes[i] = [$ports_i$, $weight_i$]。</p>
<ul>
<li>$ports_i$ 表示第i 个箱子需要送达的码头， $weight_i$是第 i 个箱子的重量。</li>
<li>portsCount 是码头的数目。</li>
<li>maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。</li>
</ul>
<p>箱子需要按照 <strong>数组顺序</strong> 运输，同时每次运输需要遵循以下步骤：</p>
<ul>
<li>卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。</li>
<li>对于在卡车上的箱子，我们需要<strong>按顺序</strong>处理它们，卡车会通过 <strong>一趟行程</strong> 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong> ，箱子也会立马被卸货。</li>
<li>卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong> 回到仓库，从箱子队列里再取出一些箱子。</li>
</ul>
<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。请你返回将所有箱子送到相应码头的 <strong>最少行程</strong> 次数。</p>
<h3 id="示例-6">示例</h3>
<h4 id="1、-4">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。</span><br><span class="line">所以总行程数为 4 。</span><br><span class="line">注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。</span><br></pre></td></tr></table></figure>
<h4 id="2、-4">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6</span><br><span class="line">输出：6</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第五个箱子，到达码头 3 ，回到仓库，总共 2 趟行程。</span><br><span class="line">总行程数为 2 + 2 + 2 = 6 。</span><br></pre></td></tr></table></figure>
<h4 id="3、">3、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7</span><br><span class="line">输出：6</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">总行程数为 2 + 2 + 2 = 6 。</span><br></pre></td></tr></table></figure>
<h4 id="4、">4、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7</span><br><span class="line">输出：14</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。</span><br><span class="line">- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。</span><br><span class="line">总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。</span><br></pre></td></tr></table></figure>
<h3 id="提示-6">提示:</h3>
<ul>
<li>1 &lt;= boxes.length &lt;= $10^5$</li>
<li>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10^5</li>
<li>1 &lt;= ports[i] &lt;= portsCount</li>
<li>1 &lt;= weights[i] &lt;= maxWeight</li>
</ul>
<h3 id="来源-6">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/description/">https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/description/</a></p>
<h2 id="问题解答-6">问题解答</h2>
<h4 id="动态规划-单调队列优化">动态规划 + 单调队列优化</h4>
<h5 id="前言">前言</h5>
<p>为了叙述方便，我们记箱子的数量为 n，它们的目的地分别为 $p_1, \cdots, p_n$，重量分别为 $w_1, \cdots, w_n$。</p>
<p>记 $W_i$ 表示 w 的前缀和，即：<br>
$$<br>
W_i = \left{ \begin{aligned} &amp; 0, &amp;&amp; i = 0 \ &amp; \sum_{k=1}^i w_i, &amp;&amp; i &gt; 0 \end{aligned} \right.<br>
$$<br>
这样我们可以用 $W_i - W_{j-1}$方便地表示第 i个到第 j 个箱子的重量，并与 maxWeight 进行比较。</p>
<p>记函数 $\mathbb{I}(i)$ 表示 $p_i$ 和 $p_{i+1}$ 是否不等，即：<br>
$$<br>
\mathbb{I}(i) = \begin{cases} 0, \quad p_i = p_{i+1} \ 1, \quad p_i \neq p_{i+1} \end{cases}<br>
$$<br>
记 neg}(i, j) 表示$p_i, \cdots, p_j$ 相邻两项不等的次数，即：<br>
$$<br>
\textit{neg}(i, j) = \sum_{k=i}^{j-1} \mathbb{I}(k)<br>
$$<br>
这样我们可以用 $neg(i,j)+2$ 方便地求出一次性运送第 i 个到第 j 个箱子需要的行程次数，这里的 $+2$ 表示来回仓库需要的 2 次。</p>
<p>为了便于快速计算 neg(i, j)，我们也可以使用前缀和的方式进行存储。记 $\textit{neg}_i = \textit{neg}(1, i)$表示前缀和，那么 $\textit{neg}(i, j) = \textit{neg}<em>j - \textit{neg}</em>{i}$可以在 O(1)的时间求出。</p>
<p>注意：这里是 $\textit{neg}<em>j - \textit{neg}</em>{i}$ 而不是 $\textit{neg}<em>j - \textit{neg}</em>{i-1}$，因为$neg_j$表示将第一个箱子从起始位置移动到第j个位置所需的行程次数，所以是减$neg_i$，这样就表示从第i个箱子位置出发。</p>
<h5 id="思路与算法">思路与算法</h5>
<p>我们可以使用动态规划解决本题。</p>
<p>记 $f_i$ 表示运送前 i 个箱子需要的最少行程次数，这里的“前 iii 个箱子”指的是目的地为 $p_1, \cdots, p_i$ 的 i 个箱子。我们可以写出状态转移方程：<br>
$$<br>
\begin{aligned} &amp; f_i = \min \big{ f_j + \textit{neg}(j+1,i) + 2 \big} \\ \text{subject to} \quad &amp; \begin{cases} 0 \leq j &lt; i \ i-j \leq \textit{maxBoxes} \ W_i-W_j \leq \textit{maxWeight} \end{cases} \end{aligned}<br>
$$<br>
即枚举上一次运送的最后一个箱子为 j（这里的 j 可以为 0，表示这一次是第一次运送箱子），那么这一次运送的箱子为 [j+1, i]。箱子的数量不超过 maxBoxes，重量之和不能超过 maxWeight。运送的行程次数即为 $p_{j+1}, \cdots, p_i$相邻两项不等的次数 $neg(j+1,i)$ 加上来回的 2 次。</p>
<p>边界条件为 $f_0 = $0，最终答案即为$f_n$。</p>
<h5 id="优化">优化</h5>
<p>然而上述动态规划的时间复杂度为 $O(n^2)$，需要进行优化。将 neg(j+1,i) 拆分成两个前缀和的差，即：$ \textit{neg}(j+1, i) = \textit{neg}<em>i - \textit{neg}</em>{j+1}$</p>
<p>带入原状态转移方程：<br>
$$<br>
\begin{aligned} f_i &amp;= \min \big{ f_j + \textit{neg}(j+1,i) + 2 \big} \ &amp;= \min \big{ f_j + \textit{neg}<em>i - \textit{neg}</em>{j+1} + 2 \big} \ &amp;= \min \big{ f_j - \textit{neg}_{j+1} \big} + \textit{neg}_i + 2 \end{aligned}<br>
$$<br>
由于 $\textit{neg}_i$ 和 2 都是与 j 无关的项，因此可以从$ \min{ \cdot }$ 中提取出来。</p>
<p>记 $g_j = f_j - \textit{neg}_{j+1}$，状态转移方程即为：$f_i = \min { g_j } + \textit{neg}(i) + 2$</p>
<p>如果只有 $0 \leq j &lt; i$ 的限制条件，那么我们实时维护 $g_j$ 的最小值进行 O(1) 的转移即可。但现在有$i-j \leq \textit{maxBoxes}$ 和 $W_i−W_j≤maxWeight$ 这两个额外的限制条件，最小的 $g_j$ 对应的 j 不一定满足限制。</p>
<p>我们可以将两个额外的限制看成：<br>
$$<br>
\begin{cases} j \geq i - \textit{maxBoxes} \ W_j \geq W_i - \textit{maxWeight} \end{cases}<br>
$$</p>
<p>注意到两个不等式右侧的值都是随着 i 的递增而递增的，因此如果当 $i=i_0$ 时，某个 $j_0$ 不满足不等式限制，那么当 $i&gt;i_0$ 时，$j_0$ 将永远不可能重新满足条件。</p>
<p>因此我们就可以使用单调队列对动态规划进行优化，对于两个可以进行转移的 $g_{j_0}$ 和 $g_{j_1}$，在$ j_0 &lt; j_1$ 的前提下：</p>
<ul>
<li>如果 $g_{j_0} &lt; g_{j_1}$，那么我们需要将 $g_{j_0}$ 和 $g_{j_1}$ 都保留下来，这是因为当 $j_0$ 还满足限制时，$g_{j_0}$ 比$g_{j_1}$ 更优；而当 $j_0$ 不满足限制后，$g_{j_1}$ 可能会代替 $g_{j_0}$，成为新的最优转移；</li>
<li>如果 $g_{j_0} \geq g_{j_1}$，那么我们只需要将 $g_{j_1}$ 保留下来即可。这是因为当 $j_0$ 还满足限制时，选择 $g_{j_1}$ 并不会更差，并且 $j_1$ 可以满足限制的时间（即随着 i 的递增）更久。</li>
</ul>
<p>因此，我们使用一个队列存储所有需要被保留的 $g_j$（存储下标 j 即可），从队首到队尾，j 的值单调递增，$g_j$ 的值也单调递增。在进行状态转移求解 $f_i$ 时：</p>
<ul>
<li>首先我们不断从队首弹出元素，直到队首的 j 是满足额外限制的；</li>
<li>使用队首的 j 进行转移，得到 $f_i$；</li>
<li>计算出 $g_i$，并不断从队尾弹出元素，直到队列为空或者队尾元素对应的 g 值严格小与 $g_i$；</li>
<li>将 $g_i$ 放入队列。</li>
<li>状态转移需要的时间为 O(1)。而对于单调队列的部分，每一个 $g_i$ 会被加入队列恰好一次，并且被从队列中弹出最多一次，因此均摊时间为 O(1)。这样一来，动态规划的时间复杂度降低为 O(n)。</li>
</ul>
<h4 id="代码-8">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">boxDelivering</span>(<span class="params">self, boxes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], portsCount: <span class="built_in">int</span>, maxBoxes: <span class="built_in">int</span>, maxWeight: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getArray</span>() -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(boxes)</span><br><span class="line">        p, w, neg, W = getArray(), getArray(), getArray(), getArray()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            p[i], w[i] = boxes[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                neg[i] = neg[i - <span class="number">1</span>] + (p[i - <span class="number">1</span>] != p[i])</span><br><span class="line">            W[i] = W[i - <span class="number">1</span>] + w[i]</span><br><span class="line">        </span><br><span class="line">        opt = deque([<span class="number">0</span>])</span><br><span class="line">        f, g = getArray(), getArray()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> i - opt[<span class="number">0</span>] &gt; maxBoxes <span class="keyword">or</span> W[i] - W[opt[<span class="number">0</span>]] &gt; maxWeight:</span><br><span class="line">                opt.popleft()</span><br><span class="line">            </span><br><span class="line">            f[i] = g[opt[<span class="number">0</span>]] + neg[i] + <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i != n:</span><br><span class="line">                g[i] = f[i] - neg[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">while</span> opt <span class="keyword">and</span> g[i] &lt;= g[opt[-<span class="number">1</span>]]:</span><br><span class="line">                    opt.pop()</span><br><span class="line">                opt.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-6">复杂度分析</h4>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组 boxes 的长度。</li>
<li>空间复杂度：O(n)，即为动态规划的数组 f 和 g，单调队列以及前缀和数组需要使用的空间。</li>
</ul>
<h4 id="作者-6">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/solutions/2005717/cong-cang-ku-dao-ma-tou-yun-shu-xiang-zi-4uya/">https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/solutions/2005717/cong-cang-ku-dao-ma-tou-yun-shu-xiang-zi-4uya/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-16</title>
    <url>/2022/05/16/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-16/</url>
    <content><![CDATA[<h2 id="问题描述-7">问题描述</h2>
<h3 id="题目：后继者">题目：后继者</h3>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。如果指定节点没有对应的“下一个”节点，则返回null。</p>
<h3 id="示例-7">示例</h3>
<ol>
<li>
<p>输入: root = [2,1,3], p = 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>输出: 2</p>
</li>
<li>
<p>输入: root = [5,3,6,2,4,null,null,1], p = 6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /   </span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输出: null</p>
</li>
</ol>
<h3 id="来源-7">来源</h3>
<p>力扣（LeetCode） 链接：<a href="https://leetcode.cn/problems/successor-lcci">https://leetcode.cn/problems/successor-lcci</a></p>
<h2 id="问题解答-7">问题解答</h2>
<h3 id="暴力法-2">暴力法</h3>
<h4 id="思想">思想</h4>
<p>先中序遍历树得到节点遍历顺序列表，再一一对比找出指定节点及其下一个节点。</p>
<h4 id="代码-9">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, root: TreeNode, p: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">rootnode</span>):</span><br><span class="line">            <span class="keyword">if</span> rootnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            getitem(rootnode.left)</span><br><span class="line">            result.append(rootnode)</span><br><span class="line">            getitem(rootnode.right)</span><br><span class="line">        getitem(root)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(result):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> p:</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(result) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> result[i+<span class="number">1</span>]</span><br><span class="line">        		<span class="keyword">else</span>:</span><br><span class="line">            		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="改进">改进</h4>
<p>因为只需要找出指定节点的下一个节点，所以可以用两个指针，一个指向当前节点的上一个节点，一个指向当前节点；若上一个节点是指定节点，则返回当前节点，否则返回null。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, root: TreeNode, p: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">global</span> last, now </span><br><span class="line">        last = <span class="literal">None</span></span><br><span class="line">        now = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">rootnode</span>):</span><br><span class="line">            <span class="keyword">global</span> last, now</span><br><span class="line">            <span class="keyword">if</span> rootnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            getitem(rootnode.left)</span><br><span class="line">            <span class="keyword">if</span> last <span class="keyword">is</span> p:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            last = now</span><br><span class="line">            now = rootnode  </span><br><span class="line">            getitem(rootnode.right)</span><br><span class="line">        getitem(root)</span><br><span class="line">        <span class="keyword">if</span> last <span class="keyword">is</span> p:</span><br><span class="line">            <span class="keyword">return</span> now</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="BST-特性-递归">BST 特性 + 递归</h2>
<h4 id="思路-2">思路</h4>
<p>利用 BST 的特性，我们可以根据当前节点 root 与 p 的值大小关系来确定搜索方向：</p>
<ul>
<li>若有<code>root.val &lt;= p.val</code>: 根据 BST 特性可知当前节点 root 及其左子树子节点均满足「值小于等于 p.val」，因此不可能是 p 点的后继，我们直接到 root 的右子树搜索 p 的后继（递归处理）；</li>
<li>若有 <code>root.val &gt; p.val </code>: 当第一次搜索到满足此条件的节点时，在以 root 为根节点的子树中「位于最左下方」的值为 p 的后继，但也有可能 root 没有左子树，因此 p 的后继要么在 root 的左子树中（若有），要么是 root 本身，此时我们可以直接到 root 的左子树搜索，若搜索结果为空返回 root，否则返回搜索结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, root: TreeNode, p: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= p.val: </span><br><span class="line">            <span class="keyword">return</span> self.inorderSuccessor(root.right, p)</span><br><span class="line">        ans = self.inorderSuccessor(root.left, p)</span><br><span class="line">        <span class="keyword">return</span> root <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="作者-7">作者</h4>
<p>AC_OIer，链接：<a href="https://leetcode.cn/problems/successor-lcci/solution/by-ac_oier-xib5/">https://leetcode.cn/problems/successor-lcci/solution/by-ac_oier-xib5/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-12-7</title>
    <url>/2022/12/07/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-12-7/</url>
    <content><![CDATA[<h2 id="问题描述-8">问题描述</h2>
<h3 id="题目：通过最少操作次数使数组的和相等">题目：通过最少操作次数使数组的和相等</h3>
<p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p>
<p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code>6</code>）。</p>
<p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p>
<h3 id="示例-8">示例</h3>
<h4 id="1、-5">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。</span><br><span class="line">- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。</span><br><span class="line">- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。</span><br><span class="line">- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。</span><br></pre></td></tr></table></figure>
<h4 id="2、-5">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6]</span><br><span class="line">输出：-1</span><br><span class="line">解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</span><br></pre></td></tr></table></figure>
<h4 id="3、-2">3、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [6,6], nums2 = [1]</span><br><span class="line">输出：3</span><br><span class="line">解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。</span><br><span class="line">- 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。</span><br><span class="line">- 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。</span><br><span class="line">- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。</span><br></pre></td></tr></table></figure>
<h3 id="提示-7">提示:</h3>
<ul>
<li>1 &lt;= nums1.length, nums2.length &lt;= $10^5$</li>
<li>1 &lt;= nums1[i], nums2[i] &lt;= 6</li>
</ul>
<h3 id="来源-8">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/description/">https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/description/</a></p>
<h2 id="问题解答-8">问题解答</h2>
<h4 id="贪心思想">贪心思想</h4>
<p>首先，我们可以很简单得出最后相同和的范围，即num1和num2各自最小值和最大值之间的交集，如果没有交集那么也就不存在这样的操作，返回-1。而num1和num2的最小值和最大值又分别等于它们长度的1倍和6倍，即最小时全为1，最大时全为6。</p>
<p>上面得到了最后相同和的范围，那么下面就可以遍历该范围内的所有数，计算当和为该数时的操作数，最后返回最小值。在这个过程中，最主要的就是解决怎么计算固定和时的操作数，下面为计算思想。</p>
<p>设最后的和为sum，当前两个数组的和为sum1、sum2，那么它们之间的差值为$diff1=sum-sum1$和$diff2=sum-sum2$，这里不缺乏一般性，可以认为$diff1&gt;0$、$diff2&lt;0$。那么变化操作就是提高num1里面的数，降低num2里面的数，而num1和num2由于每个数都有范围，那么每个数对diff的贡献也都有上限，题目要求是最小操作数，那么根据贪心思想，每次先对贡献大的数进行操作，所以问题就转变为固定最终和，求num1和num2的操作数，即用贪心算法求$diff=5x_1+4x_2+3x_3+2x_4+x_5$中$x_1+x_2+x_3+x_4+x_5$的最小值，同时$x_1、x_2、x_3、x_4、x_5$均不大于相应数字的个数。</p>
<h4 id="代码-10">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        times_nums1_1 = [<span class="number">0</span>] * <span class="number">6</span> </span><br><span class="line">        times_nums2_1 = [<span class="number">0</span>] * <span class="number">6</span> </span><br><span class="line">        times_nums1_2 = [<span class="number">0</span>] * <span class="number">6</span></span><br><span class="line">        times_nums2_2 = [<span class="number">0</span>] * <span class="number">6</span></span><br><span class="line">        length1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        length2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        sum1 = <span class="built_in">sum</span>(nums1)</span><br><span class="line">        sum2 = <span class="built_in">sum</span>(nums2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            times_nums1_1[i-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            times_nums1_2[<span class="number">6</span>-i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            times_nums2_1[i-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            times_nums2_2[<span class="number">6</span>-i] += <span class="number">1</span></span><br><span class="line">        times_nums1_1 = <span class="built_in">list</span>(accumulate(times_nums1_1))<span class="comment"># 依次为可贡献5、4、3、2、1、0的数字总数</span></span><br><span class="line">        times_nums1_2 = <span class="built_in">list</span>(accumulate(times_nums1_2))<span class="comment"># 依次为可贡献-5、-4、-3、-2、-1、0的数字总数</span></span><br><span class="line">        times_nums2_1 = <span class="built_in">list</span>(accumulate(times_nums2_1))</span><br><span class="line">        times_nums2_2 = <span class="built_in">list</span>(accumulate(times_nums2_2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">sum_num</span>):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> sum_num &gt; sum1:</span><br><span class="line">                dis = sum_num - sum1</span><br><span class="line">                x1 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">5</span>), times_nums1_1[<span class="number">0</span>])</span><br><span class="line">                dis -= x1*<span class="number">5</span></span><br><span class="line">                x2 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">4</span>), times_nums1_1[<span class="number">1</span>]-x1)</span><br><span class="line">                dis -= x2*<span class="number">4</span></span><br><span class="line">                x3 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">3</span>), times_nums1_1[<span class="number">2</span>]-x1-x2)</span><br><span class="line">                dis -= x3*<span class="number">3</span></span><br><span class="line">                x4 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">2</span>), times_nums1_1[<span class="number">3</span>]-x1-x2-x3)</span><br><span class="line">                dis -= x4*<span class="number">2</span></span><br><span class="line">                x5 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis), times_nums1_1[<span class="number">4</span>]-x1-x2-x3-x4)</span><br><span class="line">                res += (x1 + x2 + x3 + x4 + x5) </span><br><span class="line">            <span class="keyword">elif</span> sum_num &lt; sum1:</span><br><span class="line">                dis = sum1 - sum_num </span><br><span class="line">                x1 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">5</span>), times_nums1_2[<span class="number">0</span>])</span><br><span class="line">                dis -= x1*<span class="number">5</span></span><br><span class="line">                x2 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">4</span>), times_nums1_2[<span class="number">1</span>]-x1)</span><br><span class="line">                dis -= x2*<span class="number">4</span></span><br><span class="line">                x3 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">3</span>), times_nums1_2[<span class="number">2</span>]-x1-x2)</span><br><span class="line">                dis -= x3*<span class="number">3</span></span><br><span class="line">                x4 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">2</span>), times_nums1_2[<span class="number">3</span>]-x1-x2-x3)</span><br><span class="line">                dis -= x4*<span class="number">2</span></span><br><span class="line">                x5 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis), times_nums1_2[<span class="number">4</span>]-x1-x2-x3-x4)</span><br><span class="line">                res += (x1 + x2 + x3 + x4 + x5) </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sum_num &gt; sum2:</span><br><span class="line">                dis = sum_num - sum2</span><br><span class="line">                x1 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">5</span>), times_nums2_1[<span class="number">0</span>])</span><br><span class="line">                dis -= x1*<span class="number">5</span></span><br><span class="line">                x2 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">4</span>), times_nums2_1[<span class="number">1</span>]-x1)</span><br><span class="line">                dis -= x2*<span class="number">4</span></span><br><span class="line">                x3 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">3</span>), times_nums2_1[<span class="number">2</span>]-x1-x2)</span><br><span class="line">                dis -= x3*<span class="number">3</span></span><br><span class="line">                x4 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">2</span>), times_nums2_1[<span class="number">3</span>]-x1-x2-x3)</span><br><span class="line">                dis -= x4*<span class="number">2</span></span><br><span class="line">                x5 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis), times_nums2_1[<span class="number">4</span>]-x1-x2-x3-x4)</span><br><span class="line">                res += (x1 + x2 + x3 + x4 + x5) </span><br><span class="line">            <span class="keyword">elif</span> sum_num &lt; sum2:</span><br><span class="line">                dis = sum2 - sum_num </span><br><span class="line">                x1 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">5</span>), times_nums2_2[<span class="number">0</span>])</span><br><span class="line">                dis -= x1*<span class="number">5</span></span><br><span class="line">                x2 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">4</span>), times_nums2_2[<span class="number">1</span>]-x1)</span><br><span class="line">                dis -= x2*<span class="number">4</span></span><br><span class="line">                x3 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">3</span>), times_nums2_2[<span class="number">2</span>]-x1-x2)</span><br><span class="line">                dis -= x3*<span class="number">3</span></span><br><span class="line">                x4 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis/<span class="number">2</span>), times_nums2_2[<span class="number">3</span>]-x1-x2-x3)</span><br><span class="line">                dis -= x4*<span class="number">2</span></span><br><span class="line">                x5 = <span class="built_in">min</span>(<span class="built_in">int</span>(dis), times_nums2_2[<span class="number">4</span>]-x1-x2-x3-x4)</span><br><span class="line">                res += (x1 + x2 + x3 + x4 + x5) </span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        a, b = length1, <span class="number">6</span>*length1</span><br><span class="line">        c, d = length2, <span class="number">6</span>*length2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(a, c) &lt;= b <span class="keyword">and</span> <span class="built_in">min</span>(b, d) &gt;= a:</span><br><span class="line">            result = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> sum_eq <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(a, c), <span class="built_in">min</span>(b, d)+<span class="number">1</span>):</span><br><span class="line">                temp = calc(sum_eq)</span><br><span class="line">                <span class="keyword">if</span> result == -<span class="number">1</span>:</span><br><span class="line">                    result = temp</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> result &gt; temp:</span><br><span class="line">                        result = temp</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-7">复杂度分析</h4>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组num1和num2的最大长度。</li>
<li>空间复杂度：O(1)，固定长度的列表。</li>
</ul>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-18</title>
    <url>/2022/05/18/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-18/</url>
    <content><![CDATA[<h2 id="问题描述-9">问题描述</h2>
<h3 id="题目：乘法表中第k小的数">题目：乘法表中第k小的数</h3>
<p>给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。</p>
<h3 id="示例-9">示例</h3>
<ol>
<li>
<p>输入: m = 3, n = 3, k = 5输出: 3解释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乘法表:</span><br><span class="line">    1  2  3</span><br><span class="line"></span><br><span class="line">    2  4  6</span><br><span class="line"></span><br><span class="line">    3  6  9</span><br><span class="line">第5小的数字是 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输入: m = 2, n = 3, k = 6</p>
<p>输出: 6</p>
<p>解释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乘法表:</span><br><span class="line">    1	2	3</span><br><span class="line">    2	4	6</span><br><span class="line"></span><br><span class="line">第6小的数字是 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意">注意</h3>
<ul>
<li>m 和 n 的范围在  [1, 30000] 之间。</li>
<li>k 的范围在 [1, m * n] 之间。</li>
</ul>
<h3 id="来源-9">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table">https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table</a></p>
<h2 id="问题解答-9">问题解答</h2>
<h3 id="二分法">二分法</h3>
<h4 id="思想-2">思想</h4>
<p>首先，给了一个 m∗n 乘法表的二维矩阵，我们其实能很快地找到矩阵中有多少个数字小于等于 x。</p>
<p>由于第 i 行的数字分别是 $i, 2i, 3i,…$，因此这一行小于等于 x 的数字个数为 $\min(\frac{x}{i},n)$。因为$\frac{x}{i}$ 得到了 x 是 i 的多少倍，表示在第 i 行最多有多少数字小于等于 x。同时矩阵最多有 n 列，因此需要取个最小值。</p>
<p>那么矩阵中小于等于 x 的数字个数等于各行的累加，即$ \sum_{i=1}^m \min(\frac{x}{i}, n)$个。</p>
<p>所以该题就是希望得到$ \sum_{i=1}^m \min(\frac{x}{i}, n) = k$时的 x 的最小值，之所以最小是因为乘法表中数字是离散，小于 x 的个数可能和小于 x+1的个数一样。得到整个 x 的方法就是二分查找。</p>
<p>注意一点：找出最小的 x 在代码中的体现就是当小于 x 的个数等于k时，应该将中间值 mid 赋给上限。</p>
<h4 id="代码-11">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthNumber</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_min = <span class="number">1</span></span><br><span class="line">        num_max = n*m</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getnums</span>(<span class="params">num</span>):</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>): </span><br><span class="line">                    result += n <span class="keyword">if</span> i*n &lt;= num <span class="keyword">else</span> <span class="built_in">int</span>(num/i)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            mid = <span class="built_in">int</span>((num_max + num_min)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> getnums(mid) &lt; k:</span><br><span class="line">                num_min = mid </span><br><span class="line">            <span class="keyword">elif</span> getnums(mid) &gt;= k:</span><br><span class="line">                num_max = mid </span><br><span class="line">    </span><br><span class="line">            <span class="built_in">print</span>(num_max, num_min)</span><br><span class="line">            <span class="keyword">if</span> (num_max == num_min):</span><br><span class="line">                <span class="keyword">return</span> num_min</span><br><span class="line">            <span class="keyword">elif</span> (num_min + <span class="number">1</span> == num_max):</span><br><span class="line">                <span class="keyword">return</span> num_max</span><br></pre></td></tr></table></figure>
<h4 id="作者-8">作者</h4>
<p>fuxuemingzhu，链接：<a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution/by-fuxuemingzhu-8eq4/">https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution/by-fuxuemingzhu-8eq4/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-19</title>
    <url>/2022/05/19/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-19/</url>
    <content><![CDATA[<h2 id="问题描述-10">问题描述</h2>
<h3 id="题目：最少移动次数使数组元素相等-II">题目：最少移动次数使数组元素相等 II</h3>
<p>给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。</p>
<h3 id="示例-10">示例</h3>
<ol>
<li>
<pre><code>输入：nums = [1,2,3]
输出：2
解释：
只需要两步操作（每步操作指南使一个元素加 1 或减 1）：
[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   输入：nums = [1,10,2,9]</span><br><span class="line">   输出：16</span><br></pre></td></tr></table></figure>




</code></pre>
</li>
</ol>
<h3 id="注意-2">注意</h3>
<ul>
<li>$n == nums.length$</li>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li>
</ul>
<h3 id="来源-10">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/</a></p>
<h2 id="问题解答-10">问题解答</h2>
<h3 id="暴力法-3">暴力法</h3>
<h4 id="思想-3">思想</h4>
<p>首先，最终相同的值不可能在 nums 的最小值和最大值的范围之外，所以遍历所有数，然后返回与其他数距离之和最小的那个。</p>
<h4 id="代码-12">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoves2</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_min = <span class="built_in">min</span>(nums)</span><br><span class="line">        num_max = <span class="built_in">max</span>(nums)</span><br><span class="line">    </span><br><span class="line">        times_min = np.inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_min, num_max+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">                temp += np.<span class="built_in">abs</span>(j - i)</span><br><span class="line">            <span class="keyword">if</span> temp &lt; times_min:</span><br><span class="line">                times_min = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(times_min)</span><br></pre></td></tr></table></figure>
<h3 id="规律法">规律法</h3>
<h4 id="思想-4">思想</h4>
<p>首先，最终相同的值不可能在 nums 的最小值和最大值的范围之外，所以结果在 [nums_min, nums_max] 之内。</p>
<p>然后，对于该范围任意一个数，它距离 nums_min 、 nums_max 的距离之和一定是等于 nums_max - nums_min。</p>
<p>既然这样，那么最小值和最大值可以从整个列表 nums 除去，那么新的 nums 又根据这种性质删除最大值和最小值。</p>
<p>最后，该问题就转化成求列表的中位数。列表长度为奇数时等于其中位数，为偶数时等于两个值中任意的那个。</p>
<h4 id="代码-13">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoves2</span>(<span class="params">self, nums</span>):</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([nums[-(i+<span class="number">1</span>)] - nums[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) // <span class="number">2</span>)])</span><br></pre></td></tr></table></figure>
<h4 id="作者-9">作者</h4>
<p>fuxuemingzhu，链接：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/by-fuxuemingzhu-13z3/">https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/by-fuxuemingzhu-13z3/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-23</title>
    <url>/2022/05/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-23/</url>
    <content><![CDATA[<h2 id="问题描述-11">问题描述</h2>
<h3 id="题目：为高尔夫比赛砍树">题目：为高尔夫比赛砍树</h3>
<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：</p>
<ul>
<li>0 表示障碍，无法触碰</li>
<li>1 表示地面，可以行走</li>
<li>比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度</li>
</ul>
<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。你需要<strong>按照树的高度从低向高砍掉所有的树</strong>，每砍过一颗树，该单元格的值变为 1（即变为地面）。</p>
<p>你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的<strong>最小</strong>步数。 如果你无法砍完所有的树，返回 -1 。</p>
<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>
<h3 id="示例-11">示例</h3>
<p>1、<img src="/2022/05/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-23/1.png" alt="image-20220523190046063"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[1,2,3],[0,0,4],[7,6,5]]</span><br><span class="line">输出：6</span><br><span class="line">解释：沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</span><br></pre></td></tr></table></figure>
<p>2、<img src="/2022/05/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-23/2.png" alt="image-20220523190117932"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[1,2,3],[0,0,0],[7,6,5]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。</span><br></pre></td></tr></table></figure>
<p>3、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[2,3,4],[0,0,5],[8,7,6]]</span><br><span class="line">输出：6</span><br><span class="line">解释：可以按与示例 1 相同的路径来砍掉所有的树。</span><br><span class="line">(0,0) 位置的树，可以直接砍去，不用算步数。</span><br></pre></td></tr></table></figure>
<h3 id="来源-11">来源</h3>
<p>力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event">https://leetcode.cn/problems/cut-off-trees-for-golf-event</a></p>
<h2 id="问题解答-11">问题解答</h2>
<h3 id="BFS">BFS</h3>
<h4 id="思路-3">思路</h4>
<p>首先对矩阵中的树按照树的高度进行排序，依次求出相邻的树之间的最短距离。记录在某个时间点已经添加到队列中的节点，这些节点已被处理或在等待处理的队列中。对于下一个要处理的每个节点，查看他们的四个方向上相邻的点，如果相邻的点没有被遍历过且不是障碍，将其加入到队列中，直到找到终点为止，返回当前的步数即可。最终返回所有的步数之和即为最终结果。</p>
<h4 id="代码-14">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutOffTree</span>(<span class="params">self, forest: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx: <span class="built_in">int</span>, sy: <span class="built_in">int</span>, tx: <span class="built_in">int</span>, ty: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            m, n = <span class="built_in">len</span>(forest), <span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">            q = deque([(<span class="number">0</span>, sx, sy)])</span><br><span class="line">            vis = &#123;(sx, sy)&#125;</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                d, x, y = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> x == tx <span class="keyword">and</span> y == ty:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> ((x - <span class="number">1</span>, y), (x + <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; n <span class="keyword">and</span> forest[nx][ny] <span class="keyword">and</span> (nx, ny) <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                        vis.add((nx, ny))</span><br><span class="line">                        q.append((d + <span class="number">1</span>, nx, ny))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        trees = <span class="built_in">sorted</span>((h, i, j) <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(forest) <span class="keyword">for</span> j, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(row) <span class="keyword">if</span> h &gt; <span class="number">1</span>)</span><br><span class="line">        ans = preI = preJ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, i, j <span class="keyword">in</span> trees:</span><br><span class="line">            d = bfs(preI, preJ, i, j)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            ans += d</span><br><span class="line">            preI, preJ = i, j</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="补充">补充</h4>
<p>这里求两点之间的最短距离可以选择很多方法，如A*搜索、Dijkstra算法等。</p>
<h3 id="AStar-算法-并查集预处理无解">AStar 算法 + 并查集预处理无解</h3>
<h4 id="思路-4">思路</h4>
<p>AStar 算法使用到了优先队列（堆）来进行启发式搜索，而对于一些最佳路径方向与两点相对位置相反（例如 TTT 在 SSS 的右边，但由于存在障碍，最短路径需要先从左边绕一圈才能到 TTT），AStar 反而会因为优先队列（堆）而多一个 log⁡ 的复杂度。</p>
<p>因此一个可行的优化是，先提前处理无解的情况，常见的做法是在预处理过程中运用并查集来维护连通性。这种对于不影响复杂度上界的预处理相比后续可能出现的大量无效搜索（最终无解）的计算量而言，是有益的。</p>
<h4 id="代码-15">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutOffTree</span>(<span class="params">self, forest: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(forest)</span><br><span class="line">        n = <span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">        p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m * n)]</span><br><span class="line">        tempDirs = [[<span class="number">0</span>, -<span class="number">1</span>],[-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        visited_list = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a, b</span>):</span><br><span class="line">            p[find(a)] = p[find(b)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> p[x] != x:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getIdx</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">return</span> i * n + j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">a ,b</span>):</span><br><span class="line">            <span class="keyword">return</span> find(a) == find(b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y, nx, ny</span>):</span><br><span class="line">            <span class="keyword">return</span> np.<span class="built_in">abs</span>(x - nx) + np.<span class="built_in">abs</span>(y - ny)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">astar</span>(<span class="params">x, y, nx, ny</span>):</span><br><span class="line">            <span class="keyword">global</span> g</span><br><span class="line">            <span class="keyword">if</span> x == nx <span class="keyword">and</span> y == ny:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">            dirs = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">            q = deque([(f(x, y, nx, ny), x, y)])</span><br><span class="line">            <span class="built_in">map</span>.update(&#123;getIdx(x, y):<span class="number">0</span>&#125;)</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                _, x, y = q.popleft()</span><br><span class="line">                step = <span class="built_in">map</span>.get(getIdx(x, y))</span><br><span class="line">                <span class="keyword">for</span> di <span class="keyword">in</span> dirs:</span><br><span class="line">                    tx, ty = x + di[<span class="number">0</span>], y + di[<span class="number">1</span>]</span><br><span class="line">                    nidx = getIdx(tx, ty)</span><br><span class="line">                    <span class="keyword">if</span> tx &lt; <span class="number">0</span> <span class="keyword">or</span> tx &gt;= m <span class="keyword">or</span> ty &lt; <span class="number">0</span> <span class="keyword">or</span> ty &gt;= n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> forest[tx][ty] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> tx == nx <span class="keyword">and</span> ty == ny:</span><br><span class="line">                        <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> nidx <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">map</span>.keys() <span class="keyword">or</span> <span class="built_in">map</span>.get(nidx) &gt; step + <span class="number">1</span>:</span><br><span class="line">                        q.append((step+<span class="number">1</span>+f(tx, ty, nx, ny), tx, ty))</span><br><span class="line">                        <span class="built_in">map</span>.update(&#123;nidx:step+<span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理过程中，同时使用「并查集」维护连通性</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> forest[i][j] &gt; <span class="number">1</span>:</span><br><span class="line">                    visited_list.append((forest[i][j], i, j))</span><br><span class="line">                <span class="keyword">if</span> forest[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> tempDirs:</span><br><span class="line">                    nx, ny = i + dx, j + dy</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; m) <span class="keyword">and</span> (ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; n) <span class="keyword">and</span> forest[nx][ny] != <span class="number">0</span>:</span><br><span class="line">                        union(getIdx(i, j), getIdx(nx, ny))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 若不满足所有树点均与 (0,0)，提前返回无解</span></span><br><span class="line">        <span class="keyword">for</span> _, x, y <span class="keyword">in</span> visited_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> query(getIdx(<span class="number">0</span>, <span class="number">0</span>), getIdx(x, y)):</span><br><span class="line">                <span class="built_in">print</span>(p)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ASTAR</span></span><br><span class="line">        visited_list = <span class="built_in">sorted</span>(visited_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        x, y, ans = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, nx, ny <span class="keyword">in</span> visited_list:</span><br><span class="line">            d = astar(x, y, nx, ny)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">0</span>:</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            ans += d</span><br><span class="line">            x, y = nx, ny</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="作者-10">作者</h4>
<p>AC_OIer，链接：<a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution/by-ac_oier-ksth/">https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution/by-ac_oier-ksth/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-9</title>
    <url>/2022/05/09/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-9/</url>
    <content><![CDATA[<h2 id="问题介绍">问题介绍</h2>
<h3 id="题目：增减字符串匹配">题目：增减字符串匹配</h3>
<p>由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:</p>
<p>​    如果 <code>perm[i] &lt; perm[i + 1] </code>，那么<code> s[i] == 'I'</code></p>
<p>​    如果 <code>perm[i] &gt; perm[i + 1]</code> ，那么<code>s[i] == 'D'</code></p>
<p>给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。</p>
<h3 id="示例-12">示例</h3>
<ol>
<li>输入：<code>s = &quot;IDID&quot;</code></li>
</ol>
<p>输出：<code>[0,4,1,3,2]</code></p>
<ol start="2">
<li>
<p>输入：<code>s = &quot;III&quot;</code></p>
<p>输出：<code>[0,1,2,3]</code></p>
</li>
<li>
<p>输入：<code>s = &quot;DDI&quot;</code></p>
</li>
</ol>
<p>输出：<code>[3,2,0,1]</code></p>
<h3 id="提示-8">提示</h3>
<ol>
<li>$ 1 \leq s.length \leq 10^5 $</li>
<li>s 只包含字符 “I” 或 “D”</li>
</ol>
<h3 id="来源-12">来源</h3>
<p>力扣（LeetCode）链接：<a href="https://leetcode.cn/problems/di-string-match">https://leetcode.cn/problems/di-string-match</a></p>
<h2 id="问题解答-12">问题解答</h2>
<h3 id="思路-5">思路</h3>
<p>可以发现“III”的输出是增序，“DDD”是降序。所以某一位置出现I可以表示该位置为未分配的数字中的最小值，D则可以表示该位置为未分配的数字中的最大值。按照这样的想法，使用双指针，一个指向最小值，一个指向最大值，按照字符串s的顺序添加进列表即可。</p>
<h3 id="代码-16">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diStringMatch</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        s = s + <span class="string">&#x27;I&#x27;</span> <span class="comment"># 因为字符串长度为n，而实际有n+1个数，所以可以加一个I或D使得字符串一个字符对应一个数</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = length</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> s[n] == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                result.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(j)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-30</title>
    <url>/2022/05/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-30/</url>
    <content><![CDATA[<h2 id="问题1描述">问题1描述</h2>
<h3 id="题目：掉落的方块">题目：掉落的方块</h3>
<p>在二维平面上的 x 轴上，放置着一些方块。</p>
<p>给你一个二维整数数组 positions ，其中 positions[i] = [lefti, sideLengthi] 表示：第 i 个方块边长为 sideLengthi ，其左侧边与 x 轴上坐标点 lefti 对齐。</p>
<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 另一个正方形的顶边 或者是 x 轴上 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
<p>在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。</p>
<p>返回一个整数数组 ans ，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。</p>
<h3 id="示例-13">示例</h3>
<ol>
<li>
<p>输入：positions = [[1,2],[2,3],[6,1]]</p>
<p>输出：[2,5,5]</p>
<p><img src="/2022/05/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-30/1.png" alt="image-20220530181242124"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line"></span><br><span class="line">第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。</span><br><span class="line"></span><br><span class="line">第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。</span><br><span class="line"></span><br><span class="line">第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。</span><br><span class="line"></span><br><span class="line">因此，返回 [2, 5, 5] 作为答案。</span><br></pre></td></tr></table></figure>
<p>2.输入：positions = [[100,100],[200,100]]</p>
<p>输出：[100,100]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line"></span><br><span class="line">第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。</span><br><span class="line"></span><br><span class="line">第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。</span><br><span class="line"></span><br><span class="line">因此，返回 [100, 100] 作为答案。</span><br><span class="line"></span><br><span class="line">注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。</span><br></pre></td></tr></table></figure>
<h3 id="提示-9">提示</h3>
<p>$ 1 &lt;= positions.length &lt;= 1000$</p>
<p>​    $1 &lt;= lefti &lt;= 10^8$</p>
<p>$ 1 &lt;= sideLengthi &lt;= 10^6$</p>
<h3 id="来源-13">来源</h3>
<p>力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/falling-squares">https://leetcode.cn/problems/falling-squares</a></p>
<h3 id="问题解答-13">问题解答</h3>
<h4 id="暴力枚举">暴力枚举</h4>
<p>用数组 heights 记录各个方块掉落后的高度。对于第 i 个掉落的方块，如果它的底部区间与第 j 个掉落的方块有重叠，那么它掉落后的高度至少为 heights[j]+sizei，其中 j&lt;i且 sizei为第 i 个掉落的方块的边长。因此对于第 i 个掉落的方块，heights[i] 的初始值为 sizei，我们暴力枚举所有之前已经掉落的方块，如果两者的底部区间有重叠，那么更新heights[i] = max⁡(heights[i],heights[j]+sizei)。</p>
<p>因为题目要求返回一个所有已经落稳的方块的最大堆叠高度列表，我们从 i=1 开始，更新 heights[i]=max⁡(heights[i],heights[i−1])，然后返回 heights 即可。</p>
<h5 id="代码-17">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fallingSquares</span>(<span class="params">self, positions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(positions)</span><br><span class="line">        heights = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i, (left1, side1) <span class="keyword">in</span> <span class="built_in">enumerate</span>(positions):</span><br><span class="line">            right1 = left1 + side1 - <span class="number">1</span></span><br><span class="line">            heights[i] = side1</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                left2, right2 = positions[j][<span class="number">0</span>], positions[j][<span class="number">0</span>] + positions[j][<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> right1 &gt;= left2 <span class="keyword">and</span> right2 &gt;= left1:</span><br><span class="line">                    heights[i] = <span class="built_in">max</span>(heights[i], heights[j] + side1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            heights[i] = <span class="built_in">max</span>(heights[i], heights[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> heights</span><br></pre></td></tr></table></figure>
<h5 id="作者-11">作者</h5>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/falling-squares/solution/diao-luo-de-fang-kuai-by-leetcode-soluti-2dmw/">https://leetcode.cn/problems/falling-squares/solution/diao-luo-de-fang-kuai-by-leetcode-soluti-2dmw/</a></p>
<h2 id="问题2描述">问题2描述</h2>
<h3 id="题目：从根到叶的二进制数之和">题目：从根到叶的二进制数之和</h3>
<p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p>
<h3 id="示例-14">示例</h3>
<p>输入：root = [1,0,1,0,1,0,1]<br>
输出：22</p>
<p><img src="/2022/05/30/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-30/2.png" alt="image-20220530182147285"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</span><br></pre></td></tr></table></figure>
<h3 id="提示-10">提示</h3>
<ul>
<li>树中的节点数在 <code>[1, 1000]</code> 范围内</li>
<li><code>Node.val</code> 仅为 <code>0</code> 或 <code>1</code></li>
</ul>
<h3 id="来源-14">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers">https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers</a></p>
<h3 id="问题解答-14">问题解答</h3>
<h4 id="直接遍历">直接遍历</h4>
<p>直接对二叉树进行遍历，唯一需要做的就是在遍历一个节点时，需要更改节点的值val，其值为如果它为叶节点时，它到根节点路径对应的二进制数的值，node.val = node.val + num*2， num为父节点的值。最后将所有叶节点的节点值加起来即可。</p>
<h4 id="代码-18">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRootToLeaf</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        leaflist = <span class="built_in">list</span>()</span><br><span class="line">        visiting = deque([root])</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">node, num</span>):</span><br><span class="line">            node.val = node.val + num*<span class="number">2</span></span><br><span class="line">            visiting.append(node)</span><br><span class="line">        <span class="keyword">while</span> visiting:</span><br><span class="line">            temp = visiting.popleft()</span><br><span class="line">            val = temp.val</span><br><span class="line">            <span class="keyword">if</span> (temp.right <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">and</span> (temp.left <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                leaflist.append(temp)</span><br><span class="line">            <span class="keyword">elif</span> temp.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                add(temp.left, val)</span><br><span class="line">            <span class="keyword">elif</span> temp.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                add(temp.right, val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                add(temp.left, val)</span><br><span class="line">                add(temp.right, val)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> leaflist:</span><br><span class="line">            <span class="built_in">sum</span> += node.val</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-16</title>
    <url>/2022/06/16/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-16/</url>
    <content><![CDATA[<h2 id="问题描述-12">问题描述</h2>
<h3 id="题目：数组中的-k-diff-数对">题目：数组中的 k-diff 数对</h3>
<p>给你一个整数数组 nums 和一个整数 k，请你在数组中找出 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。k-diff 数对定义为一个整数对 (nums[i], nums[j]) ，并满足下述全部条件：</p>
<ul>
<li>
<p>0 &lt;= i, j &lt; nums.length</p>
</li>
<li>
<p>i != j</p>
</li>
<li>
<p>nums[i] - nums[j] == k</p>
<p>注意，|val| 表示 val 的绝对值。</p>
</li>
</ul>
<h3 id="示例-15">示例</h3>
<ol>
<li></li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3, 1, 4, 1, 5], k = 2</span><br><span class="line"></span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3, 4, 5], k = 1</span><br><span class="line"></span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li></li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 3, 1, 5, 4], k = 0</span><br><span class="line"></span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">解释：数组中只有一个 0-diff 数对，(1, 1) 。</span><br></pre></td></tr></table></figure>
<h3 id="提示-11">提示</h3>
<ul>
<li>1 &lt;= nums.length &lt;= $10^4$</li>
<li>$-10^7$ &lt;= nums[i] &lt;= $10^7$</li>
<li>0 &lt;= k &lt;= $10^7$</li>
</ul>
<h3 id="来源-15">来源</h3>
<p>力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/k-diff-pairs-in-an-array">https://leetcode.cn/problems/k-diff-pairs-in-an-array</a></p>
<h2 id="问题解答-15">问题解答</h2>
<h3 id="双指针法">双指针法</h3>
<p>对于乱序的列表进行处理，可能只能暴力穷举，但如果是排好序的列表，如从高到低排好序，位置i和位置j（j &gt; i）的差小于 k ，那么 i 与 j 之间的数都不会间隔 k ， 等于 k 的数只会在 j 的后面（固定 i ），如果大于 k ，那么等于 k 的数就会在 i 的前面（固定 j ）。如果等于 k ，那么这就是一对满足条件的数对。移动 i ，那么就可以找到所有满足条件的数对。</p>
<h3 id="代码-19">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPairs</span>(<span class="params">self, nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        result = <span class="built_in">set</span>() <span class="comment"># 这样避免重复数对</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[i] - nums[j] &gt; k:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= j :</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] - nums[j] &lt; k:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.add((nums[j],nums[i]))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= j :</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(result) </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-1</title>
    <url>/2022/06/01/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-1/</url>
    <content><![CDATA[<h2 id="问题描述-13">问题描述</h2>
<h3 id="题目：外星文字典">题目：外星文字典</h3>
<p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>
<p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经按这门新语言的字母顺序进行了排序 。</p>
<p>请你根据该词典还原出此语言中已知的字母顺序，并按字母递增顺序排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种顺序即可。</p>
<p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p>
<ul>
<li>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。</li>
<li>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</li>
</ul>
<h3 id="示例-16">示例</h3>
<ol>
<li>
<p>输入：words = [“wrt”,“wrf”,“er”,“ett”,“rftt”]<br>
输出：“wertf”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;wrt&#x27; &lt; &#x27;wrf&#x27;  --&gt;  &#x27;t&#x27; &lt; &#x27;f&#x27;</span><br><span class="line">&#x27;wrf&#x27; &lt; &#x27;er&#x27;   --&gt;  &#x27;w&#x27; &lt; &#x27;e&#x27;</span><br><span class="line">&#x27;er&#x27;  &lt; &#x27;ett&#x27;  --&gt;  &#x27;r&#x27; &lt; &#x27;t&#x27;</span><br><span class="line">&#x27;ett&#x27; &lt; &#x27;rftt&#x27; --&gt;  &#x27;e&#x27; &lt; &#x27;r&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输入：words = [“z”,“x”]<br>
输出：“zx”</p>
</li>
<li>
<p>输入：words = [“z”,“x”,“z”]<br>
输出：“”<br>
解释：不存在合法字母顺序，因此返回 “” 。</p>
</li>
</ol>
<h3 id="提示-12">提示</h3>
<ul>
<li>1 &lt;= words.length &lt;= 100</li>
<li>1 &lt;= words[i].length &lt;= 100</li>
<li>words[i] 仅由小写英文字母组成</li>
</ul>
<h3 id="来源-16">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/Jf1JuT">https://leetcode.cn/problems/Jf1JuT</a></p>
<h2 id="问题解答-16">问题解答</h2>
<h3 id="拓扑排序-深度优先搜索">拓扑排序 + 深度优先搜索</h3>
<p>这道题是拓扑排序问题。外星文字典中的字母和字母顺序可以看成有向图，字典顺序即为所有字母的一种排列，满足每一条有向边的起点字母和终点字母的顺序都和这两个字母在排列中的顺序相同，该排列即为有向图的拓扑排序。</p>
<p>只有当有向图中无环时，才有拓扑排序，且拓扑排序可能不止一种。如果有向图中有环，则环内的字母不存在符合要求的排列，因此没有拓扑排序。</p>
<p>使用拓扑排序求解时，将外星文字典中的每个字母看成一个节点，将字母之间的顺序关系看成有向边。对于外星文字典中的两个相邻单词，同时从左到右遍历，当遇到第一个不相同的字母时，该位置的两个字母之间即存在顺序关系。</p>
<p>以下两种情况不存在合法字母顺序：</p>
<ul>
<li>字母之间的顺序关系存在由至少 2个字母组成的环，例如 words=[“a”, “b”, “a”]</li>
<li>相邻两个单词满足后面的单词是前面的单词的前缀，且后面的单词的长度小于前面的单词的长度，例如 words=[“ab”, 'a&quot;]。</li>
</ul>
<p>其余情况下都存在合法字母顺序，可以使用拓扑排序得到字典顺序。</p>
<p>拓扑排序可以使用深度优先搜索或广度优先搜索实现，以下介绍拓扑排序 + 深度优先搜索方法。</p>
<p>使用深度优先搜索实现拓扑排序的总体思想是：对于一个特定节点，如果该节点的所有相邻节点都已经搜索完成，则该节点也会变成已经搜索完成的节点，在拓扑排序中，该节点位于其所有相邻节点的前面。一个节点的相邻节点指的是从该节点出发通过一条有向边可以到达的节点。</p>
<p>由于拓扑排序的顺序和搜索完成的顺序相反，因此需要使用一个栈存储所有已经搜索完成的节点。深度优先搜索的过程中需要维护每个节点的状态，每个节点的状态可能有三种情况：「未访问」、「访问中」和「已访问」。初始时，所有节点的状态都是「未访问」。</p>
<p>每一轮搜索时，任意选取一个「未访问」的节点u，从节点u开始深度优先搜索。将节点u的	状态更新为「访问中」，对于每个与节点u相邻的节点v，判断节点v的状态，执行如下操作：</p>
<ol>
<li>
<p>如果节点v的状态是「未访问」，则继续搜索节点v；</p>
</li>
<li>
<p>如果节点v的状态是「访问中」，则找到有向图中的环，因此不存在拓扑排序；</p>
</li>
<li>
<p>如果节点v的状态是「已访问」，则节点v已经搜索完成并入栈，节点u尚未入栈，因此节点u的拓扑顺序一定在节点v的前面，不需要执行任何操作。</p>
</li>
</ol>
<p>当节点u的所有相邻节点的状态都是「已访问」时，将节点u的状态更新为「已访问」，并将节点u入栈。</p>
<p>当所有节点都访问结束之后，如果没有找到有向图中的环，则存在拓扑排序，所有节点从栈顶到栈底的顺序即为拓扑排序。</p>
<p>实现方面，由于每个节点是一个字母，因此可以使用字符数组代替栈，当节点入栈时，在字符数组中按照从后往前的顺序依次填入每个字母。当所有节点都访问结束之后，将字符数组转成字符串，即为字典顺序。</p>
<h4 id="代码-20">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> pairwise</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">alienOrder</span>(<span class="params">self, words: <span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        g = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> words[<span class="number">0</span>]:</span><br><span class="line">            g[c] = []</span><br><span class="line">        <span class="keyword">for</span> s, t <span class="keyword">in</span> pairwise(words):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                g.setdefault(c, [])</span><br><span class="line">            <span class="keyword">for</span> u, v <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">                <span class="keyword">if</span> u != v:</span><br><span class="line">                    g[u].append(v)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t):</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        VISITING, VISITED = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        states = &#123;&#125;</span><br><span class="line">        order = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            states[u] = VISITING</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> g[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> states:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dfs(v):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> states[v] == VISITING:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            order.append(u)</span><br><span class="line">            states[u] = VISITED</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(order)) <span class="keyword">if</span> <span class="built_in">all</span>(dfs(u) <span class="keyword">for</span> u <span class="keyword">in</span> g <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> states) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="作者-12">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/Jf1JuT/solution/wai-xing-wen-zi-dian-by-leetcode-solutio-to66/">https://leetcode.cn/problems/Jf1JuT/solution/wai-xing-wen-zi-dian-by-leetcode-solutio-to66/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-27</title>
    <url>/2022/06/27/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-27/</url>
    <content><![CDATA[<h2 id="问题描述-14">问题描述</h2>
<h3 id="题目：最长特殊序列-II">题目：最长特殊序列 II</h3>
<p>给定字符串列表 strs ，返回其中 最长的特殊序列 。如果最长特殊序列不存在，返回 -1 。</p>
<p>特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。 s 的 子序列可以通过删去字符串 s 中的某些字符实现。例如，“abc” 是 “aebdc” 的子序列，因为您可以删除&quot;aebdc&quot;中的下划线字符来得到 “abc” 。“aebdc&quot;的子序列还包括&quot;aebdc”、 “aeb” 和 “” (空字符串)。</p>
<h3 id="示例-17">示例</h3>
<p>1、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;aba&quot;,&quot;cdc&quot;,&quot;eae&quot;]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;aaa&quot;,&quot;aaa&quot;,&quot;aa&quot;]</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<h3 id="提示-13">提示</h3>
<ul>
<li>2 &lt;= strs.length &lt;= 50</li>
<li>1 &lt;= strs[i].length &lt;= 10</li>
<li>strs[i] 只包含小写英文字母</li>
</ul>
<h3 id="来源-17">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii">https://leetcode.cn/problems/longest-uncommon-subsequence-ii</a></p>
<h2 id="问题解答-17">问题解答</h2>
<p>由题意可知，如果序列中字符串两两不同，那么最长的特殊序列一定是长度最大的，但由于存在相同的情况，所以为了尽快找到最长特殊序列，可以从字符串长度最大的开始，依次判断它是不是其他字符串的子串。</p>
<p>判断是不是子串的方法：双指针法。指针一 i 指向其他字符串的首位置，指针二 j 指向该字符串的首位置，两个位置的字符一样， i 和 j 都加 1 ，否则只有 i 加 1 ，最后如果在指针 i 超出范围前， j 的位置超过了最后一个位置，说明 j 指向的字符串是 i 指向字符串的子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLUSlength</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># str1是不是str2的子串</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isslen</span>(<span class="params">str1, str2</span>):</span><br><span class="line">            <span class="comment"># str1长度比str2大时，肯定不是</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str1) &gt; <span class="built_in">len</span>(str2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str2):</span><br><span class="line">                <span class="keyword">if</span> str2[i] == str1[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == <span class="built_in">len</span>(str1):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">       	<span class="comment"># 按照字符串长度的逆序排列</span></span><br><span class="line">        strs.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> isslen(strs[i], strs[j]):</span><br><span class="line">                    n = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span>            </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(strs[i])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-6-28</title>
    <url>/2022/06/28/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-6-28/</url>
    <content><![CDATA[<h2 id="问题描述-15">问题描述</h2>
<h3 id="题目：摆动排序-II">题目：摆动排序 II</h3>
<p>给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p>
<p>你可以假设所有输入数组都可以得到满足题目要求的结果。</p>
<h3 id="示例-18">示例</h3>
<p>1、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,1,1,6,4]</span><br><span class="line">输出：[1,6,1,5,1,4]</span><br><span class="line">解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,2,2,3,1]</span><br><span class="line">输出：[2,3,1,3,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="提示-14">提示</h3>
<ul>
<li>1 &lt;= nums.length &lt;= 5 * 104</li>
<li>0 &lt;= nums[i] &lt;= 5000</li>
<li>题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果</li>
</ul>
<h3 id="来源-18">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/wiggle-sort-ii">https://leetcode.cn/problems/wiggle-sort-ii</a></p>
<h2 id="问题解答-18">问题解答</h2>
<h3 id="思想-5">思想</h3>
<p>如果将这样的序列隔行取出来可以得到以下两个列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[0]   nums[2]   nums[4]   nums[6]   nums[8]... </span><br><span class="line">nums[1]   nums[3]   nums[5]   nums[7]   nums[9]... </span><br></pre></td></tr></table></figure>
<p>如果这两个序列按照降序排列，即有： nums[1]  &gt; nums[0] ,  nums[1]   nums[3]  , nums[1] &gt; nums[2] ,	因此 nums[1] 为序列的最大值，同理可得 nums[3] 为子序列的最大值。又因为下面一行总比上面一行大，所以下面一行取序列中大数，上面取小数。</p>
<h3 id="代码-21">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleSort</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        numss = nums.copy()</span><br><span class="line">        numss.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(numss)</span><br><span class="line">        mid = <span class="built_in">int</span>((<span class="built_in">len</span>(numss)+<span class="number">1</span>)/<span class="number">2</span>) - <span class="number">1</span> </span><br><span class="line">        n = length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                nums[i] = numss[mid]</span><br><span class="line">                mid = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i] = numss[n]</span><br><span class="line">                n = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-7-23</title>
    <url>/2022/07/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-23/</url>
    <content><![CDATA[<h2 id="问题描述-16">问题描述</h2>
<h3 id="题目：摆动排序-II-2">题目：摆动排序 II</h3>
<p>给定一个长度为 n 的整数数组 nums ，其中 nums 是范围为 [1,n] 的整数的排列。还提供了一个 2D 整数数组 sequences ，其中 sequences[i] 是 nums 的子序列。检查 nums 是否是唯一的最短超序列 。最短超序列是长度最短的序列，并且所有序列 sequences[i] 都是它的子序列。对于给定的数组 sequences ，可能存在多个有效的超序列 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如，对于 sequences = [[1,2],[1,3]] ，有两个最短的 超序列 ，[1,2,3] 和 [1,3,2] 。</span><br><span class="line">而对于 sequences = [[1,2],[1,3],[1,2,3]] ，唯一可能的最短 超序列 是 [1,2,3] 。[1,2,3,4] 是可能的超序列，但不是最短的。</span><br></pre></td></tr></table></figure>
<p>如果 nums 是序列的唯一最短超序列 ，则返回 true ，否则返回 false 。子序列是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p>
<h3 id="示例-19">示例</h3>
<h4 id="1、-6">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], sequences = [[1,2],[1,3]]</span><br><span class="line">输出：false</span><br><span class="line">解释：有两种可能的超序列：[1,2,3]和[1,3,2]。</span><br><span class="line">序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。</span><br><span class="line">序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。</span><br><span class="line">因为 nums 不是唯一最短的超序列，所以返回false。</span><br></pre></td></tr></table></figure>
<h4 id="2、-6">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], sequences = [[1,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：最短可能的超序列为 [1,2]。</span><br><span class="line">序列 [1,2] 是它的子序列：[1,2]。</span><br><span class="line">因为 nums 不是最短的超序列，所以返回false。</span><br></pre></td></tr></table></figure>
<h4 id="3、-3">3、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：true</span><br><span class="line">解释：最短可能的超序列为[1,2,3]。</span><br><span class="line">序列 [1,2] 是它的一个子序列：[1,2,3]。</span><br><span class="line">序列 [1,3] 是它的一个子序列：[1,2,3]。</span><br><span class="line">序列 [2,3] 是它的一个子序列：[1,2,3]。</span><br><span class="line">因为 nums 是唯一最短的超序列，所以返回true。</span><br></pre></td></tr></table></figure>
<h3 id="提示-15">提示</h3>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 104</li>
<li>nums 是 [1, n] 范围内所有整数的排列</li>
<li>1 &lt;= sequences.length &lt;= 104</li>
<li>1 &lt;= sequences[i].length &lt;= 104</li>
<li>1 &lt;= sum(sequences[i].length) &lt;= 105</li>
<li>1 &lt;= sequences[i][j] &lt;= n</li>
<li>sequences 的所有数组都是 唯一 的</li>
<li>sequences[i] 是 nums 的一个子序列</li>
</ul>
<h3 id="来源-19">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/ur2n8P">https://leetcode.cn/problems/ur2n8P</a></p>
<h2 id="问题解答-19">问题解答</h2>
<h3 id="思想：拓扑排序">思想：拓扑排序</h3>
<p>我们把sequences看成是一个有向图，若按照拓扑排序，入度为0的点只有一个，则一定是一个最短的超序列，否则不是。此题也可以理解为，用sequences能不能转化为一个唯一序列。</p>
<p><img src="/2022/07/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-23/1.png" alt="uTools_1658562075174"></p>
<p>思路来源作者 作者：capital-worker，链接：<a href="https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-capital-worker-n6ti/">https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-capital-worker-n6ti/</a></p>
<h4 id="详细：">详细：</h4>
<p>由于 sequences 中的每个序列都是nums 的子序列，因此每个序列中的数字顺序都和 nums 中的数字顺序一致。为了判断 nums 是不是序列的唯一最短超序列，只需要判断根据 sequences 中的每个序列构造超序列的结果是否唯一。</p>
<p>可以将 sequences 中的所有序列看成有向图，数字 1 到 n分别表示图中的 n 个结点，每个序列中的相邻数字表示的结点之间存在一条有向边。根据给定的序列构造超序列等价于有向图的拓扑排序。</p>
<p>首先根据有向边计算每个结点的入度，然后将所有入度为 0 的结点添加到队列中，进行拓扑排序。每一轮拓扑排序时，队列中的元素个数表示可以作为超序列下一个数字的元素个数，根据队列中的元素个数，执行如下操作。</p>
<pre><code>如果队列中的元素个数大于 1，则超序列的下一个数字不唯一，因此 nums 不是唯一的最短超序列，返回 false。

如果队列中的元素个数等于 1，则超序列的下一个数字是队列中唯一的数字。将该数字从队列中取出，将该数字指向的每个数字的入度减 1，并将入度变成 0 的数字添加到队列中。
</code></pre>
<p>重复上述过程，直到出现队列中的元素个数不等于 1 的情况。</p>
<pre><code>如果队列中的元素个数大于 1，则 nums 不是唯一的最短超序列，返回 false。
如果队列为空，则完整的拓扑排序结束，nums 是唯一的最短超序列，返回 true。
</code></pre>
<p>作者：LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/">https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/</a></p>
<h3 id="代码1：">代码1：</h3>
<p>使用二维 n x n 数组来存储 sequences 构成的有向图，以列为入度、行为出度，依次删除入度为 0 的节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sequenceReconstruction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], sequences: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:  </span><br><span class="line">        n = <span class="built_in">len</span>(nums) </span><br><span class="line">        num_list = <span class="built_in">set</span>([])</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> sequences:</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> l:</span><br><span class="line">                num_list.update([a])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num_list) != <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        rudu = np.zeros(shape=(n,n))</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> sequences:</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(l[:-<span class="number">1</span>], l[<span class="number">1</span>:]):</span><br><span class="line">                rudu[i-<span class="number">1</span>,j-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">rudu</span>):</span><br><span class="line">            result = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(np.<span class="built_in">sum</span>(rudu, axis=<span class="number">0</span>)):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                    result.append(i)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dul</span>(<span class="params">rudu, col</span>):</span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(rudu[col,:]):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                rudu[col,i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> rudu</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(rudu)</span><br><span class="line">            <span class="keyword">if</span> rudu.shape[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cols = process(rudu)</span><br><span class="line">            <span class="built_in">print</span>(cols)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cols) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            rudu = dul(rudu, cols[<span class="number">0</span>])</span><br><span class="line">            rudu = np.delete(rudu, cols[<span class="number">0</span>], axis=<span class="number">0</span>)</span><br><span class="line">            rudu = np.delete(rudu, cols[<span class="number">0</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="代码2：">代码2：</h3>
<p>上面采用二维 n x n 数组存有向图，所需的时间和内存很大，而且涉及数组的行列删除，这对于n很大的情况很不友好。下面采用两个列表来简化操作，一个列表用于依次存 1 - n 节点的下一个节点，另一个列表存每个节点的入度为多少，每次将入度为 0 的节点放入q栈里，出栈时，下一个节点的入度减一，然后继续将入度为 0 的节点放入栈里。那么，如果栈里同时有1个以上的节点，说明不是唯一。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sequenceReconstruction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], sequences: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:  </span><br><span class="line">		n = <span class="built_in">len</span>(nums)</span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        inDeg = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> sequence <span class="keyword">in</span> sequences:</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> pairwise(sequence):</span><br><span class="line">                <span class="built_in">print</span>(x,y)</span><br><span class="line">                g[x - <span class="number">1</span>].append(y - <span class="number">1</span>)</span><br><span class="line">                inDeg[y - <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        q = deque([i <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(inDeg) <span class="keyword">if</span> d == <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            x = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                inDeg[y] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDeg[y] == <span class="number">0</span>:</span><br><span class="line">                    q.append(y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作者：LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/">https://leetcode.cn/problems/ur2n8P/solution/zhong-jian-xu-lie-by-leetcode-solution-urxc/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-7-25</title>
    <url>/2022/07/25/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-25/</url>
    <content><![CDATA[<h2 id="问题描述-17">问题描述</h2>
<h3 id="题目：完全二叉树插入器">题目：完全二叉树插入器</h3>
<p>完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>
<p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p>
<p>实现 CBTInserter 类:</p>
<ul>
<li>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；</li>
<li>CBTInserter.insert(int v)  向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值；</li>
<li>CBTInserter.get_root() 将返回树的头节点。</li>
</ul>
<h3 id="示例-20">示例</h3>
<p>1、</p>
<p><img src="/2022/07/25/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-25/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;CBTInserter&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;get_root&quot;]</span><br><span class="line">[[[1, 2]], [3], [4], []]</span><br><span class="line">输出</span><br><span class="line">[null, 1, 2, [1, 2, 3, 4]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">CBTInserter cBTInserter = new CBTInserter([1, 2]);</span><br><span class="line">cBTInserter.insert(3);  // 返回 1</span><br><span class="line">cBTInserter.insert(4);  // 返回 2</span><br><span class="line">cBTInserter.get_root(); // 返回 [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<h3 id="提示-16">提示</h3>
<ul>
<li>树中节点数量范围为 [1, 1000]</li>
<li>0 &lt;= Node.val &lt;= 5000</li>
<li>root 是完全二叉树</li>
<li>0 &lt;= val &lt;= 5000</li>
<li>每个测试用例最多调用 insert 和 get_root 操作 $10^4$ 次</li>
</ul>
<h3 id="来源-20">来源</h3>
<p>来源：力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/complete-binary-tree-inserter">https://leetcode.cn/problems/complete-binary-tree-inserter</a></p>
<h2 id="问题解答-20">问题解答</h2>
<h3 id="思想-6">思想</h3>
<p>三个函数中，最主要是初始化和插入这两个函数，返回根节点可以在初始化时就得到。而初始化也是给插入服务的，所以考虑插入节点需要什么，即找到当前插入的父节点。</p>
<p>完全二叉树是按照从上到下、从左到右依次插入节点，这里有一个规律，每当插入两个节点，其可插入的父节点按照顺序后移一位，如节点1、2、3、4，当插入完2，3节点后，4节点插入的位置为节点2。下面代码的 traverse 函数就是实现本功能。</p>
<h3 id="代码-22">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: TreeNode</span>):</span><br><span class="line">        self.root = root</span><br><span class="line">        self.n, self.nodelist = self.traverse(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, root:TreeNode</span>):</span><br><span class="line">        nodelist = deque([root])</span><br><span class="line">        visiting = deque([root])</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(visiting) &gt; <span class="number">0</span>:</span><br><span class="line">            node = visiting.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                visiting.append(node.left)</span><br><span class="line">                nodelist.append(node.left)</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    visiting.append(node.right)</span><br><span class="line">                    nodelist.append(node.right)</span><br><span class="line">                    n += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                    nodelist.popleft()</span><br><span class="line">                    n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> n, nodelist</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n, nodelist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        node = self.nodelist[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.n == <span class="number">0</span>:</span><br><span class="line">            node.left = TreeNode(val)</span><br><span class="line">            self.nodelist.append(node.left)</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = TreeNode(val)</span><br><span class="line">            self.nodelist.append(node.right)</span><br><span class="line">            self.nodelist.popleft()</span><br><span class="line">            self.n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root</span>(<span class="params">self</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">return</span> self.root</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-7-27</title>
    <url>/2022/07/27/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-27/</url>
    <content><![CDATA[<h2 id="问题描述-18">问题描述</h2>
<h3 id="题目：分数加减运算">题目：分数加减运算</h3>
<p>给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。</p>
<p>这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。</p>
<h3 id="示例-21">示例</h3>
<h4 id="1、-7">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: expression = &quot;-1/2+1/2&quot;</span><br><span class="line">输出: &quot;0/1&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2、-7">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: expression = &quot;-1/2+1/2+1/3&quot;</span><br><span class="line">输出: &quot;1/3&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3、-4">3、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: expression = &quot;1/3-1/2&quot;</span><br><span class="line">输出: &quot;-1/6&quot;</span><br></pre></td></tr></table></figure>
<h3 id="提示-17">提示</h3>
<ul>
<li>输入和输出字符串只包含 ‘0’ 到 ‘9’ 的数字，以及 ‘/’, ‘+’ 和 ‘-’。</li>
<li>输入和输出分数格式均为 + 或 - 分子/分母。如果输入的第一个分数或者输出的分数是正数，则 ‘+’ 会被省略掉。</li>
<li>输入只包含合法的最简分数，每个分数的分子与分母的范围是  [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。</li>
<li>输入的分数个数范围是 [1,10]。</li>
<li>最终结果的分子与分母保证是 32 位整数范围内的有效整数。</li>
</ul>
<h3 id="来源-21">来源</h3>
<p>来源：力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/fraction-addition-and-subtraction">https://leetcode.cn/problems/fraction-addition-and-subtraction</a></p>
<h2 id="问题解答-21">问题解答</h2>
<h3 id="思想：">思想：</h3>
<p>根据正则表达式匹配出所有的分子、分母和运算符，这里需要对首字母进行处理，不隐藏 ’+'，然后遍历所有分母，找到一个公倍数（不用最小），然后根据运算符把分子乘以一个因子（公倍数 / 相应的分母）加减到 sum 上，最后进行格式转换（如 0/1 和 分数约简）就行。</p>
<h3 id="代码：">代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fractionAddition</span>(<span class="params">self, expression: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">		<span class="comment"># 找到最大公倍数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            k = <span class="built_in">int</span>(<span class="built_in">min</span>(i,j))</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> i % k == <span class="number">0</span> <span class="keyword">and</span> j % k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> k</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">		<span class="comment"># 得到结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getresult</span>(<span class="params">s</span>):</span><br><span class="line">            strlist = re.findall(<span class="string">&#x27;(.)(\d*)/(\d*)&#x27;</span>, s)</span><br><span class="line">            fenzi = <span class="built_in">list</span>([])</span><br><span class="line">            fenmu = <span class="built_in">list</span>([])</span><br><span class="line">            calc = <span class="built_in">list</span>([])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">                calc.append(i[<span class="number">0</span>])</span><br><span class="line">                fenzi.append(<span class="built_in">int</span>(i[<span class="number">1</span>]))</span><br><span class="line">                fenmu.append(<span class="built_in">int</span>(i[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">            m = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> fenmu:</span><br><span class="line">                <span class="keyword">if</span> m % <span class="built_in">int</span>(i) != <span class="number">0</span>:</span><br><span class="line">                    m *= i</span><br><span class="line"></span><br><span class="line">            sum_fenzi = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> index, i  <span class="keyword">in</span> <span class="built_in">enumerate</span>(fenzi):</span><br><span class="line">                fz = <span class="built_in">int</span>(i) * m / (<span class="built_in">int</span>(fenmu[index]))</span><br><span class="line">                <span class="keyword">if</span> calc[index] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    sum_fenzi += fz</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sum_fenzi -= fz</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sum_fenzi == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;0/1&#x27;</span></span><br><span class="line">            </span><br><span class="line">            a = get(<span class="built_in">int</span>(<span class="built_in">abs</span>(sum_fenzi)), <span class="built_in">int</span>(m))</span><br><span class="line">            <span class="keyword">if</span> a != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">int</span>(sum_fenzi/a)&#125;</span>/<span class="subst">&#123;<span class="built_in">int</span>(m/a)&#125;</span>&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">int</span>(sum_fenzi)&#125;</span>/<span class="subst">&#123;<span class="built_in">int</span>(m)&#125;</span>&#x27;</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 显示‘+’，再进行处理</span></span><br><span class="line">        <span class="keyword">if</span> expression[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> getresult(<span class="string">&#x27;+&#x27;</span> + expression)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getresult(expression)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-7-26</title>
    <url>/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/</url>
    <content><![CDATA[<h2 id="问题描述-19">问题描述</h2>
<h3 id="题目：设计跳表">题目：设计跳表</h3>
<p>不使用任何库函数，设计一个 跳表 。</p>
<p>跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p>
<p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/1.gif" alt="img"></p>
<p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a></p>
<p>在本题中，你的设计应该要包含这些函数：</p>
<pre><code>bool search(int target) : 返回target是否存在于跳表中。
void add(int num): 插入一个元素到跳表。
bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。
</code></pre>
<p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p>
<h3 id="示例-22">示例</h3>
<h4 id="1、-8">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Skiplist&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;search&quot;, &quot;add&quot;, &quot;search&quot;, &quot;erase&quot;, &quot;erase&quot;, &quot;search&quot;]</span><br><span class="line">[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, false, null, true, false, true, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Skiplist skiplist = new Skiplist();</span><br><span class="line">skiplist.add(1);</span><br><span class="line">skiplist.add(2);</span><br><span class="line">skiplist.add(3);</span><br><span class="line">skiplist.search(0);   // 返回 false</span><br><span class="line">skiplist.add(4);</span><br><span class="line">skiplist.search(1);   // 返回 true</span><br><span class="line">skiplist.erase(0);    // 返回 false，0 不在跳表中</span><br><span class="line">skiplist.erase(1);    // 返回 true</span><br><span class="line">skiplist.search(1);   // 返回 false，1 已被擦除</span><br></pre></td></tr></table></figure>
<h3 id="提示-18">提示</h3>
<ul>
<li>0 &lt;= num, target &lt;= 2 * $10^4$</li>
<li>调用<code>search</code>, <code>add</code>,  <code>erase</code>操作次数不大于 5 * $10^4$</li>
</ul>
<h3 id="来源-22">来源</h3>
<p>来源：力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/design-skiplist">https://leetcode.cn/problems/design-skiplist</a></p>
<h2 id="问题解答-22">问题解答</h2>
<h3 id="思想：跳表">思想：跳表</h3>
<h4 id="1、什么是跳表？">1、什么是跳表？</h4>
<p>在传统的单链表中，每个元素都存放这下一个元素的引用，我们查找元素时，需要从链表头开始从前向后遍历，查找的时间复杂度为O(n)。</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/2.png" alt="img"></p>
<p>传统链表的查询效率非常低。那有没有什么办法提高效率呢？</p>
<p>我们可以采用空间换时间的办法，将上面的每两个元素抽出来做一个类似于索引的链表。</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/3.png" alt="img"></p>
<p>假设我们要查询6，我们从上层链表开始遍历，当遍历到7时，大于目标值，我们需要到下一层接着找目标值。</p>
<p>在上述遍历中，我们只需要遍历1、3、5、5、6即可找到目标结点，在普通的链表中需要1、2、3、4、5、6才能找到。</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/4.png" alt="img"><br>
也许有人会说，这才节约了1次，其实只是我们的数据量比较少且层数比较少，假如我们有1000万条数据，减少一半就是500万条数据。随着我们层数的增加，查询的效率接近二分查找的O(logn)，在空间复杂度上，假如我们每层都是原来的1/2，上层元素的结点和为：</p>
<p>n/2 + n/4 + n/8 +…，会无限接近n，所以空间复杂度为O(n)。</p>
<h4 id="2、跳表如何插入数据？">2、跳表如何插入数据？</h4>
<p>插入数据也很简单，跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/5.png" alt="img"><br>
但是这样插入会有问题，如下图所示假如一直往原始列表中添加数据，但是不更新上层元素，就可能出现两个节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率退化为O(n)</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/6.png" alt="img"></p>
<h5 id="我们如何去维护上层元素呢？">我们如何去维护上层元素呢？</h5>
<p>比较容易理解的做法就是完全重建上层元素，我们每次插入数据后，都把这个跳表的上层元素删掉全部重建，重建的时间复杂度是多少呢？因为上层元素的空间复杂度是O(n)，即：上层元素节点的个数是O(n)级别，时间复杂度是O(n)。导致每次插入的时间复杂度也变为了O(n)，而不是O(logn)。</p>
<p>由于我们是均匀的选取n/2个元素作为上一层的元素，我们也可以采用随机的方式，也就是在链表中随机的选取n/2个元素作为他的上一层元素，并且当原始链表中元素数量足够大，且抽取足够随机的话，我们得到的上层元素是均匀的。于是我们可以在每次新插入元素的时候，一定要插入第一层，有1/2的概率插入第二层、1/4的概率插入第三层、1/8的概率插入第四层。当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几层中。</p>
<h4 id="3、跳表如何删除数据？">3、跳表如何删除数据？</h4>
<p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 ，则执行删除操作。我们把每一层的元素删除即可，如果顶层数据没有，则需要降低层数。在具体的实现上采用数组的形式，可以进一步节省空间</p>
<p><img src="/2022/07/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-7-26/7.png" alt="img"></p>
<h4 id="作者-13">作者</h4>
<p>capital-worker，链接：<a href="https://leetcode.cn/problems/design-skiplist/solution/she-ji-tiao-biao-by-capital-worker-3vqk/">https://leetcode.cn/problems/design-skiplist/solution/she-ji-tiao-biao-by-capital-worker-3vqk/</a></p>
<h4 id="作用">作用</h4>
<p>了解跳表这个数据结构。</p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-9-15</title>
    <url>/2022/09/15/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-15/</url>
    <content><![CDATA[<h2 id="问题描述-20">问题描述</h2>
<h3 id="题目：灯泡开关-Ⅱ">题目：灯泡开关 Ⅱ</h3>
<p>房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。</p>
<p>这 4 个开关各自都具有不同的功能，其中：</p>
<pre><code>开关 1 ：反转当前所有灯的状态（即开变为关，关变为开）
开关 2 ：反转编号为偶数的灯的状态（即 2, 4, ...）
开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...）
开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...）
</code></pre>
<p>你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。</p>
<p>给你两个整数 n 和 presses ，执行完所有按压之后，返回不同可能状态的数量。</p>
<h3 id="示例-23">示例</h3>
<h4 id="1、-9">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, presses = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：状态可以是：</span><br><span class="line">- 按压开关 1 ，[关]</span><br><span class="line">- 按压开关 2 ，[开]</span><br></pre></td></tr></table></figure>
<h4 id="2、-8">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, presses = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：状态可以是：</span><br><span class="line">- 按压开关 1 ，[关, 关]</span><br><span class="line">- 按压开关 2 ，[开, 关]</span><br><span class="line">- 按压开关 3 ，[关, 开]</span><br></pre></td></tr></table></figure>
<h4 id="3、-5">3、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, presses = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：状态可以是：</span><br><span class="line">- 按压开关 1 ，[关, 关, 关]</span><br><span class="line">- 按压开关 2 ，[关, 开, 关]</span><br><span class="line">- 按压开关 3 ，[开, 开, 开]</span><br><span class="line">- 按压开关 4 ，[关, 开, 开]</span><br></pre></td></tr></table></figure>
<h3 id="提示-19">提示</h3>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= presses &lt;= 1000</code></li>
</ul>
<h3 id="来源-23">来源</h3>
<p>来源：力扣（LeetCode）,链接：<a href="https://leetcode.cn/problems/bulb-switcher-ii">https://leetcode.cn/problems/bulb-switcher-ii</a></p>
<h2 id="问题解答-23">问题解答</h2>
<h3 id="方法1：暴力法">方法1：暴力法</h3>
<p>因为是寻找所有可能的灯泡组合，又因为每个灯泡只受固定开关影响，所以统计各个开关次数，然后得到每个灯泡的亮灭，即可以得到最终组合数（此时因为n较大，采用列表存太耗费存储空间，可以将列表转为字符串然后进行哈希运算）。（这部分无代码）</p>
<p>再想一想，灯泡其实可以分为四组，开关1、2控制的、开关1、2、4控制的、开关1、3控制的、开关1、3、4控制的。那么就不用遍历所有灯泡，可以在知道各个开关次数的情况下，得到各个灯泡组的亮灭。</p>
<h4 id="代码-23">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flipLights</span>(<span class="params">self, n: <span class="built_in">int</span>, presses: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getnums</span>(<span class="params">m, x, y, z</span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> (m+x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> n == <span class="number">3</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> (m+x+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> (m+x+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">3</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            result = <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, presses+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == presses:</span><br><span class="line">                </span><br><span class="line">                result.add(getnums(i,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, presses+<span class="number">1</span>-i):</span><br><span class="line">                <span class="keyword">if</span> j + i == presses:</span><br><span class="line">                    </span><br><span class="line">                    result.add(getnums(i,j,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, presses+<span class="number">1</span>-i-j):</span><br><span class="line">                    result.add(getnums(i,j,k,presses-i-j-k))</span><br></pre></td></tr></table></figure>
<p>注：这种方法太耗费时间，提交过不了。</p>
<h3 id="方法二：去除开关数">方法二：去除开关数</h3>
<p>查看上面代码可以看到，各个组合的亮灭其实是看其对于控制开关总数的奇偶性，那么其实不需要知道各个开关的具体次数，只需要知道其奇偶就行。且由于最终总数确定，奇偶性已知，那么四种位置的奇偶性便可以已知有哪几种组合，那么确定各个组合最后的灯泡组合并去重就得到不同状态的总数。</p>
<h4 id="代码-24">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flipLights</span>(<span class="params">self, n: <span class="built_in">int</span>, presses: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getnums</span>(<span class="params">m, x, y, z</span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> (m+x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> n == <span class="number">3</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> (m+x+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> (m+x+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y+z) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (m+y) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    result[<span class="number">3</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            result = <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> presses%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            result.add(getnums(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            result.add(getnums(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            result.add(getnums(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">            result.add(getnums(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> presses &gt; <span class="number">1</span>:</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">                result.add(getnums(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> presses &gt;= <span class="number">2</span>:</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">                result.add(getnums(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">                result.add(getnums(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">                result.add(getnums(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> presses &gt;= <span class="number">4</span>:</span><br><span class="line">                result.add(getnums(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            result.add(getnums(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(result)</span><br></pre></td></tr></table></figure>
<h4 id="作者-14">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/bulb-switcher-ii/solution/deng-pao-kai-guan-ii-by-leetcode-solutio-he7o/">https://leetcode.cn/problems/bulb-switcher-ii/solution/deng-pao-kai-guan-ii-by-leetcode-solutio-he7o/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-9-26</title>
    <url>/2022/09/26/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-26/</url>
    <content><![CDATA[<h2 id="问题描述-21">问题描述</h2>
<h3 id="题目：消失的两个数字">题目：消失的两个数字</h3>
<p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p>
<p>以任意顺序返回这两个数字均可。</p>
<h3 id="示例-24">示例</h3>
<h4 id="1、-10">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure>
<h4 id="2、-9">2、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,3]</span><br><span class="line">输出: [1,4]</span><br></pre></td></tr></table></figure>
<h3 id="提示-20">提示</h3>
<ul>
<li>0 &lt;= nums.length &lt;= 30000</li>
</ul>
<h3 id="来源-24">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/missing-two-lcci">https://leetcode.cn/problems/missing-two-lcci</a></p>
<h2 id="问题解答-24">问题解答</h2>
<h3 id="数学规律">数学规律</h3>
<p>首先，确定N为输入列表长度加2，那么这N个数字无缺失的情况下，和等于$sum=\sum_{i=1}^{N}i=\frac{N(N+1)}{2}$，再求得输入序列的总和为 sum_list，那么缺失的两个数字和为 bias = sum_list - sum，那么这两个数中必有一个数小于 bias/2。那么即可将原问题转化为在原列表中找到一个小于 bias/2 的数，再由于 1~bias/2 无缺失和可直接求得，又可得到原列表所有小于  bias/2 数之和，两者一减便可得缺失的一个数，另一个用 bias 减去这个数即可。</p>
<h4 id="代码-25">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingTwo</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums) + <span class="number">2</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        sum_target = <span class="built_in">int</span>((N**<span class="number">2</span> + N)/<span class="number">2</span>)</span><br><span class="line">        bias_ = sum_target - sum_</span><br><span class="line"></span><br><span class="line">        bias = <span class="built_in">int</span>(bias_/<span class="number">2</span>)</span><br><span class="line">        sum_temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt;= bias:</span><br><span class="line">                sum_temp += i</span><br><span class="line"></span><br><span class="line">        sum_bias = <span class="built_in">int</span>((bias**<span class="number">2</span> + bias)/<span class="number">2</span>)</span><br><span class="line">        a = sum_bias - sum_temp</span><br><span class="line">        <span class="keyword">return</span> a, bias_ - a</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-9-28</title>
    <url>/2022/09/28/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-28/</url>
    <content><![CDATA[<h2 id="问题描述-22">问题描述</h2>
<h3 id="题目：第-k-个数">题目：第 k 个数</h3>
<p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>
<h3 id="示例-25">示例</h3>
<h4 id="1、-11">1、</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: k = 5</span><br><span class="line"></span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<h3 id="来源-25">来源</h3>
<p>力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/get-kth-magic-number-lcci">https://leetcode.cn/problems/get-kth-magic-number-lcci</a></p>
<h2 id="问题解答-25">问题解答</h2>
<h3 id="最小堆">最小堆</h3>
<p>要得到从小到大的第 k 个数，可以使用最小堆实现。初始时堆为空。首先将最小的数 1加入堆。每次取出堆顶元素 x，则 x 是堆中最小的数，由于 3x,5x,7x 也是符合要求的数，因此将 3x,5x,7x 加入堆。上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。在排除重复元素的情况下，第 k 次从最小堆中取出的元素即为第 k 个数。</p>
<h4 id="代码-26">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthMagicNumber</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        factors = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125;</span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">            curr = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := curr * factor) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nxt)</span><br><span class="line">                    heapq.heappush(heap, nxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)</span><br></pre></td></tr></table></figure>
<h4 id="作者-15">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/solution/di-k-ge-shu-by-leetcode-solution-vzp7/">https://leetcode.cn/problems/get-kth-magic-number-lcci/solution/di-k-ge-shu-by-leetcode-solution-vzp7/</a></p>
<h3 id="三指针法">三指针法</h3>
<p>为了叙述方便，我们就把符合题目要求的这些数叫做丑数。不难发现，一个丑数总是由前面的某一个丑数 x3 / x5 / x7 得到。反过来说也是一样的，一个丑数 x3 / x5 / x7 就会得到某一个更大的丑数。</p>
<p>如果把丑数数列叫做 ugly[i]，那么考虑一下三个数列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ugly[0]*3,ugly[1]*3,ugly[2]*3,ugly[3]*3,ugly[4]*3,……</span><br><span class="line">2. ugly[0]*5,ugly[1]*5,ugly[2]*5,ugly[3]*5,ugly[4]*5,……</span><br><span class="line">3. ugly[0]*7,ugly[1]*7,ugly[2]*7,ugly[3]*7,ugly[4]*7,……</span><br></pre></td></tr></table></figure>
<p>上面这个三个数列合在一起就形成了新的、更长的丑数数列。如果合在一起呢？这其实就是一个<strong>合并有序线性</strong>表的问题。</p>
<p>定义三个index 分别指向上面三个数列，下一个丑数一定是三个 index 代表的值中最小的那个。然后相应 index++ 即可。</p>
<p>举个例子，初始值 ugly[0]=1; index1=0; index2=0; index3=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ugly[1]=Min(ugly[index1]*3,ugly[index2]*5,ugly[index3]*7)</span><br><span class="line">=Min(1*3,1*5,1*7)</span><br><span class="line">=3</span><br><span class="line">于是 index1++;</span><br><span class="line"></span><br><span class="line">ugly[2]=Min(ugly[index1]*3,ugly[index2]*5,ugly[index3]*7)</span><br><span class="line">=Min(3*3,1*5,1*7)</span><br><span class="line">=5</span><br><span class="line">于是 index2++;</span><br></pre></td></tr></table></figure>
<p>以此类推</p>
<h4 id="代码-27">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthMagicNumber</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_list = [<span class="number">1</span>]</span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        index2 = <span class="number">0</span></span><br><span class="line">        index3 = <span class="number">0</span></span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> index == k:</span><br><span class="line">                <span class="keyword">return</span> num_list[-<span class="number">1</span>]</span><br><span class="line">            a = num_list[index1] * <span class="number">3</span></span><br><span class="line">            b = num_list[index2] * <span class="number">5</span></span><br><span class="line">            c = num_list[index3] * <span class="number">7</span></span><br><span class="line">            <span class="keyword">if</span> a &lt;= b <span class="keyword">and</span> a &lt;= c:</span><br><span class="line">                index1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> a != num_list[-<span class="number">1</span>]:</span><br><span class="line">                    num_list.append(a)</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> b &lt;= a <span class="keyword">and</span> b &lt;= c:</span><br><span class="line">                index2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> b != num_list[-<span class="number">1</span>]:</span><br><span class="line">                    num_list.append(b)</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index3 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c != num_list[-<span class="number">1</span>]:</span><br><span class="line">                    num_list.append(c)</span><br><span class="line">                    index += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="作者-16">作者</h4>
<p>orangex,链接：<a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/solution/di-k-ge-shu-jiu-shi-xiang-bu-tong-wei-he-san-zhi-z/">https://leetcode.cn/problems/get-kth-magic-number-lcci/solution/di-k-ge-shu-jiu-shi-xiang-bu-tong-wei-he-san-zhi-z/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-9-5</title>
    <url>/2022/09/05/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-5/</url>
    <content><![CDATA[<h2 id="问题描述-23">问题描述</h2>
<h3 id="题目：寻找重复的子树">题目：寻找重复的子树</h3>
<p>给定一棵二叉树 root，返回所有重复的子树。</p>
<p>对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>
<p>如果两棵树具有相同的结构和相同的结点值，则它们是重复的</p>
<h3 id="示例-26">示例</h3>
<h4 id="1、-12">1、</h4>
<p><img src="/2022/09/05/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-5/1.png" alt="image-20220905193532489"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,null,2,4,null,null,4]</span><br><span class="line">输出：[[2,4],[4]]</span><br></pre></td></tr></table></figure>
<h4 id="2、-10">2、</h4>
<p><img src="/2022/09/05/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-5/2.png" alt="image-20220905193625716"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<h4 id="3、-6">3、</h4>
<p><img src="/2022/09/05/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-9-5/3.png" alt="image-20220905193659922"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,2,2,3,null,3,null]</span><br><span class="line">输出：[[2,3],[3]]</span><br></pre></td></tr></table></figure>
<h3 id="提示-21">提示</h3>
<ul>
<li>树中的结点数在<code>[1,10^4]</code>范围内。</li>
<li><code>-200 &lt;= Node.val &lt;= 200</code></li>
</ul>
<h3 id="来源-26">来源</h3>
<p>来源：力扣（LeetCode），链接：<a href="https://leetcode.cn/problems/find-duplicate-subtrees">https://leetcode.cn/problems/find-duplicate-subtrees</a></p>
<h2 id="问题解答-26">问题解答</h2>
<h3 id="思想：使用三元组进行唯一表示">思想：使用三元组进行唯一表示</h3>
<p>使用递归序列化树，并可以用一个三元组直接表示一棵子树，即 $(x, l, r)$，它们分别表示：</p>
<pre><code>根节点的值为 x；
左子树的序号为 l；
右子树的序号为 r。
</code></pre>
<p>这里的「序号」指的是：每当我们发现一棵新的子树，就给这棵子树一个序号，用来表示其结构。那么两棵树是重复的，当且仅当它们对应的三元组完全相同。</p>
<p>使用「序号」的好处在于同时减少了时间复杂度和空间复杂度。使用序号替换整个左子树和右子树的序列，可以使得每一个节点只使用常数大小的空间。</p>
<h4 id="代码-28">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicateSubtrees</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            tri = (node.val, dfs(node.left), dfs(node.right))</span><br><span class="line">            <span class="keyword">if</span> tri <span class="keyword">in</span> seen:</span><br><span class="line">                (tree, index) = seen[tri]</span><br><span class="line">                repeat.add(tree)</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">nonlocal</span> idx</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                seen[tri] = (node, idx)</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">        </span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        seen = <span class="built_in">dict</span>()</span><br><span class="line">        repeat = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(repeat)</span><br></pre></td></tr></table></figure>
<h4 id="作者-17">作者</h4>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/find-duplicate-subtrees/solution/xun-zhao-zhong-fu-de-zi-shu-by-leetcode-zoncw/">https://leetcode.cn/problems/find-duplicate-subtrees/solution/xun-zhao-zhong-fu-de-zi-shu-by-leetcode-zoncw/</a></p>
<h4 id="作用-2">作用</h4>
<p>树的一种结构化表示：三元组，通过递归序列化，x为该节点值，l为左子树的序号，r为右子树的序号。由于采用递归方式，所以优先加入字典的是叶子节点，然后依次增加节点形成的子树。</p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2023-2-23</title>
    <url>/2023/02/23/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2023-2-23/</url>
    <content><![CDATA[<h2 id="循环码排列">循环码排列</h2>
<h3 id="问题描述-24">问题描述</h3>
<p>给你两个整数 <code>n</code> 和 <code>start</code>。你的任务是返回任意 <code>(0,1,2,,...,2^n-1)</code> 的排列 <code>p</code>，并且满足：</p>
<ul>
<li><code>p[0] = start</code></li>
<li><code>p[i]</code> 和 <code>p[i+1]</code> 的二进制表示形式只有一位不同</li>
<li><code>p[0]</code> 和 <code>p[2^n -1]</code> 的二进制表示形式也只有一位不同</li>
</ul>
<h4 id="示例-27">示例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, start = 3</span><br><span class="line">输出：[3,2,0,1]</span><br><span class="line">解释：这个排列的二进制表示是 (11,10,00,01)</span><br><span class="line">     所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2]</span><br><span class="line"></span><br><span class="line">输出：n = 3, start = 2</span><br><span class="line">输出：[2,6,7,5,4,0,1,3]</span><br><span class="line">解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011)</span><br></pre></td></tr></table></figure>
<h4 id="提示-22">提示</h4>
<ul>
<li><code>1 &lt;= n &lt;= 16</code></li>
<li><code>0 &lt;= start &lt; 2^n</code></li>
</ul>
<h3 id="问题解答-27">问题解答</h3>
<p>本题是换了一个初始值的格雷码生成算法。</p>
<p>初始格雷码生成公式：</p>
<p>第$i\geq 0$个格雷码即为：$g_i = i \oplus \lfloor \frac{i}{2} \rfloor$，其中$\oplus$表示按位异或运算。证明见<a href="https://leetcode.cn/problems/gray-code/solutions/1196538/ge-lei-bian-ma-by-leetcode-solution-cqi7/">格雷编码</a></p>
<p>初始值的不同，即在生成的格雷码的最后与初始值进行按位异或即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">circularPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, start: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = [<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">            ans[i] = (i &gt;&gt; <span class="number">1</span>) ^ i ^ start</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="作者-18">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/solutions/2126240/xun-huan-ma-pai-lie-by-leetcode-solution-6e40/">https://leetcode.cn/problems/circular-permutation-in-binary-representation/solutions/2126240/xun-huan-ma-pai-lie-by-leetcode-solution-6e40/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:N阶末尾0的个数</title>
    <url>/2023/03/31/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-N%E9%98%B6%E6%9C%AB%E5%B0%BE0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="计算阶乘n-末尾所含0的个数">计算阶乘n!末尾所含0的个数</h2>
<h3 id="问题描述-25">问题描述</h3>
<p>给定参数n（n为正整数），请计算n的阶乘n！末尾所含有“0”的个数。<br>
例如，5！=120，其末尾所含有的“0”的个数为1；10！=3628800，其末尾所含有的“0”的个数为2；20！=2432902008176640000，其末尾所含有的“0”的个数为4。</p>
<h3 id="计算公式">计算公式</h3>
<p>这里先给出其计算公式，后面给出推导过程。 令f(x)表示正整数x末尾所含有的“0”的个数，则有：</p>
<ul>
<li>当0&lt;n&lt;5时，f(n!)=0;</li>
<li>当n&gt;=5时，f(n!)=k+f(k!),其中k=n/5（取整）。</li>
</ul>
<h4 id="证明">证明</h4>
<p>显然，对于阶乘这个大数，我们不可能将其结果计算出来，再统计其末尾所含有的“0”的个数。所以必须从其数字特征进行分析。下面我们从因式分解的角度切入分析。</p>
<p>我们先考虑一般的情形。对于任意一个正整数，若对其进行因式分解，那么其末尾的“0”必可以分解为2*5。在这里，每一个“0”必然和一 个因子“5”相对应。但请注意，一个数的因式分解中因子“5”不一定对应着一个“0”，因为还需要一个因子“2”，才能实现其一一对应。</p>
<p>我们再回到原先的问题。这里先给出一个结论：</p>
<p>结论1：对于n的阶乘n！，其因式分解中，如果存在一个因子“5”，那么它必然对应着n！末尾的一个“0”。</p>
<p>下面对这个结论进行证明：</p>
<ol>
<li>当n&lt;5时,结论显然成立。</li>
<li>当n&gt;=5时，令n！=[5k*5(k-1)*…*10*5]*a，其中n=5k+r(0&lt;=r&lt;=4)，a是一个不含因子“5”的整数。</li>
<li>对于序列5k,5(k-1),…,10,5中每一个数5i(1&lt;=i&lt;=k)，都含有因子“5”，并且 在区间(5(i-1),5i)(1&lt;=i&lt;=k)内存在偶数，也就是说，a中存在一个因子“2”与5i相对应。即，这里的k个因子 “5”与n！末尾的k个“0”一一对应。</li>
<li>我们进一步把n！表示为：n！=5^k*k!*a（公式1），其中5^k表示5的k次方。很容易利用(1)和迭代法，得出结论1。</li>
</ol>
<p>上面证明了n的阶乘n！末尾的“0”与n！的因式分解中的因子“5”是一一对应的。也就是说，计算n的阶乘n！末尾的“0”的个数，可以转换为计算其因式分解中“5”的个数。</p>
<p>令f(x)表示正整数x末尾所含有的“0”的个数，g(x)表示正整数x的因式分解中因子“5”的个数，则利用上面的的结论1和公式1有： f(n!)=g(n!)=g(5^k*k!*a)=k+g(k!)=k+f(k!)</p>
<p>所以，最终的计算公式为：</p>
<ul>
<li>当0&lt;n&lt;5时，f(n!)=0;</li>
<li>当n&gt;=5时，f(n!)=k+f(k!),其中k=n/5（取整）。</li>
</ul>
<h4 id="计算举例">计算举例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(5!)=1+f(1!)=1 </span><br><span class="line">f(10!)=2+f(2!)=2 </span><br><span class="line">f(20!)=4+f(4!)=4 </span><br><span class="line">f(100!)=20+f(20!)=20+4+f(4!)=24 </span><br><span class="line">f(1000!)=200+f(200!)=200+40+f(40!)=240+8+f(8!)=248+1+f(1)=249 </span><br><span class="line">... </span><br></pre></td></tr></table></figure>
<h4 id="作者-19">作者</h4>
<p><a href="https://www.iteye.com/blog/gaofen100-1269394">https://www.iteye.com/blog/gaofen100-1269394</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:值和下标之差都在给定的范围内</title>
    <url>/2023/04/24/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E4%B9%8B%E5%B7%AE%E9%83%BD%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E5%86%85/</url>
    <content><![CDATA[<h2 id="值和下标之差都在给定的范围内">值和下标之差都在给定的范围内</h2>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>
<h3 id="示例-28">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3, t = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1, t = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,9,1,5,9], k = 2, t = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h3 id="提示-23">提示</h3>
<ul>
<li>$0 &lt;= nums.length &lt;= 2 * 10^4$</li>
<li>$-2^31 &lt;= nums[i] &lt;= 2^31 - 1$</li>
<li>$0 &lt;= k &lt;= 10^4$</li>
<li>$0 &lt;= t &lt;= 2^31 - 1$</li>
</ul>
<h4 id="问题解答-28">问题解答</h4>
<h3 id="方法一：滑动窗口-有序集合">方法一：滑动窗口 + 有序集合</h3>
<h4 id="思路-6">思路</h4>
<p>对于序列中每一个元素 x 左侧的至多 k 个元素，如果这 k 个元素中存在一个元素落在区间 [x−t,x+t] 中，我们就找到了一对符合条件的元素。注意到对于两个相邻的元素，它们各自的左侧的 k 个元素中有 k−1 个是重合的。于是我们可以使用滑动窗口的思路，维护一个大小为 k 的滑动窗口，每次遍历到元素 x 时，滑动窗口中包含元素 x 前面的最多 k 个元素，我们检查窗口中是否存在元素落在区间 [x−t,x+t] 中即可。</p>
<p>如果使用队列维护滑动窗口内的元素，由于元素是无序的，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。如果数组的长度为 n，则使用队列的时间复杂度为 O(nk)，会超出时间限制。</p>
<p>因此我们希望能够找到一个数据结构维护滑动窗口内的元素，该数据结构需要满足以下操作：</p>
<pre><code>支持添加和删除指定元素的操作，否则我们无法维护滑动窗口；

内部元素有序，支持二分查找的操作，这样我们可以快速判断滑动窗口中是否存在元素满足条件，具体而言，对于元素 x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间 [x−t,x+t] 中，只需要判断滑动窗口中所有大于等于 x−t 的元素中的最小元素是否小于等于 x+t 即可。
</code></pre>
<p>我们可以使用<strong>有序集合</strong>来支持这些操作。</p>
<p>实现方面，我们在有序集合中查找大于等于 x−t 的最小的元素 y，如果 y 存在，且 $y \leq x + t$，我们就找到了一对符合条件的元素。完成检查后，我们将 x 插入到有序集合中，如果有序集合中元素数量超过了 k，我们将有序集合中最早被插入的元素删除即可。</p>
<p>**注意：**如果当前有序集合中存在相同元素，那么此时程序将直接返回 true，因为此时相当于在k的范围内，存在两个数之差为0，其用于小于等于t。因此本题中的有序集合无需处理相同元素的情况。</p>
<h4 id="代码-29">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line">        st=SortedList()</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):            </span><br><span class="line">            st.add(num)</span><br><span class="line">            index=bisect_left(st,num)<span class="comment"># 将num插入st，如果存在相同的值，查找最左边</span></span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(st)-<span class="number">1</span> <span class="keyword">and</span> st[index+<span class="number">1</span>]-st[index]&lt;=t:<span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 比较比当前值大一个的数与当前值的差</span></span><br><span class="line">            <span class="keyword">if</span> index&gt;<span class="number">0</span> <span class="keyword">and</span> st[index]-st[index-<span class="number">1</span>]&lt;=t:<span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 比较比当前值小一个的数与当前值的差</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(st)&gt;k:</span><br><span class="line">                st.remove(nums[i-k]) <span class="comment"># 由于里面不会存在重复值，可以直接使用remove删除最先添加进来的数。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>有序集合可参考网站：<a href="https://www.jb51.net/article/221847.htm%E3%80%82">https://www.jb51.net/article/221847.htm。</a></p>
<h4 id="复杂度分析-8">复杂度分析</h4>
<p>时间复杂度：$O(n \log(\min(n, k)))$，其中 n 是给定数组的长度。每个元素至多被插入有序集合和从有序集合中删除一次，每次操作时间复杂度均为 $O(\log(\min(n, k))$。</p>
<p>空间复杂度：$O(\min(n, k))$，其中 n 是给定数组的长度。有序集合中至多包含 $\min(n, k + 1)$个元素。</p>
<h4 id="作者-20">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/7WqeDu/solutions/1038291/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/">https://leetcode.cn/problems/7WqeDu/solutions/1038291/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</a></p>
<h3 id="方法二：桶">方法二：桶*</h3>
<h4 id="思路-7">思路</h4>
<p>我们也可以使用利用桶排序的思想解决本题。我们按照元素的大小进行分桶，维护一个滑动窗口内的元素对应的元素。</p>
<p>对于元素 x，其影响的区间为[x - t, x + t]。于是我们可以设定桶的大小为 t+1。如果两个元素同属一个桶，那么这两个元素必然符合条件，因为一个桶的最大值减去最小值最大为t。如果两个元素属于相邻桶，那么我们需要校验这两个元素是否差值不超过 t。如果两个元素既不属于同一个桶，也不属于相邻桶，那么这两个元素必然不符合条件。</p>
<p>具体地，我们遍历该序列，假设当前遍历到元素 x，那么我们首先检查 x 所属于的桶是否已经存在元素，如果存在，那么我们就找到了一对符合条件的元素，否则我们继续检查两个相邻的桶内是否存在符合条件的元素。</p>
<p>实现方面，我们将 int 范围内的每一个整数 x 表示为 $x = (t + 1) \times a + b(0 \leq b \leq t)$的形式，这样 x 即归属于编号为 a 的桶。因为一个桶内至多只会有一个元素，所以我们使用哈希表实现即可。</p>
<h4 id="代码-30">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        buckets=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            bucket = num // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> bucket + <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> <span class="built_in">abs</span>(num - buckets[bucket + <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> bucket - <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> <span class="built_in">abs</span>(num - buckets[bucket - <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">            buckets[bucket] = num</span><br><span class="line">            <span class="keyword">if</span> i - k &gt;= <span class="number">0</span>:</span><br><span class="line">                old_bucked = nums[i - k] // (t + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> buckets[old_bucked]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="作者-21">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/7WqeDu/solutions/1038291/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/">https://leetcode.cn/problems/7WqeDu/solutions/1038291/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</a></p>
]]></content>
      <tags>
        <tag>Leetcode,有序集合，桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:出现频率最高的k个数字</title>
    <url>/2023/04/24/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="和最小的-k-个数对">和最小的 k 个数对</h2>
<p>给定两个以升序排列的整数数组 <code>nums1</code> 和 <code>nums2</code> , 以及一个整数 <code>k</code> 。</p>
<p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code> 。</p>
<p>请找到和最小的 <code>k</code> 个数对 <code>(u1,v1)</code>, <code> (u2,v2)</code>  …  <code>(uk,vk)</code> 。</p>
<h3 id="示例-29">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class="line">输出: [1,1],[1,1]</span><br><span class="line">解释: 返回序列中的前 2 对数：[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,2], nums2 = [3], k = 3 </span><br><span class="line">输出: [1,3],[2,3]</span><br><span class="line">解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]</span><br></pre></td></tr></table></figure>
<h3 id="提示-24">提示</h3>
<ul>
<li>$1 &lt;= nums1.length, nums2.length &lt;= 10^4$</li>
<li>$-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9$</li>
<li><code>nums1</code>, <code>nums2</code> 均为升序排列</li>
<li>1 &lt;= k &lt;= 1000</li>
</ul>
<h2 id="问题解答-29">问题解答</h2>
<h3 id="方法">方法</h3>
<p>对于已经按升序排列的两个数组 $\textit{nums}_1,\textit{nums}_2$，长度分别为 $\textit{length}_1,\textit{length}_2$，我们可以知道和最小的数对一定为$ (\textit{nums}_1[0], \textit{nums}_2[0])$，和最大的数对一定为 $(\textit{nums}_1[\textit{length}_1-1], \textit{nums}_2[\textit{length}_2-1])$。本题要求找到最小的 k个数对，最直接的办法是可以将所有的数对求出来，然后利用排序或者 TopK 解法求出最小的 k 个数对即可。</p>
<p>实际求解时可以不用求出所有的数对，只需从所有符合待选的数对中选出最小的即可，假设当前已选的前 n 小数对的索引分别为$ (a_1,b_1),(a_2,b_2),(a_3,b_3),\ldots,(a_n,b_n)$，由于两个数组都是按照升序进行排序的，则可以推出第 n+1 小的数对的索引选择范围为 $(a_1+1,b_1),(a_1,b_1+1),(a_2+1,b_2),(a_2,b_2+1),(a_3+1,b_3),(a_3,b_3+1),\ldots,(a_n+1,b_n),(a_n,b_n+1)$，假设我们利用堆的特性可以求出待选范围中最小数对的索引为 $(a_{i},b_{i})$，同时将新的待选的数对 $(a_{i}+1,b_{i}),(a_{i},b_{i}+1)$ 加入到堆中，直到我们选出 k 个数对即可。</p>
<pre><code>如果我们每次都将已选的数对 (a_&#123;i&#125;,b_&#123;i&#125;) 的待选索引 (a_&#123;i&#125;+1,b_&#123;i&#125;),(a_&#123;i&#125;,b_&#123;i&#125;+1) 加入到堆中则可能出现重复的问题，一般需要设置标记位解决去重的问题。我们可以将 nums1 的前k个索引数对 (0,0),(1,0),…,(k−1,0)加入到队列中，每次从队列中取出元素 (x,y)时，我们只需要将 nums2的索引增加即可，这样避免了重复加入元素的问题。
</code></pre>
<h4 id="代码-31">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kSmallestPairs</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        </span><br><span class="line">        l1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        l2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        heap = <span class="built_in">list</span>([(nums1[i] + nums2[<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(k, l1))])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt;= k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            _, i, j = heapq.heappop(heap)</span><br><span class="line">            res.append([nums1[i],nums2[j]])</span><br><span class="line">            <span class="keyword">if</span> j &lt; l2 - <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(heap, (nums1[i]+nums2[j+<span class="number">1</span>],i,j+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-9">复杂度分析</h4>
<p>时间复杂度：O(klog⁡k)，其中 k 是选择的数对的数目。优先队列中最多只保存 k 个元素，每次压入新的元素队列进行调整的时间复杂度为 log⁡k，入队操作一共有 2k 次, 一共需要从队列中弹出 k 个数据。</p>
<p>空间复杂度：O(k)。优先队列中最多只保存 k 个元素。</p>
<h4 id="作者-22">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/qn8gGX/solutions/1265881/he-zui-xiao-de-k-ge-shu-dui-by-leetcode-eoce6/">https://leetcode.cn/problems/qn8gGX/solutions/1265881/he-zui-xiao-de-k-ge-shu-dui-by-leetcode-eoce6/</a></p>
]]></content>
      <tags>
        <tag>Leetcode, 堆</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:回文字符串的个数</title>
    <url>/2023/04/05/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="回文字符串的个数">回文字符串的个数</h2>
<p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<h3 id="示例-30">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; </span><br></pre></td></tr></table></figure>
<h3 id="提示-25">提示</h3>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h3 id="问题解答-30">问题解答</h3>
<p>思路：暴力法</p>
<p>遍历所有字符串，判断其是否为回文子串，在更新过程中，由于指针i和j指向字符串的两端，所以可以判断i指向的字符和j指向的字符是否一样，以此来进行简单的剪枝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Palindrome</span>(<span class="params">s1</span>):</span><br><span class="line">            <span class="keyword">return</span> s1 == s1[::-<span class="number">1</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[j] == s[i] <span class="keyword">and</span> Palindrome(s[i:j+<span class="number">1</span>]):</span><br><span class="line">         </span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">               </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>上述暴力法可以优化的地方在于：在更新左段指针i时，每更新一次都要对i和j之间的字符串进行回文判断。所以在更新时，如果当前状态与之前状态可以进行转换，那么就可以使用动态规划来解决。</p>
<p>针对这题，对于[i,j]的字符串，如果s[i]==s[j]，那么如果[i+1,j-1]是回文，那么[i,j]也是回文。所以，上述代码可以使用动态规划改进为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Palindrome</span>(<span class="params">s1</span>):</span><br><span class="line">            <span class="keyword">return</span> s1 == s1[::-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[j] == s[i] <span class="keyword">and</span> (j-i+<span class="number">1</span> &lt; <span class="number">3</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]==<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:和为k的子数组</title>
    <url>/2023/04/03/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="问题描述：和为-k-的子数组">问题描述：和为 k 的子数组</h2>
<p>给定一个整数数组和一个整数 <code>k</code> **，**请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<h4 id="示例-31">示例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:nums = [1,2,3], k = 3</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h4 id="提示-26">提示</h4>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-10^7 &lt;= k &lt;= 10^7</code></li>
</ul>
<h3 id="问题解答-31">问题解答</h3>
<h4 id="思路：枚举（暴力法）">思路：枚举（暴力法）</h4>
<p>直接遍历所有连续子数组，得到它们的和。在计算子数组之和时，可以用一种O(1)的算法，即在计算以i为开始，j为结尾的子数组的和时，sum(i,j)=sum(i,j-1)+nums[j]。</p>
<h5 id="代码-32">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span>     </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                sum_i += nums[j]</span><br><span class="line">                <span class="keyword">if</span> sum_i == k:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-10">复杂度分析</h5>
<p>时间复杂度：$O(n^2)$，其中 n 为数组的长度。枚举子数组开头和结尾需要 $O(n^2)$ 的时间，其中求和需要$O(1)$ 的时间复杂度，因此总时间复杂度为 $O(n^2)$。</p>
<p>空间复杂度：O(1)。</p>
<h4 id="思路：前缀和-哈希表优化">思路：前缀和+哈希表优化</h4>
<p>我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。</p>
<p>我们定义 $\textit{pre}[i]$为 $[0…i]$ 里所有数的和，则 $\textit{pre}[i]$ 可以由 $\textit{pre}[i-1$] 递推而来，即：$\textit{pre}[i]=\textit{pre}[i-1]+\textit{nums}[i]$</p>
<p>那么$[j…i]$ 这个子数组和为 k 这个条件我们可以转化为$pre[i]−pre[j−1]==k$</p>
<p>简单移项可得符合条件的下标 j 需要满足$pre[j−1]==pre[i]−k$</p>
<p>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时，只要统计有多少个前缀和为 $pre[i]−k$ 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1)时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。</p>
<p>需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于pre[i]的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1]的答案即可。</p>
<h5 id="代码-33">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dict_ = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        before_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_i = before_sum + nums[i]</span><br><span class="line">            before_sum = sum_i</span><br><span class="line">            <span class="keyword">if</span> dict_.__contains__(sum_i - k):<span class="comment">#判断字典是否有该键</span></span><br><span class="line">                res += dict_[sum_i - k]</span><br><span class="line">            dict_[sum_i] = dict_.get(sum_i, <span class="number">0</span>) + <span class="number">1</span> <span class="comment"># dict.get(key,0) 获取该键的值，没有就赋值为0。</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>dict的get多种用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>()</span><br><span class="line">a[<span class="number">0</span>] = a.get(<span class="number">0</span>,[])</span><br><span class="line">a[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>()</span><br><span class="line">a[<span class="number">0</span>] = a.get(<span class="number">0</span>,<span class="number">0</span>)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="作者：">作者：</h5>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/QTMn0o/solutions/1399223/he-wei-k-de-zi-shu-zu-by-leetcode-soluti-1169/">https://leetcode.cn/problems/QTMn0o/solutions/1399223/he-wei-k-de-zi-shu-zu-by-leetcode-soluti-1169/</a></p>
]]></content>
      <tags>
        <tag>Leetcode，前缀和+哈希映射</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:实现前缀树</title>
    <url>/2023/04/25/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h2 id="实现前缀树">实现前缀树</h2>
<p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果已经插入的字符串中存在<code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<h3 id="示例-32">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">inputs = [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">inputs = [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure>
<h3 id="提示-27">提示</h3>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>
</ul>
<h2 id="问题解答-32">问题解答</h2>
<h3 id="字典法">字典法</h3>
<p>基本想法就是存储一个以开头字符为键、以字符串列表为值的字典，然后再查询时根据首字母进行分组遍历</p>
<h4 id="代码-34">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.charDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a = self.charDict.get(word[<span class="number">0</span>],[])</span><br><span class="line">        a.append(word)</span><br><span class="line">        self.charDict[word[<span class="number">0</span>]] = a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.charDict.get(word[<span class="number">0</span>],[]).__contains__(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        a = self.charDict.get(prefix[<span class="number">0</span>],[])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.startWith(prefix, a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startWith</span>(<span class="params">self, str1:<span class="built_in">str</span>, strList:<span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strList:</span><br><span class="line">            l = <span class="built_in">len</span>(str1)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> s[i] != str1[i]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-11">复杂度分析</h4>
<p>时间复杂度：找到首字母相同的字符串列表的时间复杂度为O(1)，然后遍历每个字符串判断是否以该字符开头，O(mn)，m为前缀长度，n为列表长度。</p>
<p>空间复杂度：存储所有的字符串，O(n)</p>
<h3 id="前缀树——字典树">前缀树——字典树</h3>
<h4 id="思路-8">思路</h4>
<h5 id="字典树">字典树</h5>
<p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<pre><code>指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。
布尔字段 isEnd，表示该节点是否为字符串的结尾。
</code></pre>
<h5 id="插入字符串">插入字符串</h5>
<p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p>
<pre><code>子节点存在。沿着指针移动到子节点，继续处理下一个字符。
子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。
</code></pre>
<p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p>
<h5 id="查找前缀">查找前缀</h5>
<p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p>
<pre><code>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
子节点不存在。说明字典树中不包含该前缀，返回空指针。
</code></pre>
<p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</p>
<p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。</p>
<h4 id="代码-35">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.children = [<span class="literal">None</span>] * <span class="number">26</span></span><br><span class="line">        self.isEnd = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchPrefix</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="string">&quot;Trie&quot;</span>:</span><br><span class="line">        node = self</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> prefix:</span><br><span class="line">            ch = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.children[ch]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = node.children[ch]</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        node = self</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            ch = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.children[ch]:</span><br><span class="line">                node.children[ch] = Trie()</span><br><span class="line">            node = node.children[ch]</span><br><span class="line">        node.isEnd = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        node = self.searchPrefix(word)</span><br><span class="line">        <span class="keyword">return</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> node.isEnd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.searchPrefix(prefix) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-12">复杂度分析</h4>
<p>时间复杂度：初始化为 O(1)，其余操作为$ O(∣S∣)$，其中 ∣S∣是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：$O(|T|\cdot\Sigma)$，其中 ∣T∣ 为所有插入字符串的长度之和，$\Sigma$ 为字符集的大小，本题 $\Sigma=26$。</p>
<h4 id="作者-23">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/QC3q1f/solutions/1079746/shi-xian-qian-zhui-shu-by-leetcode-solut-un50/">https://leetcode.cn/problems/QC3q1f/solutions/1079746/shi-xian-qian-zhui-shu-by-leetcode-solut-un50/</a></p>
]]></content>
      <tags>
        <tag>Leetcode, 前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:最大公约数和最小公倍数</title>
    <url>/2023/04/15/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E4%B8%8B%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="最大公约数">最大公约数</h2>
<h3 id="1、更相减损术">1、更相减损术</h3>
<p>以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。</p>
<p>第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数，相当于不要第一步。</p>
<h4 id="代码-36">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GCD</span>(<span class="params">a:<span class="built_in">int</span>, b:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">while</span> a != b:</span><br><span class="line">        <span class="keyword">if</span> a &gt; b:</span><br><span class="line">            a = a - b;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = b - a;</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h3 id="2、辗转相除法（欧几里得算法）">2、辗转相除法（欧几里得算法）</h3>
<p>该算法定义如下：两个正整数A，B的最大公约数等于其中较小值与两数相除的余数的最大公约数。</p>
<h4 id="代码-37">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GCD</span>(<span class="params">a:<span class="built_in">int</span>, b:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> GCD(b, a%b)</span><br><span class="line"></span><br><span class="line">//循环</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">m:<span class="built_in">int</span>,n:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">while</span> m % n != <span class="number">0</span>:    </span><br><span class="line">        r = m % n</span><br><span class="line">        m = n</span><br><span class="line">        n = r</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
<h3 id="注：经测试在大量求大数之间公约数的情况下，循环的欧几里得算法最佳。">注：经测试在大量求大数之间公约数的情况下，循环的欧几里得算法最佳。</h3>
<h2 id="最小公倍数">最小公倍数</h2>
<h3 id="遍历法">遍历法</h3>
<p>通过遍历大数的倍数来得到最小公倍数</p>
<h4 id="代码-38">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># m &gt; n</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">m,n</span>):</span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i*m%n == <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i*m</span><br></pre></td></tr></table></figure>
<h3 id="公式法">公式法</h3>
<p>最小公倍数等于两数之积除以最大公约数。</p>
<h4 id="代码-39">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//循环</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">m:<span class="built_in">int</span>,n:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">while</span> m % n != <span class="number">0</span>:    </span><br><span class="line">            r = m % n</span><br><span class="line">            m = n</span><br><span class="line">            n = r</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> i*j/gcd(i,j)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="注意：遍历法不适合大数之间进行计算，因此优选公式法。">注意：遍历法不适合大数之间进行计算，因此优选公式法。</h3>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:数据流的第K大数值</title>
    <url>/2023/04/24/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AC%ACK%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<h2 id="数据流的第-K-大数值">数据流的第 K 大数值</h2>
<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>
<p>请实现 <code>KthLargest</code> 类：</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>
<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>
</ul>
<h3 id="示例-33">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   // return 4</span><br><span class="line">kthLargest.add(5);   // return 5</span><br><span class="line">kthLargest.add(10);  // return 5</span><br><span class="line">kthLargest.add(9);   // return 8</span><br><span class="line">kthLargest.add(4);   // return 8 </span><br></pre></td></tr></table></figure>
<h3 id="提示-28">提示</h3>
<ul>
<li>$1 &lt;= k &lt;= 10^4$</li>
<li>$0 &lt;= nums.length &lt;= 10^4$</li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
<li>$-10^4 &lt;= val &lt;= 10^4$</li>
<li>最多调用 <code>add</code> 方法 $10^4$ 次</li>
<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>
</ul>
<h2 id="问题解答-33">问题解答</h2>
<h3 id="方法一：堆">方法一：堆</h3>
<p>前K大，这样的题一般都可以用到<strong>堆</strong>这个数据结构。本题也一样，不过需要注意为了效率，这里使用了两个堆来存储。因为如果使用一个堆，每次调用add函数时，不仅弹出k次堆顶元素，还要将弹出来的数再加入堆里，此时就会超时间复杂度。</p>
<p>因此，这里使用两个堆来存，基本思路是一个堆存前K-1大数（最小堆），一个堆存其他的数（最大堆），这样每次调用add函数时，先将该数添加进最小堆里，并返回一个里面的最小值，再将该值添加进最大堆，这样堆顶就是第K大数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.heap2 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: -x, nums)) <span class="comment"># 大根堆，第k大数在第一个位置</span></span><br><span class="line">        heapq.heapify(self.heap2)</span><br><span class="line">        self.heap1 = [] <span class="comment"># 小根堆，前K-1个大的数</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            a = heapq.heappop(self.heap2)</span><br><span class="line">            self.heap1.append(-a)</span><br><span class="line">        heapq.heapify(self.heap1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        heapq.heappush(self.heap1, val)</span><br><span class="line">        a = heapq.heappop(self.heap1)</span><br><span class="line">        heapq.heappush(self.heap2, -a)</span><br><span class="line">        <span class="keyword">return</span> -self.heap2[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-13">复杂度分析</h4>
<p>这里主要分析add函数的时间复杂度，因为每次调用add涉及两次堆的push操作，一次堆的pop操作，所以复杂度为$O(max(n,K)log(max(n,K)))$</p>
<p>空间复杂度主要存两个堆，因此为O(n)，其中add函数空间复杂度为O(1)。</p>
<h3 id="方法二：优先队列">方法二：优先队列</h3>
<h4 id="思路-9">思路</h4>
<p>我们可以使用一个大小为 k 的优先队列来存储前 k 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 k 大的元素。</p>
<p>在单次插入的操作中，我们首先将元素 val 加入到优先队列中。如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 k。</p>
<h4 id="代码-40">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要导入</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="comment"># 优先队列</span></span><br><span class="line">        self.q = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 进队</span></span><br><span class="line">            <span class="keyword">if</span> self.q.qsize() &lt; k:</span><br><span class="line">                self.q.put(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 删除并进队</span></span><br><span class="line">                <span class="keyword">if</span> n &gt; self.q.queue[<span class="number">0</span>]:</span><br><span class="line">                    self.q.get()</span><br><span class="line">                    self.q.put(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 进队</span></span><br><span class="line">        <span class="keyword">if</span> self.q.qsize() &lt; self.k:</span><br><span class="line">            <span class="comment"># 进队</span></span><br><span class="line">            self.q.put(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 删除并进队</span></span><br><span class="line">            <span class="keyword">if</span> val &gt; self.q.queue[<span class="number">0</span>]:</span><br><span class="line">                self.q.get()</span><br><span class="line">                self.q.put(val)</span><br><span class="line">        <span class="keyword">return</span> self.q.queue[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="作者-24">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/jBjn9C/solutions/1041946/shu-ju-liu-de-di-k-da-shu-zhi-by-leetcod-11n3/">https://leetcode.cn/problems/jBjn9C/solutions/1041946/shu-ju-liu-de-di-k-da-shu-zhi-by-leetcod-11n3/</a></p>
]]></content>
      <tags>
        <tag>Leetcode,堆,优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:最大的异或</title>
    <url>/2023/04/26/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96/</url>
    <content><![CDATA[<h2 id="最大的异或">最大的异或</h2>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<h3 id="示例-34">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,10,5,25,2,8]</span><br><span class="line">输出：28</span><br><span class="line">解释：最大运算结果是 5 XOR 25 = 28.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]</span><br><span class="line">输出：127</span><br></pre></td></tr></table></figure>
<h3 id="提示-29">提示</h3>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^5</code></li>
<li><code>0 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
</ul>
<h2 id="问题解答-34">问题解答</h2>
<p>假设我们在数组中选择了元素 $a_i$ 和 $a_j$（$i \neq j$），使得它们达到最大的按位异或运算结果 x：$x = a_i \oplus a_j$</p>
<p>其中 $\oplus$ 表示按位异或运算。要想求出 x，一种简单的方法是使用二重循环枚举 i 和 j，但这样做的时间复杂度为 $O(n^2)$，会超出时间限制。</p>
<h3 id="思路与算法-2">思路与算法</h3>
<p>根据按位异或运算的性质，$x = a_i \oplus a_j$ 等价于 $a_j = x \oplus a_i$。我们可以根据这一变换，设计一种「从高位到低位依次确定 x 二进制表示的每一位」的方法，以此得到 x 的值。该方法的精髓在于：</p>
<p>由于数组中的元素都在 $[0,2^{31})$的范围内，那么我们可以将每一个数表示为一个长度为 31 位的二进制数（如果不满 31 位，在最高位之前补上若干个前导 0 即可）；</p>
<p>这 31 个二进制位从低位到高位依次编号为 $0, 1, \cdots, 30$。我们从最高位第 30 个二进制位开始，依次确定 x 的每一位是 0 还是 1；</p>
<p>由于我们需要找出最大的 x，因此在枚举每一位时，我们先判断 x 的这一位是否能取到 1。如果能，我们取这一位为 1，否则我们取这一位为 0。</p>
<p>「判断 x 的某一位是否能取到 1」这一步骤并不容易。下面介绍两种判断的方法。</p>
<h4 id="方法一：哈希表">方法一：哈希表</h4>
<p>假设我们已经确定了 x 最高的若干个二进制位，当前正在确定第 k 个二进制位。根据「前言」部分的分析，我们希望第 k 个二进制位能够取到 1。</p>
<p>我们用$ \textit{pre}^k(x)$表示 x 从最高位第 30 个二进制位开始，到第 k 个二进制位为止的数，那么 $a_j = x \oplus a_i$ 蕴含着：<br>
$\textit{pre}^k (a_j) = \textit{pre}^k (x) \oplus \textit{pre}^k (a_i)$</p>
<p>由于 $\textit{pre}^k(x)$ 对于我们来说是已知的，因此我们将所有的 $\textit{pre}^k (a_j)$ 放入哈希表中，随后枚举 i 并计算 $\textit{pre}^k (x) \oplus \textit{pre}^k (a_i)$。如果其出现在哈希表中，那么说明第 k 个二进制位能够取到 1，否则第 k 个二进制位只能为 0。</p>
<p>**细节：**计算 $\textit{pre}^k(x)$ 可以使用右移运算 $\texttt{&gt;&gt;}$。</p>
<p>上述步骤简化即为：从最高位开始，依次计算能否为1，能就赋值为1，不能就为0，然后考虑下一个，在计算下一个时，前面的值已经固定，此时考虑该位能不能在满足前面情况的条件下使得当前位为1。因此，隐含了位数越高，其优先级越高。</p>
<h5 id="代码-41">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaximumXOR</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(HIGH_BIT, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            seen = <span class="built_in">set</span>()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-14">复杂度分析</h5>
<p>时间复杂度：$O(n \log C)$，其中 n 是数组 nums 的长度，C 是数组中的元素范围，在本题中 $C &lt; 2^{31}$。枚举答案 x的每一个二进制位的时间复杂度为 $O(\log C)$，在每一次枚举的过程中，我们需要 O(n) 的时间进行判断，因此总时间复杂度为 $O(n \log C)$。</p>
<p>空间复杂度：O(n)，即为哈希表需要使用的空间。</p>
<h5 id="作者-25">作者</h5>
<p>力扣官方题解,链接：<a href="https://leetcode.cn/problems/ms70jA/solutions/1090301/zui-da-de-yi-huo-by-leetcode-solution-hr7m/">https://leetcode.cn/problems/ms70jA/solutions/1090301/zui-da-de-yi-huo-by-leetcode-solution-hr7m/</a></p>
<h4 id="方法二：字典树">方法二：字典树</h4>
<p>我们也可以将数组中的元素看成长度为 31 的字符串，字符串中只包含 0 和 1。如果我们将字符串放入字典树中，那么在字典树中查询一个字符串的过程，恰好就是从高位开始确定每一个二进制位的过程。字典树的具体逻辑以及实现可以参考「208. 实现 Trie（前缀树）的官方题解」，这里我们只说明如何使用字典树解决本题。</p>
<p>根据 $x = a_j \oplus a_i$，我们枚举 $a_i$，并将 $a_0, a_1, \cdots, a_{i-1}$ 作为 $a_j$ 放入字典树中，希望找出使得 x 达到最大值的 $a_j$。</p>
<p>如何求出 x 呢？我们可以从字典树的根节点开始进行遍历，遍历的「参照对象」为 $a_i$。在遍历的过程中，我们根据 $a_i$ 的第 x 个二进制位是 0 还是 1，确定我们应当走向哪个子节点以继续遍历。假设我们当前遍历到了第 k 个二进制位：</p>
<p>如果 $a_i$ 的第 k 个二进制位为 0，那么我们应当往表示 1 的子节点走，这样 $0 \oplus 1 = 1$，可以使得 x 的第 k 个二进制位为 1。如果不存在表示 1 的子节点，那么我们只能往表示 0 的子节点走，x 的第 k 个二进制位为 0；</p>
<p>如果 $a_i$ 的第 k 个二进制位为 1，那么我们应当往表示 0 的子节点走，这样 $1 \oplus 0 = 1$，可以使得 x 的第 k 个二进制位为 1。如果不存在表示 0 的子节点，那么我们只能往表示 1 的子节点走，x 的第 k 个二进制位为 0。</p>
<p>当遍历完所有的 31 个二进制位后，我们也就得到了 $a_i$ 可以通过异或运算得到的最大 x。这样一来，如果我们枚举了所有的 $a_i$，也就得到了最终的答案。</p>
<p>**细节：**由于字典树中的每个节点最多只有两个子节点，分别表示 0 和 1，因此本题中的字典树是一棵二叉树。在设计字典树的数据结构时，我们可以令左子节点 left 表示 0，右子节点 right 表示 1。</p>
<p>上述步骤简述为：依次遍历所有数字，在遍历过程中，比较当前数与已遍历过的数字之间能异或得到的最大值，方法是通过前缀树。</p>
<h5 id="代码-42">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaximumXOR</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num: <span class="built_in">int</span></span>):</span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(HIGH_BIT, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(HIGH_BIT, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = <span class="built_in">max</span>(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-15">复杂度分析</h5>
<p>时间复杂度：O(nlog⁡C)，其中 n 是数组 nums 的长度，C 是数组中的元素范围，在本题中 $C &lt; 2^{31}$。我们需要将 $a_0$ 到$a_{n-2}$ 加入字典树中，并且需要以 $a_1$ 到 $a_{n-1}$ 作为「参照对象」在字典树上进行遍历，每一项操作的单次时间复杂度为 O(log⁡C)，因此总时间复杂度为 O(nlog⁡C)。</p>
<p>空间复杂度：O(nlog⁡C)。每一个元素在字典树中需要使用 O(log⁡C) 的空间，因此总空间复杂度为 O(nlog⁡C)。</p>
<h5 id="作者-26">作者</h5>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/ms70jA/solutions/1090301/zui-da-de-yi-huo-by-leetcode-solution-hr7m/">https://leetcode.cn/problems/ms70jA/solutions/1090301/zui-da-de-yi-huo-by-leetcode-solution-hr7m/</a></p>
]]></content>
      <tags>
        <tag>Leetcode,哈希表,前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:直方图最大矩形面积</title>
    <url>/2023/04/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="问题描述：直方图最大矩形面积">问题描述：直方图最大矩形面积</h2>
<p>给定非负整数数组 <code>heights</code> ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h3 id="示例-35">示例</h3>
<p>1、</p>
<p><img src="/2023/04/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/histogram.jpg" alt="histogram"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure>
<p>2、</p>
<p><img src="/2023/04/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/histogram-1.jpg" alt="histogram-1"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>
<h3 id="提示-30">提示</h3>
<ul>
<li><code>1 &lt;= heights.length &lt;=10^5</code></li>
<li><code>0 &lt;= heights[i] &lt;= 10^4</code></li>
</ul>
<h2 id="问题解答-35">问题解答</h2>
<p>暴力法，直接遍历左右柱子的位置，其最大矩形面积就是该范围内柱子的个数*范围内的最小值。</p>
<p>暴力法简单，但由于复杂度达到了$O(N^2)$，因此可以优化，利用单调栈来降低复杂度。</p>
<h3 id="单调栈">单调栈</h3>
<p>我们用一个具体的例子 [6,7,5,2,4,5,9,3] 来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。</p>
<p>1、我们枚举 6，因为栈为空，所以 6 左侧的柱子是「哨兵」，位置为 -1。随后我们将 6 入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[6(0)]。（这里括号内的数字表示柱子在原数组中的位置）</span><br></pre></td></tr></table></figure>
<p>2、我们枚举 7，由于 6&lt;7，因此不会移除栈顶元素，所以 7 左侧的柱子是 6，位置为 0。随后我们将 7 入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[6(0), 7(1)]</span><br></pre></td></tr></table></figure>
<p>3、我们枚举 5，由于$7\geq 5$，因此移除栈顶元素 7。同样地，$6 \geq 5$，再移除栈顶元素 6。此时栈为空，所以 5 左侧的柱子是「哨兵」，位置为 −1。随后我们将 5 入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[5(2)]</span><br></pre></td></tr></table></figure>
<p>4、接下来的枚举过程也大同小异。我们枚举 2，移除栈顶元素 5，得到 2 左侧的柱子是「哨兵」，位置为 −1。将 2入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2(3)]</span><br></pre></td></tr></table></figure>
<p>5、我们枚举 4，5 和 9，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 2，4 和 5，位置分别为 3，4 和 5。将它们入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2(3), 4(4), 5(5), 9(6)]</span><br></pre></td></tr></table></figure>
<p>6、我们枚举 3，依次移除栈顶元素 9，5 和 4，得到 3 左侧的柱子是 2，位置为 3。将 3 入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2(3), 3(7)]</span><br></pre></td></tr></table></figure>
<p>7、这样以来，我们得到它们左侧的柱子编号分别为[−1,0,−1,−1,3,4,5,3]。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 [2,2,3,8,7,7,7,8]，这里我们将位置 8 看作「哨兵」。</p>
<p>在得到了左右两侧的柱子之后，我们就可以计算出每根柱子对应的左右边界，并求出答案了。</p>
<h4 id="代码-43">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            right[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> n</span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-16">复杂度分析</h4>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h4 id="作者-27">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/0ynMMM/solutions/1398942/zhi-fang-tu-zui-da-ju-xing-mian-ji-by-le-pcyu/">https://leetcode.cn/problems/0ynMMM/solutions/1398942/zhi-fang-tu-zui-da-ju-xing-mian-ji-by-le-pcyu/</a></p>
]]></content>
      <tags>
        <tag>Leetcode,单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题:矩阵中最大的矩形</title>
    <url>/2023/04/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="问题描述：矩阵中最大的矩形">问题描述：矩阵中最大的矩形</h2>
<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>matrix</code> ，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<p>**注意：**此题 <code>matrix</code> 输入格式为一维 <code>01</code> 字符串数组。</p>
<h3 id="示例-36">示例</h3>
<p>1、</p>
<p><img src="/2023/04/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/maximal.jpg" alt="maximal"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [&quot;10100&quot;,&quot;10111&quot;,&quot;11111&quot;,&quot;10010&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>3、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [&quot;0&quot;]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>4、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [&quot;1&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>5、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [&quot;00&quot;]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="问题解答-36">问题解答</h2>
<h3 id="使用柱状图的单调栈方法">使用柱状图的单调栈方法</h3>
<p>最原始地，我们可以列举每个可能的矩形。我们枚举矩形所有可能的左上角坐标和右下角坐标，并检查该矩形是否符合要求。然而该方法的时间复杂度过高，不能通过所有的测试用例，因此我们必须寻找其他方法。</p>
<p>我们首先计算出矩阵的每个元素的左边连续 1 的数量，使用二维数组 left记录，其中 left[i][j] 为矩阵第 i行第 j 列元素的左边连续 1 的数量。</p>
<p>如图所示，对于每一列我们可以生成这样的直方图，然后该题就转换为求如图所示的直方图中最大面积（1的个数等于面积）</p>
<p><img src="/2023/04/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/3_1.png" alt="3_1"></p>
<h4 id="代码-44">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            n = <span class="built_in">len</span>(heights)</span><br><span class="line">            left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">            mono_stack = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                    mono_stack.pop()</span><br><span class="line">                left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                mono_stack.append(i)</span><br><span class="line">            </span><br><span class="line">            mono_stack = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                    mono_stack.pop()</span><br><span class="line">                right[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> n</span><br><span class="line">                mono_stack.append(i)</span><br><span class="line">            </span><br><span class="line">            ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">                    </span><br><span class="line">        row = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        col = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        h = [<span class="number">0</span>]*row</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    h[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    h[i] = <span class="number">0</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, largestRectangleArea(h))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-17">复杂度分析</h4>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。计算 left 矩阵需要 O(mn)的时间；对每一列应用柱状图算法需要 O(m)的时间，一共需要 O(mn) 的时间。</p>
<p>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。我们分配了一个与给定矩阵等大的数组，用于存储每个元素的左边连续 1 的数量。</p>
<h4 id="作者-28">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/PLYXKQ/solutions/1399094/ju-zhen-zhong-zui-da-de-ju-xing-by-leetc-pjc7/">https://leetcode.cn/problems/PLYXKQ/solutions/1399094/ju-zhen-zhong-zui-da-de-ju-xing-by-leetc-pjc7/</a></p>
]]></content>
      <tags>
        <tag>Leetcode,单调栈，直方图最大面积</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题：不用加减乘除做加法</title>
    <url>/2023/03/16/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="不用加减乘除做加法">不用加减乘除做加法</h2>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<h3 id="示例-37">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h3 id="提示-31">提示</h3>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<h2 id="问题解答-37">问题解答</h2>
<h3 id="思路-10">思路</h3>
<p>我们使用位运算来处理这个问题。</p>
<p>首先，考虑两个二进制位相加的四种情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 + 0 = 0</span><br><span class="line">0 + 1 = 1</span><br><span class="line">1 + 0 = 1</span><br><span class="line">1 + 1 = 0 (进位)</span><br></pre></td></tr></table></figure>
<p>可以发现，对于整数 a 和 b：</p>
<pre><code>在不考虑进位的情况下，其无进位加法结果为 a⊕b

而所有需要进位的位为 a &amp; b，进位后的进位结果为 (a &amp; b) &lt;&lt; 1。
</code></pre>
<p>于是，我们可以将整数 a 和 b的和，拆分为 a 和 b 的<strong>无进位加法结果</strong>与<strong>进位结果</strong>的和。因为每一次拆分都可以让需要进位的最低位至少左移一位，又因为 a 和 b 可以取到负数，所以我们最多需要 log⁡(max_int)次拆分即可完成运算。</p>
<p>因为有符号整数用补码来表示，所以以上算法也可以推广到 0 和负数。</p>
<h3 id="代码-45">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MASK1 = <span class="number">4294967296</span>  <span class="comment"># 2^32</span></span><br><span class="line">MASK2 = <span class="number">2147483648</span>  <span class="comment"># 2^31</span></span><br><span class="line">MASK3 = <span class="number">2147483647</span>  <span class="comment"># 2^31-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a %= MASK1</span><br><span class="line">        b %= MASK1</span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            carry = ((a &amp; b) &lt;&lt; <span class="number">1</span>) % MASK1</span><br><span class="line">            a = (a ^ b) % MASK1</span><br><span class="line">            b = carry</span><br><span class="line">        <span class="keyword">if</span> a &amp; MASK2:  <span class="comment"># 负数</span></span><br><span class="line">            <span class="keyword">return</span> ~((a ^ MASK2) ^ MASK3)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 正数</span></span><br><span class="line">            <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h3 id="作者-29">作者</h3>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solutions/1790724/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-by-0a30/">https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solutions/1790724/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-by-0a30/</a></p>
<h2 id="数组中数字出现的次数">数组中数字出现的次数</h2>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了<strong>两次</strong>。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h3 id="示例-38">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>
<h3 id="限制">限制</h3>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10000</code></li>
</ul>
<h2 id="问题解答-38">问题解答</h2>
<p>对于只有一个数字不同时，全员进行异或操作即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。</p>
<p>那么这一方法如何扩展到找出两个出现一次的数字呢？</p>
<p>如果我们可以把所有数字分成两组，使得：</p>
<pre><code>两个只出现一次的数字在不同的组中；

相同的数字会被分到相同的组中。
</code></pre>
<p>那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。</p>
<p>该分组方法可以选择为：以异或结果中为1的某一位进行划分。因为存在两个不同的数字，这时异或的结果就是两者的异或结果。选取为1的某一位进行划分，那么由于相同数字相同位一样，那么肯定可以分到同一组。同时由于该位为1，所以两个存在一次的数字在该位的值不一样，一定被分到两组。</p>
<h3 id="算法">算法</h3>
<p>先对所有数字进行一次异或，得到两个出现一次的数字的异或值。</p>
<p>在异或结果中找到任意为 111 的位。</p>
<p>根据这一位对所有的数字进行分组。</p>
<p>在每个组内进行异或操作，得到两个数字。</p>
<h3 id="代码-46">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ret = functools.reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)//求所有值的异或结果，可用<span class="keyword">for</span>循环替代</span><br><span class="line">        div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> div &amp; ret == <span class="number">0</span>:</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; div:</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure>
<h3 id="作者-30">作者</h3>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solutions/222307/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-by-leetcode/">https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solutions/222307/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-by-leetcode/</a></p>
<h2 id="数组中数字出现的次数-II">数组中数字出现的次数 II</h2>
<p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<h3 id="示例-39">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="限制：">限制：</h3>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
<h2 id="问题解答-39">问题解答</h2>
<p>如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。 因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<p><img src="/2023/03/16/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/image-20230316111605502.png" alt="image-20230316111605502"></p>
<h3 id="代码-47">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="comment">//建立一个长度为 32 的数组 counts，通过以上方法可记录所有数字的各二进制位的1的出现次数。</span></span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">		<span class="comment">//使用与运算，可获取二进制数字num的最右一位n^1：n^1=num&amp;i</span></span><br><span class="line">        <span class="comment">//配合无符号右移操作，可获取num所有位的值（即n^1~ n^32）: num=num&gt;&gt;&gt;1 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将counts各元素对3求余，则结果为 “只出现一次的数字” 的各二进制位。</span></span><br><span class="line">        <span class="comment">//利用左移操作和或运算 ，可将counts数组中各二进位的值恢复到数字res上（循环区间是 i∈[0,31]）。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：实际上，只需要修改求余数值 m ，即可实现解决 <strong>除了一个数字以外，其余数字都出现 m 次</strong> 的通用问题。</p>
<h3 id="作者-31">作者</h3>
<p>Krahets，链接：<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solutions/215895/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/">https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solutions/215895/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题：二分查找变形</title>
    <url>/2023/04/03/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="二分查找">二分查找</h2>
<p>在有序的数组里寻找数时，还可以寻找等于该数的最右边位置和最左边位置。（java版本）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums = &#123;......&#125;;<span class="comment">//升序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 只查找，不限位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; targt)&#123;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在的情况就是 j &lt; i</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; i)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* 查找target的最左边位置 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= targt)&#123;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束状态有两种，存在该数时，j指向该数的最左边位置-1，i=j+1</span></span><br><span class="line">    <span class="comment">// 所以不存在的情况判断</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找target的最右边位置 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= targt)&#123;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束状态有两种，存在该数时，i指向该数的最右边位置+1，j=i-1</span></span><br><span class="line">    <span class="comment">// 所以不存在的情况判断</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode, 二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题：圆圈中最后剩下的数字</title>
    <url>/2023/03/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="圆圈中最后剩下的数字">圆圈中最后剩下的数字</h2>
<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<h3 id="示例-40">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h3 id="限制：-2">限制：</h3>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<h2 id="问题解答-40">问题解答</h2>
<p>该问题由于m、n较大，所以暴力法会很浪费时间和空间。</p>
<p>这里需要思考：如果我们知道对于一个长度 <code>n - 1</code> 的序列，留下的是第几个元素，那么我们能否可以由此计算出长度为 <code>n</code> 的序列的答案。答案是可以的：</p>
<p>我们将上述问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。</p>
<p>首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p>
<p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 f(n, m) = (m % n + x) % n = (m + x) % n。</p>
<p><img src="/2023/03/17/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/fig1.gif" alt></p>
<h3 id="代码-48">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastRemaining</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            f = (m + f) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<h3 id="作者-32">作者</h3>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solutions/176636/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solutions/176636/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题：数值的整数次幂</title>
    <url>/2023/03/15/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82/</url>
    <content><![CDATA[<h2 id="数值的整数次方">数值的整数次方</h2>
<h3 id="问题描述-26">问题描述</h3>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即$x^n$）。不得使用库函数，同时不需要考虑大数问题。</p>
<h4 id="示例-41">示例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<h4 id="提示-32">提示</h4>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-2^31 &lt;= n &lt;= 2^31-1</code></li>
<li><code>-10^4 &lt;= x^n &lt;= 10^4</code></li>
</ul>
<h3 id="问题解答-41">问题解答</h3>
<h4 id="方法一：快速幂-递归">方法一：快速幂 + 递归</h4>
<p>将$x^n$看成$(x^{\lfloor \frac{n}{2} \rfloor})^2$，如果n为偶数，则两者是相等的，如果是奇数则需要在乘以一个x才相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pow</span>(<span class="params">a, m</span>):</span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            y = <span class="built_in">pow</span>(a, <span class="built_in">int</span>(m/<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> y * y <span class="keyword">if</span> m % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> y * y * a</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> / <span class="built_in">pow</span>(x, n)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：这里y*y不可替换为y**2，y**2会报数值溢出错误。</p>
<h4 id="作者-33">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solutions/1398793/shu-zhi-de-zheng-shu-ci-fang-by-leetcode-yoqr/">https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solutions/1398793/shu-zhi-de-zheng-shu-ci-fang-by-leetcode-yoqr/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题：把字符串转换成整数</title>
    <url>/2023/03/20/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="把字符串转换成整数">把字符串转换成整数</h2>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>**说明：**假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [$−2^{31}$, $2^{31} − 1$]。如果数值超过这个范围，请返回  INT_MAX ($2^{31} − 1$) 或 INT_MIN ($−2^{31}$,) 。</p>
<h3 id="示例-42">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−2^31) 。</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-42">问题解答</h3>
<h4 id="方法：自动机">方法：自动机</h4>
<h5 id="思路-11">思路</h5>
<p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p>
<p>我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。</p>
<h5 id="算法-2">算法</h5>
<p>本题可以建立如下图所示的自动机：</p>
<p><img src="/2023/03/20/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/fig1.png" alt></p>
<p>我们也可以用下面的表格来表示这个自动机（状态转移表）：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>’ ’</th>
<th>+/-</th>
<th>number</th>
<th>other</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">start</td>
<td>start</td>
<td>signed</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td style="text-align:center">signed</td>
<td>end</td>
<td>end</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td style="text-align:center">in_number</td>
<td>end</td>
<td>end</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td style="text-align:center">end</td>
<td>end</td>
<td>end</td>
<td>end</td>
<td>end</td>
</tr>
</tbody>
</table>
<p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可。</p>
<p>另外自动机也需要记录当前已经输入的数字，只要在 s’ 为 in_number 时，更新我们输入的数字，即可最终得到输入的数字。</p>
<h4 id="代码-49">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="string">&#x27;start&#x27;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">&#x27;start&#x27;</span>: [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;signed&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;in_number&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;end&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_col</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;in_number&#x27;</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            self.ans = <span class="built_in">min</span>(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&#x27;signed&#x27;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strToInt</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure>
<h4 id="作者-34">作者</h4>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solutions/1398809/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-sh-epeo/">https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solutions/1398809/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-sh-epeo/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之难题：滑动窗口的最大值</title>
    <url>/2023/03/21/Leetcode%E4%B9%8B%E9%9A%BE%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="滑动窗口的最大值">滑动窗口的最大值</h2>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<h3 id="示例-43">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<h3 id="提示-33">提示</h3>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组 <strong>不为空</strong> 的情况下，<code>1 ≤ k ≤ nums.length</code>。</p>
<h3 id="问题解答-43">问题解答</h3>
<h4 id="方法一：优先队列">方法一：优先队列</h4>
<p>对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p>
<p>对于本题而言，初始时，我们将数组 nums 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p>
<p>我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组 (num,index)，表示元素 num 在数组中的下标为 index。</p>
<h5 id="代码-50">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 注意 Python 默认的优先队列是小根堆</span></span><br><span class="line">        q = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line"></span><br><span class="line">        ans = [-q[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            heapq.heappush(q, (-nums[i], i))</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:</span><br><span class="line">                heapq.heappop(q)</span><br><span class="line">            ans.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h5 id="复杂度">复杂度</h5>
<p>时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log⁡n)，因此总时间复杂度为 O(nlog⁡n)。</p>
<p>空间复杂度：O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用。</p>
<p>作者：力扣官方题解<br>
链接：<a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/">https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/</a><br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h5 id="作者-35">作者</h5>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/">https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/</a></p>
<h4 id="方法二：单调队列">方法二：单调队列</h4>
<p>由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 i 和 j，其中 i 在 j 的左侧（i&lt;j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]），那么会发生什么呢？</p>
<p>当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中，这是 i 在 j 的左侧所保证的。因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将 nums[i] 永久地移除。</p>
<p>因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 i，后者为 j，就对应了上面所说的情况，即 nums[i] 会被移除，这就产生了矛盾。</p>
<p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p>
<p>由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。</p>
<p>为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。</p>
<h5 id="代码-51">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line"></span><br><span class="line">        ans = [nums[q[<span class="number">0</span>]]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            ans.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-18">复杂度分析</h5>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)。</p>
<p>空间复杂度：O(k)。与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素，因此队列使用的空间为 O(k)。</p>
<h5 id="作者-36">作者</h5>
<p>力扣官方题解，链接：<a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/">https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2023/03/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="关系型数据库">关系型数据库</h3>
<p>数据库：存储数据的仓库，本质是信息管理系统。</p>
<p>为什么使用数据库？提供了数据的统一管理，集中访问；使用方便，降低了应用开发的门槛。</p>
<p>简单描述：利用二维表的形式  来存储数据，用表和表之间的关系保存数据之间的关系的数据库。</p>
<h3 id="SQL语言">SQL语言</h3>
<p>结构化查询语言，关系型数据库通用语言。一种非过程性语言（操作者仅需要给出自己想要的结果）。SQL具有查询、操纵、定义和控制关系型数据库的四方面功能。学习SQL语句依次主要分为以下三部分，每部分主要围绕增删改查四方面进行。</p>
<h4 id="SQL中常见的数据类型">SQL中常见的数据类型</h4>
<h5 id="字符串型">字符串型</h5>
<p><strong>VARCHAR</strong>：变长的字符串，需要在声明字段时指定能存储的最大字符数，真实占用的空间取决于存入的字符数。能包含的数据大小：0~65536字节。</p>
<p><strong>CHAR</strong>：定长字符串，需要在声明字段时指定固定字符数。能包含的数据大小：0~255字节</p>
<h5 id="大数据类型">大数据类型</h5>
<p><strong>BLOB</strong>：(二进制大对象)。大二进制类型，主要存图片、音频、视频等数据以二进制的形式存入数据库。最大为4GB。</p>
<p><strong>TEXT</strong>：大文本，保持大量的字符数据，最大为4GB。TEXT为MySQL的方言，其他数据库叫<strong>CLOB</strong>类型。</p>
<h5 id="数值型">数值型</h5>
<p><strong>TINYINT</strong>：占用1个字节</p>
<p><strong>SMALLINT</strong>：占用两个字节</p>
<p><strong>INT</strong>：占用4个字节</p>
<p><strong>BIGINT</strong>：占用8个字节</p>
<p><strong>FLOAT</strong>：占用4个字节</p>
<p><strong>DOUBLE</strong>：占用8个字节</p>
<h5 id="逻辑型">逻辑型</h5>
<p><strong>BIT</strong>：位类型，可以存储指定位的值，可以指定位的个数，默认为1，此时只能存0、1，可相当于布尔型。</p>
<h5 id="日期型">日期型</h5>
<p><strong>DATE</strong>：日期，如2023-03-16</p>
<p><strong>TIME</strong>：时间，如21:53:12</p>
<p><strong>DATETIME</strong>：日期时间，如2023-03-16 21:53:12，占用8个字节</p>
<p><strong>TIMESTAMP</strong>：时间戳，占用四个字节</p>
<p><strong>DATETIME</strong>和<strong>TIMESTAMP</strong>的区别：1、DATETIME和TIMESTAMP显示的结果是一样的，都是“YYYY-MM-DD HH:MM:SS”的格式；2、DATETIME支持的范围是“1000-01-01 00:00:00”到“9999-12-31 23:59:59”。TIMESTAMP的显示范围是“1970-01-01 00:00:00”到2037年，且其实际的存储值为1970年到当前时间的毫秒数。3、在建表时，列为TIMESTAMP的日期类型可以设置一个默认值（默认值：当前时间），而DATETIME不行。4、在更新表时，可以设置TIMESTAMP类型的列自动更新时间为当前时间。</p>
<h4 id="字段约束">字段约束</h4>
<h5 id="1、主键约束">1、主键约束</h5>
<p>通常每张表都会有一个字段或多个字段联合起来唯一标识表记录这样的字段称为这张表的主键。我们可以为这样的字段增加主键约束。主键约束要求字段<strong>必须不能为空</strong>且<strong>值必须唯一</strong>。</p>
<p>增加主键约束：<strong>PRIMARY KEY</strong></p>
<p>可以在定义主键时指定主键的自动增长auto_increment，这样主键就不需要人为的维护，在新增记录时不需要指定主键的值，数据库会自动维护一个计数器，每次计数器的值+ 1后作为主键，保证主键的唯一性。</p>
<h5 id="2、唯一约束">2、唯一约束</h5>
<p>如果需要指定某个字段的值不能重复，可以为该字段指定唯一约束，该字段可存在NULL，且可以插入多个NULL值。因为对于MySQL来说，null和任意值的比较结果都为False</p>
<p>增加唯一约束：<strong>UNIQUE</strong></p>
<h5 id="3、非空约束">3、非空约束</h5>
<p>如果需要指定某个字段的值不能为空，可以为该字段指定非空约束</p>
<p>增加非空约束：<strong>NOT NULL</strong></p>
<h5 id="4、外键约束">4、外键约束</h5>
<p>**什么是外键？**外键是一种约束，一个表的一个字段可以设为外键关联另一张表的主键字段，外键约束是指限定该表该外键字段的值，必须是另一张表中主键字段已经存在的值。 1)向A表中插入数据时，外键字段的值会做校验，必须是B表中主键字段存在的值。 2)在B表中做删除操作时，如果A表中有数据关联了该主键值，则不能进行删除。</p>
<p>外键作用：维护数据的完整性和一致性</p>
<p>添加外键：foreign key(本表的字段) references 其他表(字段)</p>
<p>**注意：**本表的外键只能引用另一张表的主键；</p>
<h6 id="建表时增加外键">建表时增加外键</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	dept_id <span class="type">int</span>, </span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h6 id="修改方式增加外键">修改方式增加外键</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_name <span class="keyword">ADD</span> [<span class="keyword">constraint</span> 真正的外键名称] <span class="keyword">FOREIGN</span> KEY(col_name1) <span class="keyword">REFERENCES</span> tab_name2(col_name2) [<span class="keyword">on</span> <span class="keyword">delete</span> restrict][<span class="keyword">on</span> <span class="keyword">update</span> restrict];</span><br></pre></td></tr></table></figure>
<p><strong>constraint 真正的外键名称</strong>：用于指定真正的外键名称。如果不指定外键的名称，mysql会自动为你创建一个外键名称。可通过show create table_name查询;</p>
<p>**RESTRICT：**只要本表格里面有指向主表的数据，在主表里面就无法删除相关记录。</p>
<p><strong>CASCADE：</strong>（级联，不安全）如果在foreign key所指向的那个表里面删除一条记录，那么在此表里面的跟那个key一样的所有记录都会一同删掉。</p>
<p>注意：在企业中，由于外键的存在会影响数据库的并发，一般是通过代码实现外键的逻辑，而不是指定外键。</p>
<h4 id="1、数据库操作相关语句">1、数据库操作相关语句</h4>
<h5 id="创建数据库">创建数据库</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb1;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果不存在再创建</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> mydb1;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建一个使用gbk字符集的mydb2数据库,<span class="keyword">sql</span>里面UTF<span class="number">-8</span>：utf8</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb2 <span class="type">CHARACTER</span> <span class="keyword">SET</span> gbk;</span><br></pre></td></tr></table></figure>
<h5 id="删除数据库">删除数据库</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>删除数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除数据库,有就删</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> db_name;</span><br></pre></td></tr></table></figure>
<h5 id="更改数据库">更改数据库</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改数据库的字符集</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE db_name <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8; </span><br></pre></td></tr></table></figure>
<h5 id="查看数据库">查看数据库</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查看所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查看某一数据库创建语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE db_name;</span><br></pre></td></tr></table></figure>
<h5 id="选择数据库">选择数据库</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>选择数据库</span><br><span class="line">use db_name;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查看当前选择的库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure>
<h4 id="2、表操作相关语句">2、表操作相关语句</h4>
<h5 id="新增表">新增表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(field1 datatype [字段约束], field2 datatype [字段约束]);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>field：列名 datatype：列的类型</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>建表时可以指定字符集和校对规则，一般不用，和数据库保存一致。</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">ename <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">gender <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">birthday <span class="type">DATE</span>,</span><br><span class="line">entry_date <span class="type">DATE</span>,</span><br><span class="line">job <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">salary <span class="type">SMALLINT</span>,</span><br><span class="line">resume TEXT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="删除表">删除表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tb_name</span><br></pre></td></tr></table></figure>
<h5 id="修改表">修改表</h5>
<p><strong>增加列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">ADD</span> (col_name datatype...);</span><br></pre></td></tr></table></figure>
<p><strong>修改列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname MODIFY (col_name datatype...);</span><br></pre></td></tr></table></figure>
<p><strong>删除列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">DROP</span> (col_name);</span><br></pre></td></tr></table></figure>
<p><strong>修改表名</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> old_tabname RENAME <span class="keyword">TO</span> new_tabname;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">or</span></span><br><span class="line">RENAME <span class="keyword">TABLE</span> old_tabname <span class="keyword">TO</span> new_tabname;</span><br></pre></td></tr></table></figure>
<p><strong>修改列名</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname CHANGE old_col_name new_col_name datatype;</span><br></pre></td></tr></table></figure>
<p><strong>修改列的顺序</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname MODIFY col_name1 datatype AFTER col_name2;</span><br></pre></td></tr></table></figure>
<p><strong>修改表的字符集</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="type">CHARACTER</span> <span class="keyword">SET</span> character_name;</span><br></pre></td></tr></table></figure>
<h5 id="查询表">查询表</h5>
<p><strong>查看表结构</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> employee;</span><br></pre></td></tr></table></figure>
<p><strong>查看当前所有表</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;<span class="operator">/</span><span class="operator">/</span>针对当前库</span><br></pre></td></tr></table></figure>
<p><strong>查看当前数据库表建表语句</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_Name;</span><br></pre></td></tr></table></figure>
<h4 id="3、表中记录操作的相关语句">3、表中记录操作的相关语句</h4>
<h5 id="增加表记录">增加表记录</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tabname (<span class="keyword">column</span>,...) <span class="keyword">VALUES</span> (<span class="keyword">value</span>,...);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>多条插入</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tabname (<span class="keyword">column</span>,...) <span class="keyword">VALUES</span> (<span class="keyword">value</span>,...)，(<span class="keyword">values</span>,...);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：1、插入的数据应与字段的数据类型相同。2、数据的大小应在列的规定范围内。3、在va1ues中列出的数据位置必须与被加入的列的排列位置相对应。4、字符串和日期格式的数据要用<strong>单引号</strong>引起来。5、如果要插入所有字段可以省写列，直接按表中字段顺序写值列表。6、自增字段可以赋值NULL，以实现自增赋值。</p>
<h5 id="删除表数据">删除表数据</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tab_name [<span class="keyword">WHERE</span> ...];</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：1、where用来筛选要别除的记录，如果不使用where子句，将删除表中所有数据。 2、delete语句不能删除某一列的值（可使用update)。3、 delete语句仅删除记录，不删除表本身。如要删除表，使用drop table语句。4、TRUNCATE TABLE tab_name语句也可以删除表中数据，它和delete有所不同。delete是条条删除记录，不对表结构进行处理，不会重置AUTO_INCREMENT的计数器，truncate是摧毁整表再重建相同结构的表，truncate效率更高，但会重置AUTO_INCREMENT的计数器。</p>
<h5 id="修改表数据">修改表数据</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tab_name <span class="keyword">SET</span> colname<span class="operator">=</span>expr,... [<span class="keyword">WHERE</span> ...];</span><br></pre></td></tr></table></figure>
<h5 id="查询表记录">查询表记录</h5>
<h6 id="基本查询：">基本查询：</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">*</span><span class="operator">|</span>&#123;column1 <span class="keyword">as</span> new_col,column2,...&#125; <span class="keyword">FROM</span> tab_name;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：select指定查询哪些列的数据。 column指定列名。*号代表查询所有列。 from指定查询哪张表。 DISTINCT可选，指显示结果时，是否剔除重复数据。as 对结果的列名起个别名。</p>
<p>ifnull(colname,0)：对NULL值的处理，这里演示的是将NULL值转化为0。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,IFNULL(english,<span class="number">0</span>) <span class="keyword">FROM</span> exam;</span><br></pre></td></tr></table></figure>
<h6 id="使用where子句的查询：">使用where子句的查询：</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="operator">|</span>列名 <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>
<p>where子句的作用：查询指定行。</p>
<p><img src="/2023/03/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="uTools_1679320190846"></p>
<p><strong>注意</strong>：WHERE子句中不能使用列的别名和聚合函数，因为where的解析顺序在字段声明的前面。WHERE子句可以用表的别名，因为from的执行顺序在where的前面。in里面可以接子查询。</p>
<h6 id="排序查询：">排序查询：</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1,column2,... <span class="keyword">FROM</span> tab_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> column3 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>ASC：升序（默认）；DESC：降序。ORDER BY：里面可以用别名。</p>
<p><strong>ORDER BY 子句在WHERE子句的后面</strong>：因为先筛选再排序（效率高），而不是先排序后筛选（效率低）。</p>
<h6 id="聚合函数">聚合函数</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> f(col_name)... <span class="keyword">FROM</span> tab_name [<span class="keyword">WHERE</span> ...];</span><br></pre></td></tr></table></figure>
<p>f代表的有：1、求符合条件的记录中指定列的记录数：COUNT()，COUNT(*)会统计包括NULL值的条数，COUNT(colname)仅统计该列不为NULL值的条数；2、求符合条件的记录中指定列的和值：SUM()；3、求符合条件的记录中指定列的平均值：AVG()；4、求符合条件的记录中指定列的最大值：MAX()；5、求符合条件的记录中指定列的最小值：MIN()；除COUNT外，其他聚合函数均不对<strong>null</strong>值进行统计。</p>
<h6 id="分组查询">分组查询</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, column3,... <span class="keyword">FROM</span> tab_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> column4 <span class="keyword">HAVING</span> ...</span><br></pre></td></tr></table></figure>
<p>GROUP BY的运行顺序是；先根据设定的字段对数据分成多个子集，然后对每个子集运行一次其他操作。</p>
<p>**注意：**WHERE子句和HAVING子句都可以进行过滤，但是使用场景有所不同：WHERE子句对分组之前的数据进行过滤，不能使用聚合函数和别名；HAVING子句对分组之后的数据进行过滤，可以使用聚合函数和别名；使用WHERE子句的地方一般都可以用HAVING替代，但是使用HAVING的地方一般不能用WHERE替代。</p>
<h4 id="多表设计">多表设计</h4>
<h5 id="一对一">一对一</h5>
<p>对于一对一的关系，可以在任意一方表中添加列，保存另外一张表的主键来保存两张表之间的对应关系.</p>
<p><img src="/2023/03/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="image-20230322205433340"></p>
<h5 id="一对多">一对多</h5>
<p>对于一对多的关系，可以在多的一方添加列，保存一的那方主键作为外键，来保存两张表之间的对应关系。</p>
<p><img src="/2023/03/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="image-20230322205715671"></p>
<h5 id="多对多">多对多</h5>
<p>对于多对多的关系，我们可以建一张第三方的表，分别保存两张表的主键，通过这种方式来保存多对多的关系</p>
<p><img src="/2023/03/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" alt="image-20230322205956076"></p>
<h4 id="多表查询">多表查询</h4>
<h5 id="多次查询">多次查询</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>暴力法</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;科技部&#x27;</span>); </span><br></pre></td></tr></table></figure>
<h5 id="笛卡尔积查询">笛卡尔积查询</h5>
<p>又称逗号连接，表和表之间使用逗号连接，过滤条件用WHERE子句给定。（少用）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>两表的笛卡尔</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_name1, tab_name2;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>多表笛卡尔查询</span><br><span class="line"><span class="keyword">SELECT</span> emp.id, emp.name <span class="keyword">FROM</span> emp, dept <span class="keyword">WHERE</span> emp.dept_id <span class="operator">=</span> dept.id <span class="keyword">and</span> dept.name <span class="operator">=</span> <span class="string">&#x27;科技部&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="内连接查询">内连接查询</h5>
<p>查询左边表有且右边表也有的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1 [<span class="keyword">inner</span>] <span class="keyword">join</span> tb2 <span class="keyword">on</span> tb1.id <span class="operator">=</span> tb2.id;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询例子</span><br><span class="line"><span class="keyword">SELECT</span> e.id, e.name, d.name <span class="keyword">as</span> dept <span class="keyword">FROM</span> emp <span class="keyword">as</span> e <span class="keyword">JOIN</span> dept <span class="keyword">as</span> d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id ;</span><br></pre></td></tr></table></figure>
<h5 id="左外连接">左外连接</h5>
<p>在内连接的基础上增加左边表有而右边表没有（NULL）的记录</p>
<p>代码：left join 或者 left outer join</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询例子</span><br><span class="line"><span class="keyword">SELECT</span> emp.id, emp.name, dept.name <span class="keyword">as</span> dept <span class="keyword">FROM</span> dept <span class="keyword">left</span> <span class="keyword">JOIN</span> emp <span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id ;</span><br></pre></td></tr></table></figure>
<h5 id="右外连接">右外连接</h5>
<p>在内连接的基础上增加右边表有而左边表没有的记录</p>
<p>代码：right join 或者 right outer join</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询例子</span><br><span class="line"><span class="keyword">SELECT</span> emp.id, emp.name, dept.name <span class="keyword">as</span> dept <span class="keyword">FROM</span> emp <span class="keyword">right</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 跟左外连接的例子结果一致</span><br></pre></td></tr></table></figure>
<h5 id="全外连接">全外连接</h5>
<p>在内连接的基础上增加右边表有而左边表没有的记录，以及左边表有而右边表没有的记录（FULL JOIN）</p>
<p>**注意：**MySQL不支持全连接，可以使用UNION关键字模拟全外连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.id, emp.name, dept.name <span class="keyword">as</span> dept <span class="keyword">FROM</span> emp <span class="keyword">left</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id ;</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.id, emp.name, dept.name <span class="keyword">as</span> dept <span class="keyword">FROM</span> emp <span class="keyword">right</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python连接MySQL数据库</title>
    <url>/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1>01 MySQL安装和设置</h1>
<p>这里不详细介绍，可以参考B站视频：<a href="https://www.bilibili.com/video/BV12b411K7Zu?spm_id_from=333.337.search-card.all.click">MySQL_基础+高级篇- 数据库 -sql -mysql教程_mysql视频_mysql入门_尚硅谷</a></p>
<h1>02 Python操作MySQL</h1>
<p>目前，关于Python操作数据库主要有以下几种方法：</p>
<ul>
<li><strong>MySQLdb的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQLdb是用于Python连接MySQL数据库的接口，它实现了Python数据库API规范V2.0，基于MySQL C API上建立的，目前只支持Python2.x。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>PyMySQL的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PyMySQL是Python中用于连接MySQL服务器的一个库，它支持Python3.x，是一个纯Python写的MySQL客户端，它的目标是替代MySQLdb。PyMySQL在MIT许可下发布。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>mysql.connector 的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</span><br><span class="line"></span><br><span class="line">目前，有两个 MySQL 驱动：</span><br><span class="line"></span><br><span class="line">1. mysql-connector-python：是 MySQL 官方的纯 Python 驱动</span><br><span class="line">2. MySQL-python ：是封装了 MySQL C驱动的 Python 驱动</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SQLAlchemy的使用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是是一种ORM（Object-Relational Mapping）框架，将关系数据库的表结构映射到对象上，隐藏了数据库操作背后的细节，简化了数据操作。</span><br></pre></td></tr></table></figure>
<h2 id="2-1在Python3-X上安装MySQL驱动">2.1在Python3.X上安装MySQL驱动</h2>
<p>这里选择PyMySQL作为主要研究对象。安装方法和验证是否安装成功的步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install pymysql</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br></pre></td></tr></table></figure>
<p>如果没有产生错误，则表明安装成功。</p>
<p>如果这里因网络原因没有安装成功，可以选择到网址 <a href="https://pypi.org/">https://pypi.org/</a> 里面搜索pymysql下载（需要魔法）。</p>
<h2 id="2-2-建立数据库连接"><strong>2.2 建立数据库连接</strong></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;连接数据库，创建游标&#x27;&#x27;&#x27;</span></span><br><span class="line">connection = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, <span class="comment"># IP地址，我这里用的本地地址</span></span><br><span class="line">                    port=<span class="number">3306</span>, <span class="comment"># 端口号</span></span><br><span class="line">                    user=<span class="string">&#x27;root&#x27;</span>, <span class="comment"># 用户名</span></span><br><span class="line">                    passwd=<span class="string">&#x27;123456&#x27;</span>, <span class="comment"># 密码</span></span><br><span class="line">                    charset = <span class="string">&#x27;utf8&#x27;</span> <span class="comment"># 编码方式</span></span><br><span class="line">                    )</span><br><span class="line">cursor = connection.cursor()</span><br></pre></td></tr></table></figure>
<h2 id="2-3-创建数据库"><strong>2.3 创建数据库</strong></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&#x27;create database if not exists s;&#x27;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<h2 id="2-4-创建数据表">2.4 创建数据表</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;create table stu(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(sql) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p><strong>cursor()：表示游标</strong></p>
<p><strong>execute()：是执行语句</strong></p>
<p><strong>commit()：是提交事务，执行语句后有这个才能对数据库进行真正的操作，也可以在创建连接时，设置autocommit = True</strong>。即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connection = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, <span class="comment"># IP地址，我这里用的本地地址</span></span><br><span class="line">                    port=<span class="number">3306</span>, <span class="comment"># 端口号</span></span><br><span class="line">                    user=<span class="string">&#x27;root&#x27;</span>, <span class="comment"># 用户名</span></span><br><span class="line">                    passwd=<span class="string">&#x27;123456&#x27;</span>, <span class="comment"># 密码</span></span><br><span class="line">                    charset = <span class="string">&#x27;utf8&#x27;</span>, <span class="comment"># 编码方式</span></span><br><span class="line">                    autocommit = <span class="literal">True</span></span><br><span class="line">                    )</span><br></pre></td></tr></table></figure>
<h2 id="2-5-增、改、删、查">2.5 增、改、删、查</h2>
<h3 id="2-5-1-增">2.5.1 增</h3>
<p>在cutomers表中插入数据用的是&quot;INSERT INTO&quot;语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert1 = <span class="string">&quot;INSERT INTO stu(id,name,class, age) Values(1,&#x27;ludong&#x27;,1,10);&quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(insert1) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>上面这种方式是在插入的时候，值是常量的情况，当值为变量的时候，可以采用下面这种方式，即多输入一个列表或元组来作为值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert2 = <span class="string">&quot;INSERT INTO stu(id,name,class, age) Values(%s,%s,%s,%s)&quot;</span></span><br><span class="line">values = [<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">1</span>,<span class="number">10</span>]</span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(insert2, values) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>除了用一条条用execute( )插入之外，我们还可以用executemany（）的方式批量插入，也就是val中包含的是一个元组列表，包含我们想要插入的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert2 = <span class="string">&quot;INSERT INTO stu(id,name,class, age) Values(%s,%s,%s,%s)&quot;</span></span><br><span class="line">values = [[<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">2</span>,<span class="number">11</span>]]</span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.executemany(insert2, values) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>需要注意的事是：如果数据表格有更新，那么必须用到commit()语句，否则在workbench是看不到插入的数据的。执行以上代码后，回到数据库 s 下面的 stu 表格，我们可以看到最终的结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/1.png" alt="image-20220608194453767"></p>
<h3 id="2-5-2-改">2.5.2 改</h3>
<p>在 stu 表中更改数据用的是&quot;UPDATE&quot;语句。例如，我们将最后一条“zhangsan”的年龄改成10：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update = <span class="string">&quot; UPDATE stu SET age=10 WHERE name=&#x27;zhangsan&#x27; &quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(update) </span><br><span class="line">connection.commit() </span><br></pre></td></tr></table></figure>
<p>执行代码，回到表格我们可以看到结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/2.png" alt="image-20220608194827301"></p>
<h3 id="2-5-3-删">2.5.3 删</h3>
<p>关于删，删除表格用的是“DROP TABLE ”语句。这里为了方便只写下代码，不执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete = <span class="string">&quot; DROP TABLE stu &quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(update) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>当需要删除一条数据记录时候，用到的语句是“DELETE  FROM”语句。例如：想在 stu 这个表格当中，删除重复的那两条数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete = <span class="string">&quot; DELETE FROM stu WHERE name=&#x27;lisi&#x27; &quot;</span></span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>) </span><br><span class="line">cursor.execute(delete) </span><br><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>
<p>执行代码，回到 stu 我们可以看到结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/3.png" alt="image-20220608195255618"></p>
<h3 id="2-5-4-查">2.5.4 查</h3>
<ul>
<li><strong>普通查询</strong></li>
</ul>
<p>普通查询数据用的是SELECT语句。例如：需要查询 stu 的所有信息，并且进行打印输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql=<span class="string">&quot;SELECT * FROM stu&quot;</span> </span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>)  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchall()     <span class="comment"># fetchall() 获取所有记录  </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line"> 	<span class="built_in">print</span>(x)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">sql=<span class="string">&quot;SELECT * FROM stu&quot;</span> </span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>)  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchone()     <span class="comment"># fetchone() 获取一条记录  </span></span><br><span class="line"><span class="built_in">print</span>(myresult)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">sql=<span class="string">&quot;SELECT * FROM stu&quot;</span> </span><br><span class="line">cursor.execute(<span class="string">&quot;use s;&quot;</span>)  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchmany(size=<span class="number">2</span>)     <span class="comment"># fetchmany() 获取部分记录  </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line"> 	<span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>得到最终结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/4.png" alt="image-20220608201425200"></p>
<p>值得注意的是：**fetchall()**表示的是获得所有记录；**fetchone()**表示只获取一条数据；**fetchmany(size=2)**表示获取两条记录。</p>
<ul>
<li><strong>限定条件查找</strong></li>
</ul>
<p>为了获取指定条件下的查找结果，我们可以使用where语句。例如：需要在查询 stu 的所有信息基础上，输出 class 为 2 的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql=<span class="string">&quot;SELECT * FROM stu WHERE class = 2&quot;</span>  </span><br><span class="line">mycursor.execute(sql)  </span><br><span class="line">myresult = mycursor.fetchall()     <span class="comment"># fetchall() 获取所有记录  </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">  <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>最终得到的结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/5.png" alt="image-20220608202545352"></p>
<ul>
<li><strong>通配符查找</strong></li>
</ul>
<p>有时候为了进行模糊查询，可以匹配通配符，通过“LIKE”来进行查找：</p>
<p><strong>百分号 （%）</strong>: 代表零个、一个或多个数字或字符；</p>
<p><strong>下划线 （_）</strong>: 代表一个单一的数字或字符。</p>
<p>例如：查出所有名字中含有do的记录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql=<span class="string">f&quot; SELECT * FROM stu WHERE name LIKE &#x27;%do%&#x27; &quot;</span>  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">myresult = cursor.fetchall()      </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">  <span class="built_in">print</span>(x) </span><br></pre></td></tr></table></figure>
<p>执行代码，我们得到的结果如下：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/6.png" alt="image-20220608202753988"></p>
<p>值得注意的是：但是使用Like查询时，即使我们在代码输入的是“do”，执行过程中也会将含有“Do”、“DO”、“dO”的记录同样输出，即用LIKE匹配通配符对大小写不敏感。为了区分大小写，可以用“GLOB”进行查询。详情见：<a href="https://blog.csdn.net/diaokua8472/article/details/101640342">【SQL】glob 和 like 的区别</a></p>
<ul>
<li><strong>排序</strong></li>
</ul>
<p>查询结果排序可以使用 ORDER BY 语句，默认的排序方式为升序，如果要设置降序排序，可以设置关键字 DESC。例如：我们要按照年龄对 stu 进行升序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升序</span></span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM stu ORDER BY age&quot;</span> </span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line"><span class="comment"># sql = &quot;SELECT * FROM stu ORDER BY age DESC&quot; </span></span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">result=cursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>执行代码，得到的结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/7.png" alt="image-20220608203453718"></p>
<ul>
<li><strong>LIMIT</strong></li>
</ul>
<p>当数据库数量非常大的时候，为了限制查询的数据量，可以采用&quot;LIMIT&quot;语句来指定，比如我们希望在 stu 表中找出年龄最高的三个人：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT * FROM stu ORDER BY age DESC LIMIT 2&quot;</span>  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">result=cursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>执行代码，得到结果为：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/7.png" alt="image-20220608203453718"></p>
<ul>
<li><strong>二次筛选</strong></li>
</ul>
<p>有时候我们在进行一次筛选后，还需要设定一个筛选条件进行二次筛选，我们就可以采用“HAVING”语句。例如：我们希望统计在年龄处于20-30（不包括20岁，但是包括30岁）的人当中，选择薪资大于5000的消费者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二次过滤  </span></span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM stu WHERE age=10 HAVING class=1 &quot;</span>  </span><br><span class="line">cursor.execute(sql)  </span><br><span class="line">result=cursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br><span class="line">con.commit()  </span><br></pre></td></tr></table></figure>
<p>执行代码后，得到的结果如下：</p>
<p><img src="/2022/06/07/Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/8.png" alt="img"></p>
<h2 id="3-5-分组聚合">3.5 分组聚合</h2>
<p>在数据库中，分组常用的语句为“GROUP BY”语句，聚合函数，通常是配合分组进行使用，在数据库中常用的聚合函数为：</p>
<ol>
<li><strong>COUNT（*）</strong>：表示计算总行数，括号可以写*和字段名字</li>
<li><strong>MAX（column）</strong>：表示求此列的最大值</li>
<li><strong>MIN（column）</strong>：表示求此列的最小值</li>
<li><strong>SUM（column）</strong>：表示求此列的和</li>
<li><strong>AVG（column）</strong>：表示求此列的平均值</li>
</ol>
<ul>
<li><strong>从customers表中统计出男女薪资总和</strong></li>
</ul>
<p>以sex为类别进行GROUP BY 分组，加上WHERE来做条件判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#统计出男女的薪水总数  </span></span><br><span class="line">sql = <span class="string">&quot;SELECT sex,sum(sl) FROM customers GROUP BY sex&quot;</span>  </span><br><span class="line">mycursor.execute(sql)  </span><br><span class="line">myresult=mycursor.fetchall()  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:  </span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br></pre></td></tr></table></figure>
<p>最终结果为：</p>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC1kMTdkODdjNTg0OTcyZWE2P2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<ul>
<li><strong>从customers表中，按性别进行分组，统计出年龄在20-30的消费者的薪资，并且按照薪资高低进行排序</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照性别进行分组，统计出年龄在20-30岁的消费者的薪资  </span><br><span class="line">sql = &quot;SELECT sex,sum(sl) FROM customers WHERE age&gt;20 and age&lt;=30 GROUP BY sex ORDER BY sl&quot;  </span><br><span class="line">mycursor.execute(sql)  </span><br><span class="line">myresult=mycursor.fetchall()  </span><br><span class="line">for x in myresult:  </span><br><span class="line">    print(x)  </span><br></pre></td></tr></table></figure>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC01NGVjN2RlYWExNzkwOTIwP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<p>值得注意的是：本例是以sex为类别进行GROUP BY 分组，加上WHERE来做条件判断，加上ORDER BY 排序，但是GROUP BY 的位置必须要在WHERE 之后，在ORDER BY 之前。</p>
<h2 id="3-6-分批量读取和处理数据">3.6 分批量读取和处理数据</h2>
<p>程序运行的时候，数据都是在内存中的，但是有时候如果数据量太大，内存会装不下，这个时候我们就需要分批从数据库去读取数据，然后再处理，等到处理完了之后，再去读取。比如：我们要从customers当中分批读取和处理薪资大于8000的消费者，并将其存入另一张表中。我们的做法是先新建一个表，然后从数据库当中读取3个，并且将读取的这3个进行处理，处理完读取的这三个后，再去数据库重新读取三个，直到数据库的数据读完为止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分批读取并且处理将薪资大于8000的消费者的记录存到另一张表中  </span></span><br><span class="line"><span class="comment"># 创建一个临时表   </span></span><br><span class="line">tmpName = \<span class="string">&#x27;cust_tmp\&#x27;  </span></span><br><span class="line"><span class="string">dropTable(mycursor, tmpName)    </span></span><br><span class="line"><span class="string">mycursor.execute(&quot;CREATE TABLE cust_tmp(id INT AUTO_INCREMENT PRIMARY KEY,\</span></span><br><span class="line"><span class="string">                               name VARCHAR(255), address VARCHAR(255), \  </span></span><br><span class="line"><span class="string">                               sex VARCHAR(225), age INT(10), sl INT(10))&quot;)</span></span><br><span class="line"><span class="string">ins = con.cursor(buffered=True)  </span></span><br><span class="line"><span class="string">if tableExists(mycursor, tableName):  </span></span><br><span class="line"><span class="string">    print(&quot;process table: %s&quot;, tableName)  </span></span><br><span class="line"><span class="string">    # 查询表里的记录  </span></span><br><span class="line"><span class="string">    sql = &quot;SELECT * FROM customers WHERE address is not null&quot;  </span></span><br><span class="line"><span class="string">    mycursor.execute(sql)  </span></span><br><span class="line"><span class="string">    # 每次处理 batchsize 条记录，直到所有查询结果处理完  </span></span><br><span class="line"><span class="string">    batchsize = 3  </span></span><br><span class="line"><span class="string">    readsize = batchsize  </span></span><br><span class="line"><span class="string">    while readsize == batchsize:  </span></span><br><span class="line"><span class="string">        print(&quot;before batch&quot;)  </span></span><br><span class="line"><span class="string">        myresult = mycursor.fetchmany(size=batchsize)  </span></span><br><span class="line"><span class="string">        for x in myresult:  </span></span><br><span class="line"><span class="string">            if x[5]&gt;8000:  </span></span><br><span class="line"><span class="string">                ins.execute(&quot;INSERT INTO&quot;+tmpName+&quot;(id,name,address,sex,age,sl) VALUES (%s, %s,%s, %s,%s,%s)&quot;, x)  </span></span><br><span class="line"><span class="string">                print(x)  </span></span><br><span class="line"><span class="string">        readsize = len(myresult)  </span></span><br><span class="line"><span class="string">else:  </span></span><br><span class="line"><span class="string">    print(&quot;table: does not exists&quot;, tableName)  </span></span><br><span class="line"><span class="string">con.commit()  </span></span><br><span class="line"><span class="string">con.close()  </span></span><br></pre></td></tr></table></figure>
<p>我们回到workbench找到这个新建的表格cust_tmp，我们可以发现薪资大于8000的消费者都被记录上了：</p>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC05NThhZDE1MGJiNGMxMjRiP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<p>执行代码，我们可以看到处理的过程如下：</p>
<p>在第一批读取的三条记录中，只有两条是满足薪资大于8000的要求，第二批读取的三条记录中，只有一条满足薪资大于8000的要求，而在第三批读取的三条记录中，没有任何记录是满足薪资大于8000的要求，当没有记录可以读的时候，程序即停止。</p>
<p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC0xYTRlNGRiZDZiNmEwZDkyP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" alt="img"></p>
<h2 id="通用类">通用类</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mycursor</span>(<span class="params">db_name=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;连接数据库，创建游标&#x27;&#x27;&#x27;</span></span><br><span class="line">    config = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;host&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;port&#x27;</span>, <span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">                      [<span class="string">&#x27;192.168.137.155&#x27;</span>, <span class="string">&#x27;shanger&#x27;</span>, <span class="number">3306</span>, <span class="string">&#x27;0123&#x27;</span>]))</span><br><span class="line">    config.update(database=db_name)</span><br><span class="line">    connection = pymysql.connect(**config)</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    <span class="keyword">return</span> cursor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">use</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;切换数据库，返回游标&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> mycursor(db_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_database</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;新建数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;create database if not exists <span class="subst">&#123;db_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_table</span>(<span class="params">tbl_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;新建数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;create table if not exists <span class="subst">&#123;tbl_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drop_database</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;删除数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;drop database if exists <span class="subst">&#123;db_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drop_table</span>(<span class="params">tbl_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;删除数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">f&#x27;drop table if exists <span class="subst">&#123;tbl_name&#125;</span>;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">sql</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;以数据框形式返回查询据结果&#x27;&#x27;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    data = cursor.fetchall()  <span class="comment"># 以元组形式返回查询数据</span></span><br><span class="line">    header = [t[<span class="number">0</span>] <span class="keyword">for</span> t <span class="keyword">in</span> cursor.description]</span><br><span class="line">    df = pd.DataFrame(<span class="built_in">list</span>(data), columns=header)  <span class="comment"># pd.DataFrem 对列表具有更好的兼容性</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_databases</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;查看服务器上的所有数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">&#x27;show databases;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> query(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_database</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;查看当前数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">&#x27;select database();&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> query(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_tables</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;查看当前数据库中所有的表&#x27;&#x27;&#x27;</span></span><br><span class="line">    sql = <span class="string">&#x27;show tables;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> query(sql)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>动态时滞算法</title>
    <url>/2022/09/15/%E5%8A%A8%E6%80%81%E6%97%B6%E6%BB%9E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>动态时滞算法</h1>
<h2 id="E-DTA">E-DTA</h2>
<p>在工业过程中，在交互通常动态的同时，多元相关性始终可用。因此，相关变量之间的时间延迟通常揭示动态特征。图1演示了静态时间延迟和动态时间延迟，其中TD代表两个变量之间的时间序列，时间代表采样时间。可以清楚地看出，静态和动态的时间延迟有显着差异。</p>
<p><img src="/2022/09/15/%E5%8A%A8%E6%80%81%E6%97%B6%E6%BB%9E%E7%AE%97%E6%B3%95/1.png" alt="image-20220915151238538"></p>
<p>考虑到大多数工业过程是多元，非线性和动态特征的，因此开发了具有弹性窗口（E-DTA）的动态时间延迟分析，以提取动态时间延迟。该算法是对传统互相关函数（CCF）方法的改进，该方法计算基于滑动弹性时间窗口和相似性相关性分析的变量之间的动态时间延迟。</p>
<p>相似性分析是时间序列挖掘中使用的一种流行方法，从统计学上计算时间序列之间的相似性，以确定时间序列之间的距离或时间延迟信息。考虑到X和Y是两个定义的时间序列，$U_x$和$U_y$是n个观察值的平均值，$R_x$和$R_y$是标准偏差，整体时间段为m，时间序列之间的相似性相关系数可以表达为：<br>
$$<br>
P_{xy}(k)=\frac{E[(X_i-U_x)(Y_{i+k}-U_y)]}{R_xR_y},m=-n+1,\dots,n-1<br>
$$<br>
在$P_{xy}$为最大绝对值的情况下，相应的m成为时间序列之间的静态时间延迟。静态时间延迟信息可以为后续的动态时间延迟提取提供支持。考虑到$S_X$和$S_Y$是样本的标准偏差，通过计算样本期望，获得数据段的相似性系数，如下式所示：<br>
$$<br>
\hat{P}<em>{xy(i)}=\frac{1}{n_k}\sum</em>{j=i}^{i+n_k}\frac{(X_{j-r}-U_{x(j)})(Y_{j+k-r}-U_{y(j+k)})}{S_{x(j)}S_{y(j+k)}}</p>
<p>\</p>
<p>i=0,1,2,\dots,n;\space k=0,1,2,\dots,\lambda_k<br>
$$<br>
这里滑动宽度 $\lambda_k$ 是光滑窗口的移动范围，$i$ 表示时间点。将观察宽度 $n_k$ 设置为平滑窗口的大小，$r$ 为观察窗口的观察半径 $r = n_k /2$，窗口的移动范围是在判断当前数据趋势和过程条件后确定的。通常，我们具有$\lambda_k=W_1 * m$，其中$W_1\in[1，8]$，这是经验系数，$m$ 是与整体数据段相对应的静态时间延迟。时间窗口滑动的示意图如图2所示。</p>
<p><img src="/2022/09/15/%E5%8A%A8%E6%80%81%E6%97%B6%E6%BB%9E%E7%AE%97%E6%B3%95/2.png" alt="image-20220915152729032"></p>
<p>$P\in[-1，1]$用作变量之间的相关系数，其正值和负值揭示了变量之间相关性的正和负。通过观察相关系数的最大值$P_{xy(i)}^{max}$和最小值$P_{xy(i)}^{min}$，变量X和Y的延迟$\lambda(i)$ 可以通过以下方程确定：<br>
$$<br>
\lambda(i)=\begin{cases}<br>
k_i^{max}, if \space P_{xy(i)}^{max} \geq -P_{xy(i)}^{min} \<br>
k_i^{min}, if \space P_{xy(i)}^{max} &lt; -P_{xy(i)}^{min}<br>
\end{cases}<br>
$$<br>
动态时间延迟提取算法的主要问题是观察窗口 $n_k$ 的大小，其扩展应参考以下观测值：（1）由于局部强大干扰（正面的总时间延迟方向），反向时间延迟是否太大相似（2）相关变量数据之间相关系数的绝对值是否大于总体数据下的变量。考虑到当前数据的总体相关系数，滑动宽度 $\lambda_k$ 和先验知识，将相对较小的值分配为$n_k$通过反复试验的初始值，以促进后续扩展。算法流程图如图3所示。</p>
<p><img src="/2022/09/15/%E5%8A%A8%E6%80%81%E6%97%B6%E6%BB%9E%E7%AE%97%E6%B3%95/3.png" alt="uTools_1663225552548"></p>
<h2 id="MGRA-滑动灰色关联分析">MGRA(滑动灰色关联分析)</h2>
<p>考虑到工业生产过程是一个复杂的非线性动态过程具有时间延迟特性，为了完全捕捉系统的动态学特性，在建模时，需考虑输入输出时序信号匹配对模型预测值的影响。滑动灰色关联分析(MGRA)是一种有效的时间滞后参数确定方法，以滑动时阶的方式构建比较时序数据集，并通过计算各时序变化曲线的相似性，判断变量之间的关联程度。取得相关性最大的时阶为最佳时滞阶数。算法具体描述如下:</p>
<ol>
<li>
<p>确定反应系统特征的 T+1 维参考数列$A_i$ 与影响系统特性的比较数列 B 做无量纲化处理：<br>
$$<br>
\begin{cases}<br>
A_i = { A_i(t),A_i(t\pm1),\dots,A_i \pm t) } \<br>
B={ B(1),B(2),B(3),\dots,B(t) }<br>
\end{cases}(i=1,2,\dots,n) \tag{1}<br>
$$<br>
其中，n 为参考序列数目，T 为最大时滞</p>
</li>
<li>
<p>计算数列的关联系数<br>
$$<br>
r(A_i(t),B(t)) = \frac{\min_{i}\min_{t}|B(t)-A_i(t\pm\tau)|+\rho\min_{i}\min_{t}|B(t)-A_i(t\pm\tau)|}{|B(t)-A_i(t\pm\tau)|+\rho|B(t)-A_i(t\pm\tau)|}\tag{2}<br>
$$</p>
</li>
<li>
<p>计算关联度结果<br>
$$<br>
r_i=\frac{1}{T}\sum_{t=1}^{L}r(A_i(t\pm\tau),B(t)) \tag{3}<br>
$$<br>
其中，L 为序列的长度。</p>
</li>
</ol>
<p>图为滑动灰色关联分析流程图。首先对输入时间序列 $x_i(i\in n)$，扩充表示为<br>
$T_{max}+1$维的数列集，可表示为 $x_i(t\pm\tau)$，其中时延参数$\tau=0,1,\dots,T_{max}$，$T_{max}$ 为最大时延参数, n 表示热工变量维度变量。然后选取 $x_i(t\pm\tau )$为比较时间序列，输出变量 y 作为参考时间序列，最后根据式2计算出关联系数 $r(x_i(t\pm\tau ),y(t))$关联系数，然后根据式3求得关联度$$r_i=\frac{1}{T_{max}}\sum_{t=1}^{L}r(x_i(t\pm\tau),y(t)) \tag{3}$$。关联度最大时的时延参数为最佳时滞阶数。</p>
<p><img src="/2022/09/15/%E5%8A%A8%E6%80%81%E6%97%B6%E6%BB%9E%E7%AE%97%E6%B3%95/4.png" alt="image-20220915174726412"></p>
<h2 id="区别">区别</h2>
<p>MGRA是主要用于预处理阶段确定各个变量的时滞，跟输入时刻无关；E-DTA则是在输入窗口序列进行操作，然后确定各个变量在这个时刻的时滞。</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL之窗口函数</title>
    <url>/2023/03/28/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="窗口函数">窗口函数</h2>
<p>MySQL 8.0支持窗口函数(Window Function)，也称分析函数。</p>
<p>窗口函数与分组聚合函数类似，但是每一行数据都生成一个结果。</p>
<p>常见的聚合函数都可以用作窗口函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	<span class="built_in">avg</span>(profit) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country) <span class="keyword">AS</span> country_profit </span><br><span class="line">	</span><br><span class="line"><span class="keyword">FROM</span> `sales` </span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country, <span class="keyword">year</span>, product ,profit;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/28/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" alt="image-20230328153341393"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">func_name(<span class="operator">&lt;</span><span class="keyword">parameter</span><span class="operator">&gt;</span>) </span><br><span class="line"><span class="keyword">OVER</span>(</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>part_by_condition<span class="operator">&gt;</span>] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br><span class="line">[<span class="keyword">rows</span> <span class="keyword">between</span> ?? <span class="keyword">And</span> ??]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>current row：当前要处理的数据行</p>
<p>M preceding：当前行的第上M行数据（处理过）</p>
<p>N following：当前行的第下N行数据（未处理）</p>
<p>unbounded preceding ： 当前分区的第一行</p>
<p>unbounded following： 当前分区的最后一行</p>
<p><img src="/2023/03/28/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" alt="image-20230328153703497"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 移动平均，每个窗口内计算在该行前面的所有行的平均值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit, <span class="built_in">AVG</span>(profit) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit <span class="keyword">rows</span> unbounded preceding) <span class="keyword">AS</span> country_profit <span class="keyword">FROM</span> `sales`;</span><br><span class="line"></span><br><span class="line"># 移动平均，每次计算前面一行加后面一行，以及自身的平均值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit, <span class="built_in">AVG</span>(profit) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="number">1</span> following) <span class="keyword">AS</span> country_profit <span class="keyword">FROM</span> `sales`;</span><br></pre></td></tr></table></figure>
<p>多窗口时，可以简写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit,</span><br><span class="line">	<span class="built_in">first_value</span>(profit) <span class="keyword">over</span> w <span class="keyword">as</span> <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">	<span class="built_in">last_value</span>(profit) <span class="keyword">over</span> w <span class="keyword">as</span> <span class="string">&#x27;last&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">as</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit <span class="keyword">ROWS</span> UNBOUNDED PRECEDING)</span><br></pre></td></tr></table></figure>
<h3 id="专用窗口函数">专用窗口函数</h3>
<p><img src="/2023/03/28/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" alt="19d42616e2114fd392e65291546d5e1a"></p>
<h4 id="序号函数">序号函数</h4>
<p>**ROW_NUMBER()：**查出指定条件后的进行排名，条件相同排名也不相同，排名连续。 说明：这个函数不需要考虑是否并列，即使根据<a href="https://so.csdn.net/so/search?q=%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2&amp;spm=1001.2101.3001.7020">条件查询</a>出来的数值相同也会进行连续排序。类似于排序完后的行数，而不是排名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit) <span class="keyword">AS</span> country_profit </span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> `sales` </span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country, <span class="keyword">year</span>, product ,profit;</span><br></pre></td></tr></table></figure>
<p>**RANK()：**查出指定条件后的进行排名，条件相同排名相同，排名间断不连续。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit) <span class="keyword">AS</span> country_profit </span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> `sales` </span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country, <span class="keyword">year</span>, product ,profit;</span><br></pre></td></tr></table></figure>
<p>**DENSE_RANK()：**查出指定条件后的进行排名，条件相同排名相同，排名间断不连续。 说明：和rank() over 的作用相同，区别在于dense_rank() over 排名是密集连续的。即，rank() over结果可能是<code>1,1,3,3,5,6,7</code>，而dense_rank() over的结果是<code>1,1,2,2,3,4,5</code>。</p>
<h4 id="分布函数">分布函数</h4>
<p>**PERCENT_RANK()：**按公式<code>(rank-1)/(rows-1)</code>进行计算，rank是该行rank()的结果。rows表示窗口的总行。该函数的窗口无法通过ROWS更改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit,</span><br><span class="line">	<span class="built_in">first_value</span>(profit) <span class="keyword">over</span> w <span class="keyword">as</span> <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">	<span class="built_in">last_value</span>(profit) <span class="keyword">over</span> w <span class="keyword">as</span> <span class="string">&#x27;last&#x27;</span>,</span><br><span class="line">	<span class="built_in">PERCENT_RANK</span>() <span class="keyword">over</span> w <span class="keyword">as</span> p</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">as</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit)</span><br></pre></td></tr></table></figure>
<p>**CUME_DIST()：**获取<code>组内小于等于当前rank值的行数/分组内总行数</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit,</span><br><span class="line">	<span class="built_in">first_value</span>(profit) <span class="keyword">over</span> w <span class="keyword">as</span> <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">	<span class="built_in">last_value</span>(profit) <span class="keyword">over</span> w <span class="keyword">as</span> <span class="string">&#x27;last&#x27;</span>,</span><br><span class="line">	<span class="built_in">CUME_DIST</span>() <span class="keyword">over</span> w <span class="keyword">as</span> p</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">as</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit <span class="keyword">ROWS</span> UNBOUNDED PRECEDING)</span><br></pre></td></tr></table></figure>
<h4 id="头尾函数">头尾函数</h4>
<p>**FIRST_VALUE()：**返回某字段第一个值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	<span class="built_in">FIRST_VALUE</span>(product) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit) <span class="keyword">AS</span> country_profit </span><br><span class="line">	</span><br><span class="line"><span class="keyword">FROM</span> `sales` </span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> profit;</span><br></pre></td></tr></table></figure>
<p>**LAST_VALUE()：**返回某字段最后一个值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	<span class="built_in">LAST_VALUE</span>(product) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit) <span class="keyword">AS</span> country_profit </span><br><span class="line">	</span><br><span class="line"><span class="keyword">FROM</span> `sales` </span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> profit;</span><br></pre></td></tr></table></figure>
<h4 id="前后函数">前后函数</h4>
<p>**LEAD()：**返回当前窗口下，某字段当前值的下几个值（following）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	<span class="built_in">LEAD</span>(profit,<span class="number">1</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit) <span class="keyword">AS</span> country_profit </span><br><span class="line">	</span><br><span class="line"><span class="keyword">FROM</span> `sales`;</span><br></pre></td></tr></table></figure>
<p>**LAG()：**返回当前窗口下，某字段当前值的上几个值（preceding）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">year</span>, country, product, profit, </span><br><span class="line">	<span class="built_in">LAG</span>(profit,<span class="number">1</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit) <span class="keyword">AS</span> country_profit </span><br><span class="line">	</span><br><span class="line"><span class="keyword">FROM</span> `sales`;</span><br></pre></td></tr></table></figure>
<h4 id="其他函数">其他函数</h4>
<p>**NTH_VALUE()：**返回窗口内某字段第n个的值，没有就返回null。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit,</span><br><span class="line">	<span class="built_in">NTH_VALUE</span>(product,<span class="number">2</span>) <span class="keyword">OVER</span> w <span class="keyword">as</span> <span class="string">&#x27;np&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">as</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country  <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="number">1</span> following);</span><br></pre></td></tr></table></figure>
<p>**NTILE()：**将有序数据分为n个桶，记录等级数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, country, product, profit,</span><br><span class="line">	<span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> w <span class="keyword">as</span> <span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">as</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> country  <span class="keyword">ORDER</span> <span class="keyword">BY</span> profit <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">0</span> FOLLOWING);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Tranformer模型细节及pytorch实现</title>
    <url>/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="Transformer模型的基本结构">Transformer模型的基本结构</h2>
<p>下图是Transformer用于中英文翻译的整体结构：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>从上图可以看到Transformer由编码器和解码器两个部分组成，Encoder和Decoder均可以有多个进行堆叠。</p>
<h3 id="工作流程">工作流程</h3>
<p>以上面的中英文翻译为例来介绍Transformer的工作流程：</p>
<p><strong>第一步</strong>：获取输入句子的每一个单词的表示向量 X。向量X由该单词的 Embedding和单词位置的 Embedding 相加得到。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/2.png" alt></p>
<p>注：想了解词嵌入的可以去看文档：<a href="https://wenku.baidu.com/view/891928f17c192279168884868762caaedd33ba7a.html">深度学习-Embedding（词嵌入）</a></p>
<p><strong>第二步</strong>：将得到的单词表示向量矩阵 (如上图所示，每一行是一个单词的表示 x) 输入 Encoder 中后可以得到句子所有单词的编码信息矩阵 C，如下图。单词向量矩阵用 $X_n\times d$表示， n 是句子中单词个数，d 是表示向量的维度 (Transformer论文中 d=512)。其中每一个 Encoder block 输出的矩阵维度与输入完全一致。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/3.png" alt></p>
<p><strong>第三步</strong>：将 Encoder 输出的编码信息矩阵 C传递到 Decoder 中，Decoder  依次会根据当前翻译过的单词 1~ i 来翻译下一个单词 i+1，如下图所示。在使用的过程中，翻译到单词 i+1 的时候需要通过 Mask (掩盖) 操作遮盖住 i+1 之后的单词，从而避免通过i+1后面的单词翻译单词i+1。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/4.png" alt></p>
<p>上图 Decoder 接收了 Encoder 的编码矩阵 C，然后首先输入一个翻译开始符 &lt;Begin&gt;，预测第一个单词 “I”；然后输入翻译开始符 &lt;Begin&gt;和单词 “I”，预测单词 “have”，以此类推。</p>
<p>如果加上Encoder和Decoder的细节，便可以得到下图经典的Transformer模型结构图：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/5.jpeg" alt></p>
<h2 id="Transformer模型各结构细节">Transformer模型各结构细节</h2>
<p>下面将根据Transformer的工作流程介绍每个部分的细节。</p>
<h3 id="Positional-Encoding">Positional Encoding</h3>
<p>Transformer 模型没有循环神经网络那样可以通过迭代来挖掘输入的顺序关系，所以在用Transformer进行相关需要顺序关系的任务时，必须提供每个字的位置信息给 Transformer，这样它才能识别出输入数据的顺序关系。</p>
<p>Positional Encoding也就是位置嵌入，位置嵌入的维度为 [max_sequence_length, embedding_dimension]，位置嵌入的第二个维度与词向量的维度是相同的，都是 embedding_dimension。max_sequence_length属于超参数，指的是限定每个句子最长由多少个词构成。</p>
<p>注意，以中英文翻译为例，一般以字为单位训练 Transformer 模型，因此初始化字编码的大小为 [vocab_size, embedding_dimension]，vocab_size为字库的大小，embedding_dimension为字向量的维度，对应到 PyTorch 代码中，其实就是 <code>nn.Embedding(vocab_size, embedding_dimension)</code></p>
<p>论文中使用了 sin 和 cos 函数的线性变换来提供给模型位置信息:</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/5.png" alt></p>
<p>其中，pos 表示单词在句子中的位置，范围是[0,max_sequence_length]；d 表示位置嵌入的维度，即等于embedding_dimension；2i 表示偶数的维度，2i+1 表示奇数维度（即 $2i≤d, 2i+1≤d$）。</p>
<p>Transformer通过sin和cos函数对位置信息进行处理，从而产生不同的周期性变化（同一维度，不同位置时，其编码呈现周期性），而位置嵌入在 embedding_dimension维度上随着维度序号增大，周期变化会越来越慢，最终产生一种包含位置信息的纹理，正如论文原文中第六页讲的，位置嵌入函数的周期从$2\pi$到$10000* 2\pi$变化，而每一个位置在 embedding_dimension维度上都会得到不同周期的sin和cos函数的取值组合，从而产生独一的纹理位置信息（同一位置，不同维度时，呈现独一的变化趋势），最终使得模型学到位置之间的依赖关系和自然语言的时序特性。以下两图展示了上面所说的两者变化情况：</p>
<p>固定d=512，embedding_dimension第1个和第50个维度的前100个位置值编码变化图：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/6.png" alt></p>
<p>固定d=512，第1个、第10个和第50个位置的embedding_dimension从1到100对应的位置编码变化图：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/7.png" alt></p>
<h3 id="Self-Attention-Mechanism">Self -Attention Mechanism</h3>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/8.png" alt></p>
<p>上图就是Self-Attention 的结构，它的输入有三个矩阵：<strong>查询矩阵Q</strong>、<strong>键矩阵K</strong>、<strong>值矩阵V</strong>。在实际中，Self-Attention 接收的是输入是单词的表示向量x组成的矩阵X， 或者上一个 Encoder block 的输出。而Q、K、V正是通过 Self-Attention 的输入进行线性变换得到的。</p>
<p>Self-Attention 的输入用矩阵X进行表示，则可以使用线性变阵矩阵WQ、WK、WV计算得到Q、K、V。计算如下图所示，注意 X、Q、K、V 的每一行都表示一个单词。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/9.png" alt></p>
<p>得到矩阵 Q、K、V之后就可以计算出 Self-Attention 的输出了，计算的公式如下：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/10.png" alt></p>
<ul>
<li>公式中先计算矩阵Q和K每一行向量的内积，为了防止内积过大，因此除以$d_k$ 的平方根。</li>
<li>Q乘以K的转置后，得到的矩阵行列数都为 n，n 为句子单词数，因此这个矩阵可以表示单词之间的注意力大小。</li>
<li>得到$QK^T$之后，使用 Softmax 计算每一个单词对于其他单词的注意力大小，公式中的 Softmax 是对矩阵的每一行进行 Softmax，即每一行的和都变为 1。</li>
<li>得到 Softmax 矩阵之后可以和V相乘，得到最终的输出Z，这就相当于根据注意力来对单词相应位置进行加权和。</li>
</ul>
<h3 id="Multi-Head-Attention">Multi-Head Attention</h3>
<p>Multi-Head Attention 是由多个 Self-Attention 组合形成的，下图是论文中 Multi-Head Attention 的结构图。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/11.png" alt></p>
<p>从上图可以看到 Multi-Head Attention 包含多个 Self-Attention 层，首先将输入X分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵$Z_1\dots Z_h$。得到 h个输出矩阵之后，Multi-Head Attention 将它们拼接在一起 (Concat)，然后传入一个Linear层，得到 Multi-Head Attention 最终的输出Z。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/12.png" alt></p>
<h3 id="Padding-Mask">Padding Mask</h3>
<p>Self-Attention的计算过程中，通常使用mini-batch来计算，也就是一次计算多句话，即输入X的维度是 [batch_size, sequence_length]，sequence_length是句子长度，所以一个 mini-batch 是由多个不等长的句子组成的，为了输入模型中可以统一处理，需要按照这个 mini-batch 中最大的句长对剩余的句子进行补齐，一般用0进行填充，这个过程叫做 padding。但这时在进行 softmax 就会产生问题。因为$e^0=1$是有值的，这样 softmax 中被 padding 的部分也会参与运算，这可能会产生很大的隐患。因此需要做一个 mask 操作，让这些无效的区域不参与运算，一般是给无效区域加一个很大的负数偏置，即</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/13.png" alt="png"></p>
<h3 id="Encoder">Encoder</h3>
<p>下图是Encoder的结构图及其部分细节。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/14.png" alt="png"></p>
<p>运算过程：输入$x_1$、$x_2$经 self-attention 层之后得到$z_1$、$z_2$，然后和输入$x_1$、$x_2$进行残差连接，经过 LayerNorm 后输出给全连接层。全连接层也有一个残差连接和一个 LayerNorm，最后得到该Encoder Block的输出。（每个 Encoder Block 中的 FeedForward 层权重都是共享的）</p>
<h4 id="残差连接">残差连接</h4>
<p>通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/15.png" alt="png"></p>
<h4 id="Layer-Normalization">Layer Normalization</h4>
<p>Layer Normalization的作用是把神经网络中隐藏层归一为标准正态分布，并假设独立同分布，以起到加快训练速度，加速收敛的作用。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/16.png" alt="image-20220506150346432"></p>
<p>即用每一列的每一个元素减去这列的均值，再除以这列的标准差，从而得到归一化后的数值，加$\epsilon$是为了防止分母为 0。</p>
<h4 id="Feed-Forward">Feed Forward</h4>
<p>Feed Forward 层是一个两层的全连接层，第一层的激活函数为 Relu，第二层不使用激活函数，对应的公式如下，其中X是输入且Feed Forward 最终得到的输出矩阵的维度与X一致。</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/17.png" alt="image-20220506150346432"></p>
<h3 id="Decoder">Decoder</h3>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/18.png" alt="image"></p>
<p>上图红色部分为 Transformer 的 Decoder Block 结构，与 Encoder Block 相似，但也存在一些区别：</p>
<ul>
<li>包含两个 Multi-Head Attention 层。</li>
<li>第一个 Multi-Head Attention 层采用了 Masked 操作。</li>
<li>第二个 Multi-Head Attention 层的K、V矩阵使用 Encoder 的编码信息矩阵C进行计算，而Q则使用上一个Decoder block 的输出计算。</li>
<li>最后有一个 Softmax 层，用于计算下一个翻译单词的概率。</li>
</ul>
<h4 id="Masked-Multi-Head-Attention">Masked Multi-Head Attention</h4>
<p>Decoder block 的第一个 Multi-Head Attention 采用了 Masked 操作，因为在翻译的过程中是顺序翻译的，即翻译完第 i 个单词，才可以翻译第 i+1 个单词。通过 Masked 操作可以防止第 i 个单词知道 i+1 个单词之后的信息。结构如图所示：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/8.png" alt></p>
<p>上图中的mask是唯一不同于其他多头注意力的地方，实现方式是通过设置一个特殊矩阵，如图所示：</p>
<p><img src="/2022/05/06/Tranformer%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82%E5%8F%8Apytorch%E5%AE%9E%E7%8E%B0/19.png" alt="image-20220506153029789"></p>
<p>这样，预测当前词时，不会用到该词以后的词的信息。值为-inf是因为，之后再做softmax就能把-inf变为0，从而使得其权重为0。</p>
<h2 id="Transformer的PyTorch实现">Transformer的PyTorch实现</h2>
<p>完成以下实验需要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,Dataset</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h3 id="Positional-Encoding-2">Positional Encoding</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sinusoid_encoding_table</span>(<span class="params">n_position, d_model</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_angle</span>(<span class="params">position, hid_idx</span>):</span><br><span class="line">        <span class="keyword">return</span> position / np.power(<span class="number">10000</span>, <span class="number">2</span> * (hid_idx // <span class="number">2</span>) / d_model)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_posi_angle_vec</span>(<span class="params">position</span>):</span><br><span class="line">        <span class="keyword">return</span> [cal_angle(position, hid_j) <span class="keyword">for</span> hid_j <span class="keyword">in</span> <span class="built_in">range</span>(d_model)]</span><br><span class="line"></span><br><span class="line">    sinusoid_table = np.array([get_posi_angle_vec(pos_i) <span class="keyword">for</span> pos_i <span class="keyword">in</span> <span class="built_in">range</span>(n_position)])</span><br><span class="line">    </span><br><span class="line">    sinusoid_table[:, <span class="number">0</span>::<span class="number">2</span>] = np.sin(sinusoid_table[:, <span class="number">0</span>::<span class="number">2</span>])  <span class="comment"># dim 2i</span></span><br><span class="line">    </span><br><span class="line">    sinusoid_table[:, <span class="number">1</span>::<span class="number">2</span>] = np.cos(sinusoid_table[:, <span class="number">1</span>::<span class="number">2</span>])  <span class="comment"># dim 2i+1</span></span><br><span class="line">    <span class="keyword">return</span> torch.FloatTensor(sinusoid_table)</span><br></pre></td></tr></table></figure>
<h2 id="参考-2">参考</h2>
<p>1、<a href="https://blog.csdn.net/qq_38410428/article/details/112348321">Transformer模型详解（图解最完整版）</a></p>
<p>2、<a href="https://wmathor.com/index.php/archives/1438/">Transformer 详解</a></p>
<p>3、<a href="https://blog.csdn.net/qq_37236745/article/details/107352273">Transformer的PyTorch实现（超详细）</a></p>
]]></content>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据相关知识</title>
    <url>/2023/02/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Hadoop">Hadoop</h2>
<h3 id="HDFS（Hadoop分布式文件系统）">HDFS（Hadoop分布式文件系统）</h3>
<p><img src="/2023/02/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20230304141412953-1677910468073-1.png" alt="image-20230304141412953"></p>
<p>1、HDFS来源：《Google File System》。</p>
<p>2、HDFS是一个分布式、可扩展的、可靠的文件系统。</p>
<p>3、namenode主要作用：</p>
<ol>
<li>管理HDFS的元数据信息（meta data）、文件名、文件大小、切块数量、每一个块的副本数量、块id、块大小以及块存储在哪台datanode上</li>
<li>通过RPC心跳机制来检测datanode节点状态。</li>
</ol>
<p>4、namenode会将元数据信息存储到namenode服务器的内存中一份，目的供用户快速查询。此外，因为元数据信息特别重要，所以namenode还会把元数据持久化到本地磁盘上。</p>
<p>5、元数据持久化的目录路径是由core-site.xml的dfs.tmp.dir属性来决定的。不配置，会默认放到linux的/tmp（临时目录，定期删除），所以一定要配置。</p>
<p>6、namenode用两个文件来存储元数据信息：</p>
<ol>
<li>Edits文件：存储HDFS的操作记录</li>
<li>Fsimage文件：存储时整个HDFS的状态（相当于快照文件）</li>
<li>Edits和 Fsimage会定期合并，合并周期默认1小时，即Fsimage文件存储的是HDFS的元数据信息。</li>
<li>查看路径安装目录下/tmp/dfs/name/current</li>
</ol>
<p>7、格式化指令：hadoop namenode -format ：清除所有元数据信息，整个指令在初次使用HDFS时，需要执行一次。</p>
<p>启动指令：<a href="http://start-dfs.sh">start-dfs.sh</a> 启动所有和HDFS相关的进程，比如namenode、datanode、secondarynamenode</p>
<p><a href="http://hadoop-datmon.sh">hadoop-datmon.sh</a> start xxx：专门启动xxx进程</p>
<p>停止指令：<a href="http://stop-dfs.sh">stop-dfs.sh</a> 停止所有和HDFS相关的进程，比如namenode、datanode、secondarynamenode</p>
<p><a href="http://hadoop-datmon.sh">hadoop-datmon.sh</a> stop xxx：专门启动xxx进程</p>
<p>kill -9 进程id</p>
<p>8、SNN的作用不仅仅是namenodel的备用节点，还承担了namenodel的元数据文件的合并。通过这种机制，可以使得NN和SNN都具有元数据信息。就NN宕机后，SNN可以接替NN继续工作。</p>
<p>注意：<strong>SNN这种元数据合并机制是可能造成元数据丢失的问题（SNN机制这是hadoop1.0机制，hadoop2.0已经弃用了）</strong>。这种方法存在问题是因为它没有达到元数据实时热备，所以hadoop1.0的namenode还是存在单点故障问题。</p>
<p>如果是hadoop2.0的伪分布式，还是会看到SNN进程；如果是完全分布式，SNN机制已经弃用。</p>
<p><img src="/2023/02/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20230304144203454.png" alt="image-20230304144203454"></p>
<p>9、当HDFS启动时，namenode会做一次Edits和Fsimage合并的操作。目的：确保fsimage里的元数据更新。</p>
<p>可以通过指令手动合并：hadoop dfsadmin -rollEdits</p>
<p>10、当HDFS启动时，每个datanode会向namenode汇报自身的存储的信息，比如存储了哪些文件块、块大小、块id等。namenode收到这些西悉尼之后，会做汇总和检测，检测数据是否完整，副本数量是否达到要求，如果出现问题，HDFS会进行安全模式，在安全模式做数据或副本的复制，直到修复完成后，安全模式自动退出。</p>
<p>安全模式下，HDFS只能提供对外读服务，不能写服务。</p>
<p>如果是伪分布式模式，副本只能配置1个，因为如果配置的副本数&gt;1，会导致 HDFS一致安全模式而不能退出。</p>
<p>11、HDFS存储数据的方式是块存储。 Hadoop1.0切块大小64MB。Hadoop2.0切片大小128MB。（默认值，可以设置）</p>
<p><strong>切块是以文件为单位，不同文件不能共用一个文件块。块多大，就在磁盘上占多大。</strong></p>
<p>12、存储文件块的服务器叫datanode，存储数据块的目录：</p>
<p>安装目录/tmp/dfs/data/current/块id/current/finalized/subdir0/subdir0</p>
<p>13、当把一个文件上传到HDFS之后是不允许修改文件的，因为修改操作属性随机写操作。</p>
<p>HDFS的应用场景：一次写入，多次使用</p>
<p>Hadoop2.0之后允许追加数据（在尾部加数据），不允许修改</p>
<p>14、HDFS不适合存储海量小文件，每上传一个文件，namenode就需要一条元数据来管理，所以存海量小文件会占用大量namenode的内存资源。</p>
<h3 id="HDFS回收站机制">HDFS回收站机制</h3>
<p>trash，默认是关闭的。修改etc/hadoop/core-site.xml来设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.trash.interval&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1440&lt;/value&gt; //清空回收站间隔，单位为分钟，0表示关闭该机制</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<h3 id="MapReduce">MapReduce</h3>
<p>分布式的计算框架。Map（映射）、Reduce（归约）</p>
]]></content>
  </entry>
  <entry>
    <title>机器学习八股文</title>
    <url>/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h2 id="机器学习面试八股文">机器学习面试八股文</h2>
<h3 id="特征工程">特征工程</h3>
<p>1、为什么要对特征做归一化处理：</p>
<p>“特征归一化”、“标准化”是数据预处理中的重要技术。特征间的单位（尺度）可能不同，比如身高和体重，比如摄氏度和华氏度，特征的单位不同的同时，特征的取值范围也会不一致，比如身高是1.5-2.0，体重是50-100kg。上述变量在进行有关距离的计算时，尺度大的特征会起决定性作用，而尺度小的特征其作用可能会被忽略。因此为了消除特征间单位和尺度差异的影响，就需要对特征进行归一化，将其映射到一个相同区间。</p>
<p>2、什么是组合特征？如何处理高维组合特征？</p>
<p>为了提高复杂关系的拟合能力，特征工程的时候会对一阶离散特征两两组合构成高阶特征。</p>
<p>针对高维组合特征可以采取降维，矩阵分解或者特征筛选的方法得到具备绝大部分信息的几个特征进行训练。</p>
<p>对于高维组合特征，常用的方法是进行embedding处理。以uid和nid为例，uid在电商或信息流中量级在百万以上（m=1000000），nid数量也得几十上百万（n=500000）。交叉后会得到高维特征w，其有1000000×500000种特征组合，也就是特征权重的数量。如果我们引入矩阵分解的思想，将uid和nid用远小于uid数量和nid数量的k维向量表示，将矩阵w分解为u和v，u就是m×k的用户矩阵，v是n×k的物品矩阵。那么参数规模变为（m+n)×k。</p>
<p>3、比较欧氏距离、曼哈顿距离和切比雪夫距离。</p>
<p>欧氏距离：欧几里得距离，就是平方和再开根号。最常用的。欧氏距离越小，两个向量的相似度越大；欧氏距离越大，两个向量的相似度越小。</p>
<p>曼哈顿距离：|x1 - x2| + |y1 - y2|。</p>
<p>切比雪夫距离：max（|x1 - x2|，|y1 - y2|）</p>
<p>4、什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？</p>
<p>对于两个向量A和B，其余弦相似度定义为cos（A，B）＝ A<em>B / |A|</em>|B| 即两个向量夹角的余弦值。余弦相似度关注的是向量之间的角度关系，并不关心它们的绝对大小,余弦相似度符合“相同为1，正交为0，相反为-1”的性质，其取值范围是［-1,1］。</p>
<p>欧式距离是衡量空间点之间的直线距离，余弦距离衡量点在空间的方向差异。欧式距离体现的数值上的绝对差异，而余弦距离体现方向上的相对差异。</p>
<p>5、one-hot的作用是什么？为什么不能直接用数字来表示？</p>
<p>One-Hot编码是分类变量作为二进制向量的表示。这首先要求将分类值映射到整数值。然后，每个整数值被表示为二进制向量，除了该整数的索引为1之外，其它都是零值。</p>
<p>不直接使用数字是因为：直接使用数字会给将人工误差而导致的假设引入到类别特征中，比如类别之间的大小关系，以及差异关系等等</p>
<h3 id="模型评估">模型评估</h3>
<p>1、过拟合和欠拟合是啥？具体表现是啥？</p>
<p>过拟合：模型在训练集上表现越来越好，测试集上表现越来越差的现象。欠拟合：模型在训练集和测试集上表现都很差。</p>
<p>欠拟合会导致高偏差 ，过拟合会导致高方差 ，所以模型需要在偏差与 方差之间做出一个权衡。</p>
<p>2、降低过拟合和欠拟合的方法</p>
<p>1）解决欠拟合的方法：</p>
<ul>
<li>增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间维度;</li>
<li>尝试非线性模型，比如核SVM 、决策树、DNN等模型;</li>
<li>如果有正则项，可以调小正则项参数 $\lambda$;</li>
<li>Boosting，Boosting 往往会有较小的偏差，比如 Gradient Boosting 等.</li>
</ul>
<p>2）解决过拟合的方法：</p>
<ul>
<li>交叉检验，通过交叉检验得到较优的模型参数;</li>
<li>减少特征数量</li>
<li>在损失函数中加入正则项，或调大正则项参数 $\lambda$;、</li>
</ul>
<h3 id="树模型">树模型</h3>
<h4 id="1、决策树">1、决策树</h4>
<ul>
<li>决策树由节点和分支组成。</li>
<li>节点有三种类型:根节点，内部节点和叶节点。</li>
<li>分支:用于连接各个节点。</li>
</ul>
<h4 id="2、特征选择">2、特征选择</h4>
<h5 id="信息熵ID3">信息熵ID3</h5>
<p>信息熵(entropy)是度量样本集合内部节点所包含的样本尽可能属于同一类别最常用的一种指标，<strong>$p_k$为以第k类为依据预测正确的概率</strong>，则D的信息熵定义为</p>
<p><img src="/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AB%E8%82%A1%E6%96%87/1.jpg" alt="v2-8c2a75989449e0e09e51a3b4d24509ba_r"></p>
<p>在选择分裂节点时，根据<strong>信息熵增益</strong>来选，信息熵增益越大越好。</p>
<p><img src="/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AB%E8%82%A1%E6%96%87/2.jpg" alt="v2-2f33756d197fd70d09f28f97e59a8094_720w"></p>
<h5 id="增益率C4-5">增益率C4.5</h5>
<p><strong>增益率C4.5</strong>（最常用的决策树算法）：思想是先从候选划分属性中找出信息增益高于平均水平的，再从中选取增益率最高的。最大的特点是克服了 ID3 对特征数目的偏重这一缺点，引入信息增益率来作为分类标准。</p>
<p><img src="/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AB%E8%82%A1%E6%96%87/3.jpg" alt="v2-a1f393b95db2ffb4f861989f491257d5_720w-1"></p>
<h5 id="基尼系数CART算法">基尼系数CART算法</h5>
<p>基尼系数CART算法（可以用于回归任务）：其反映了从D中随机抽取两个样例,其类别标记不一致的概率。Gini(D)越小，数据集D的纯度越高</p>
<h4 id="3、随机森林">3、随机森林</h4>
<p>**结构：**随机森林建立了多个决策树，并将它们合并在一起以获得更准确和稳定的预测，是以决策树为估计器的Bagging算法。</p>
<p><strong>过程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">循环 K 次：</span><br><span class="line"></span><br><span class="line">  1、从训练集 T 中有放回抽样的方式，取样 N 次形成一个新子训练集 D</span><br><span class="line"></span><br><span class="line">  2、随机选择 m 个特征，其中 m &lt; M</span><br><span class="line"></span><br><span class="line">  3、使用新的训练集 D 和 m 个特征，学习出一个完整的决策树</span><br><span class="line"></span><br><span class="line">得到随机森林，随机森林的大小为 K，最后投票决定分类结果。概率为所有树的输出的平均值。</span><br></pre></td></tr></table></figure>
<h4 id="4、Adaboost">4、Adaboost</h4>
<p>该算法其实是一个简单的弱分类算法提升过程</p>
<p><strong>过程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**（1）初始化训练数据的权重。**</span><br><span class="line"></span><br><span class="line">如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</span><br><span class="line"></span><br><span class="line">**（2）训练弱分类器。**</span><br><span class="line"></span><br><span class="line">具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</span><br><span class="line"></span><br><span class="line">**（3）将各个训练得到的弱分类器组合成强分类器。**</span><br><span class="line"></span><br><span class="line">各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</span><br></pre></td></tr></table></figure>
<h4 id="5、GBDT">5、GBDT</h4>
<p>**结构：**一种boosting算法，相当于把多个弱学习器串联（bagging是并联）。残差本质上就是二次损失函数的负梯度。</p>
<p>弱学习器限定只能使用CART回归树，初始化一颗回归树，然后每棵树由拟合上一轮残差得到，最后将所有弱分类器组合。</p>
<p><img src="/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AB%E8%82%A1%E6%96%87/4.png" alt="20180713165334912"></p>
<h4 id="6、XGBoost">6、XGBoost</h4>
<p>GBDT是机器学习算法，<strong>XGBoost是该算法的工程实现</strong>，包括一些工程实现方面的优化。</p>
<p>（1）在使用CART作为基分类器时，XGBoost显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力。</p>
<p>（2）GBDT在模型训练时只使用了代价函数的一阶导数信息，XGBoost对代 价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数。</p>
<p>（3）传统的GBDT采用CART作为基分类器，XGBoost支持多种类型的基分类器，比如线性分类器。</p>
<p>（4）传统的GBDT在每轮迭代时使用全部的数据，XGBoost则采用了与随机森林相似的策略，支持对数据进行采样。</p>
<p>（5）传统的GBDT没有设计对缺失值进行处理，XGBoost采用稀疏感知策略自动学习出缺失值的处理策略。</p>
<p>（6）XGBoost的列块设计能有效支持并行运算，提高效率。</p>
<h5 id="寻找最优分裂点：">寻找最优分裂点：</h5>
<ul>
<li>对每个待分裂节点遍历所有特征。</li>
<li>针对每个特征，对属于该节点的训练样本根据该特征值进行预排序，通过线性扫描的方式决定该特征的最佳划分位置，并记录该特征的分裂收益。</li>
<li>选择收益最大的特征和划分位置作为分裂点，在该节点上分裂出左右两个新的叶节点，并为每个新节点关联对应的样本集。</li>
</ul>
<h4 id="7、LightGBM">7、LightGBM</h4>
<p>LightGBM 是对XGBoost算法进行的优化。</p>
<p>（1）为了解决xgboost分裂点数量过多的问题，LightGBM采用直方图算法，类似于对特征进行分桶。</p>
<p>（2）为了解决xgboost样本数量过多的问题， LightGBM采用单边梯度抽样算法。</p>
<p>（3）为了解决xgboost特征数量过多的问题，LightGBM采用互斥特征捆绑算法</p>
<h5 id="直方图算法">直方图算法</h5>
<p>将连续型特征值放入离散化的箱子 (bin) 中，然后用这些箱子构建特征直方图。然后模型基于特征直方图寻找最佳分裂点</p>
<h5 id="单边梯度抽样算法-GOSS-：">单边梯度抽样算法(GOSS)：</h5>
<p>梯度小的样本，训练误差也比较小，说明数据已经被模型学习得很好了，直接想法就是丢掉这部分梯度小的数据。然而这样做会改变数据的分布，GOSS根据样本的权重信息对样本进行抽样，减少了大量梯度小的样本，但是还能不会过多的改变数据集的分布。</p>
<h5 id="带有深度限制的按叶子生长-leaf-wise-算法：">带有深度限制的按叶子生长 (leaf-wise) 算法：</h5>
<p><img src="/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AB%E8%82%A1%E6%96%87/5.jpg" alt="v2-77e95bf86ae4f2b0ff2c58d07c8749a0_r"></p>
<p>该策略每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。</p>
<p>Level-wise相比，优点在于：在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。</p>
<p>缺点在于：可能会长出比较深的决策树，产生过拟合。因此LightGBM会在Leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p>
<h4 id="问题：简要说一下Lightgbm相对于xgboost的优缺点">问题：简要说一下Lightgbm相对于xgboost的优缺点</h4>
<p>**优点：**Ligbm是相较于XGBoost，有更高效率，速度更快，内存占用更低，泛化能力更强（分箱与之后的不精确分割也起到了一定防止过拟合的作用）；</p>
<p>**缺点：**直方图算法对特征进行分桶相较于XGBoost之间进行，会损失一定精度。</p>
<h4 id="问题：对比一下XGB和lightGBM在节点分裂时候的区别">问题：对比一下XGB和lightGBM在节点分裂时候的区别</h4>
<p>xgboost是level-wise，lgbm是leaf-wise，level-wise指在树分裂的过程中，同一层的非叶子节点，只要继续分裂能够产生正的增益就继续分裂下去，而leaf-wise更苛刻一点，同一层的非叶子节点，仅仅选择分裂增益最大的叶子节点进行分裂。</p>
<h4 id="问题：RF和xgboost哪个对异常点更敏感">问题：RF和xgboost哪个对异常点更敏感</h4>
<p>xgboost更敏感。rf的每棵数的生成是独立的，异常点数量不多的情况下异常点常常和正常样本中的某些样本合并在一个分支里。但是xgboost不一样，异常样本的t-1轮的预测值和真实标签计算出来的负梯度会一直很大。</p>
<h4 id="问题：XGBoost和GBDT的区别有哪些？">问题：XGBoost和GBDT的区别有哪些？</h4>
<p><strong>1、算法层面：</strong></p>
<p>（1）损失函数的二阶泰勒展开；</p>
<p>（2）树的正则化概念的引入，对叶节点数量和叶子节点输出进行了约束，方式是将二者形成的约束项加入损失函数中；</p>
<p>（3）二阶泰勒展开与树正则化推出了新的叶子节点输出的计算公式而不是原始gbdt那样的简单平均；</p>
<p>（4）对于缺失值的处理，xgboost根据左右子节点的增益大小将缺失值分到增益大的节点中，而sklearn中的gbdt是无法处理缺失值的，因为sklearn中的gbdt是以sklearn中的cart为基学习器的，而sklearn中的cart也并没有实现对缺失值的处理功能。</p>
<p><strong>2、工程层面</strong></p>
<p>对每个特征进行分块（block）并排序（pre_sort），将排序后的结构保存在内存中，这样后续分裂的时候就不需要重复对特征进行排序然后计算最佳分裂点了，并且能够进行并行化计算。</p>
<h4 id="8、逻辑回归">8、逻辑回归</h4>
<p>逻辑回归也称作logistic回归分析，是一种有监督的统计学习方法。其推导过程与计算方式类似于回归的过程，但实际上主要是用来解决二分类问题（也可以解决多分类问题）</p>
<p>逻辑回归模型的假设是： $h_\theta \left( x \right)=g\left(\theta^{T}X \right)$其中： X代表特征向量,  g代表逻辑函数（logistic function)。一个常用的逻辑函数为S形函数（Sigmoid function），公式为： $g(z)=\frac{1}{1+e^{-z}}$</p>
<p><strong>逻辑回归的思路</strong>是，先拟合决策边界，再建立这个边界与分类的概率联系，从而得到了二分类情况下的概率。</p>
<p>Logistic 回归实际上是使用线性回归模型的预测值逼近分类任务真实标记的对数几率，其优点有：</p>
<ol>
<li>直接对<strong>分类的概率</strong>建模，无需实现假设数据分布，从而避免了假设分布不准确带来的问题（区别于生成式模型）；</li>
<li>不仅可预测出类别，还能得到该<strong>预测的概率</strong>，这对一些利用概率辅助决策的任务很有用；</li>
<li>对数几率函数是<strong>任意阶可导的凸函数</strong>，有许多数值优化算法都可以求出最优解。</li>
</ol>
<h4 id="9、判别式模型、生成式模型">9、判别式模型、生成式模型</h4>
<p>判别式模型是对条件概率建模，学习不同类别之间的最优边界，无法反映训练数据本身的特性</p>
<p>生成式模型先计算了联合概率P(x,y)，再由贝叶斯公式计算得到条件概率。因此，生成式模型可以体现更多数据本身的分布信息，其普适性更广。</p>
]]></content>
      <tags>
        <tag>ML, 面试</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题：填充数组</title>
    <url>/2023/03/23/%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="填充数组">填充数组</h2>
<p>牛妹给了牛牛一个长度为 n 的下标从 0开始的正整型数组 a ，粗心的牛牛不小心把其中的一些数字删除了。</p>
<p>假如$a_{i}$被删除了，则$a_{i}=0$。对于所有被删除的数字，牛牛必须选择一个正整数填充上。现在牛牛想知道有多少种填充方案使得：</p>
<ul>
<li>$a_{0} \leq a_{1} \leq…\leq a_{n-1}$ 且对于所有的$0 \leq i \leq n-1$满足$1≤a_i≤k$</li>
</ul>
<p>函数传入一个下标从000开始的数组 aaa 和一个正整数 kkk ，请返回合法的填充方案数对 $10^9+7$ 取模的值,保证不存在方案数为0的数据。</p>
<h3 id="示例-44">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">[0,4,5],6</span><br><span class="line">输出</span><br><span class="line">4</span><br><span class="line">说明</span><br><span class="line">所有的合法填充方案是：[1,4,5],[2,4,5],[3,4,5],[4,4,5]，共4种。   </span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入</span><br><span class="line">[1,0,0],3</span><br><span class="line">输出</span><br><span class="line">6</span><br><span class="line">说明</span><br><span class="line">所有的合法填充方案是：[1,1,1],[1,1,2],[1,2,2],[1,2,3],[1,3,3],[1,1,3]共6种   </span><br><span class="line"></span><br><span class="line">示例3</span><br><span class="line">输入</span><br><span class="line">[0,0,0,0,0,67,0,0],100</span><br><span class="line">输出</span><br><span class="line">746845806</span><br></pre></td></tr></table></figure>
<h5 id="备注"><strong>备注:</strong></h5>
<ul>
<li>$1 \leq n,k \leq 1000$</li>
<li>数组a满足$0 \leq a_{i} \leq k$</li>
</ul>
<h3 id="问题解答-44">问题解答</h3>
<h4 id="动态规划-2">动态规划</h4>
<p>原问题是在原非递减数组找到丢失的数，输出可能的数组数。直接在既有0又有其他数的区间上计算很难。根据组合相关知识，可知最终的可能数等于每一部分（连续0区间为一部分）可能数的乘积。所以我们可以找到这样区间。他们可能填充的数字个数为左边第一个非0数到右边第一个非0数。因此只要可以计算长度l区间的填充n个数的可能情况数即可。</p>
<p>如何计算？由于该区间后面取值情况取决于前面的取值，因此可以使用动态规划进行求解。这里构建了一个dp数组，dp[i][j]表示将j+1个数填充到i+1个长度上的总可能数。那么迭代式可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure>
<p>dp[i-1][j]表示当第i+1个位置的值填充为j+1的可能数（因为原数组是非递减的，因此当第i+1个位置的值为j+1时，前面i个位置的最大值也就是j+1，也就相当于将j+1个数填充到i个位置上）。dp[i][j-1]表示当第i+1个位置的值不填充为j+1的可能数（因为第i+1位置是最大值出现的地方，因此该位置不等于j+1，其他位置最大值可能就是j，相当于将j个数填充到i+1个位置上）。分出上述情况是因为j+1是之前没有考虑过的数，而它可能出现的情况只能有两种，要不i+1位置是j+1，要不就存在j+1。</p>
<h5 id="代码-52">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param a int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param k int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FillArray</span>(<span class="params">self , a , k </span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        emp_list = [(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                emp_list.append((idx+<span class="number">1</span>, i))</span><br><span class="line">        emp_list.append((<span class="built_in">len</span>(a)+<span class="number">1</span>, k))</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">l, n</span>):</span><br><span class="line">            <span class="comment"># dp[i][j]表示将j+1个数填充到i+1个长度上的总方式数</span></span><br><span class="line">            dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l)]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[<span class="number">0</span>][j] = j + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    dp[i][j] = (dp[i][j-<span class="number">1</span>]+ dp[i-<span class="number">1</span>][j])%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[l-<span class="number">1</span>][n-<span class="number">1</span>]         </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ((i1,j1),(i2,j2)) <span class="keyword">in</span> <span class="built_in">zip</span>(emp_list[:-<span class="number">1</span>],emp_list[<span class="number">1</span>:]):</span><br><span class="line">            n = i2 - i1 - <span class="number">1</span></span><br><span class="line">            min_ = j1 </span><br><span class="line">            max_ = j2</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(calc(n, max_-min_+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            result = (result * i)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>经典笔试题</title>
    <url>/2023/03/27/%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="删除游戏（打家劫舍）">删除游戏（打家劫舍）</h2>
<p>现在给你一个包含 n个正整数的序列$a$，你可以进行许多次提作直到序列为空，每次提作可以选定当序列中的一个数$a_i$并删除，然后删除所有等于$a_i+1$或者$a_i-1$的数，都除的数无法再减之后的提作选中这样的一次操作能让你获得$a_i$分，请问你最多能获得多少分数？</p>
<h3 id="示例-45">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入描述：</span><br><span class="line"></span><br><span class="line">	第一行一个正整数n，表示序列a的长度</span><br><span class="line"></span><br><span class="line">    接下来一行包含n个正整数a1,a2,...an,分别为序列a中的n个数</span><br><span class="line"></span><br><span class="line">    n≤100000，1≤ai≤100000</span><br><span class="line"></span><br><span class="line">输出描述：</span><br><span class="line"></span><br><span class="line">    输出可以获得的最高分数</span><br><span class="line"></span><br><span class="line">样例输入：</span><br><span class="line"></span><br><span class="line">    样例1</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    1 2 3</span><br><span class="line"></span><br><span class="line">    样例2</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line"></span><br><span class="line">    1 2 3 2 2</span><br><span class="line"></span><br><span class="line">样例输出：</span><br><span class="line"></span><br><span class="line">    样例1</span><br><span class="line"></span><br><span class="line">    4</span><br><span class="line"></span><br><span class="line">    样例2</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">样例解释：</span><br><span class="line"></span><br><span class="line">    对于样例2，第一次可以选择删除任意一个等于2的数，这次操作同时除等于1和3的数，获得2分目序列中剩余的数为[2,2],</span><br><span class="line"></span><br><span class="line">    之后可以连续两次操作都选择等于2的数，这样总共能获得6分。</span><br></pre></td></tr></table></figure>
<h3 id="解答">解答</h3>
<p>思路：首先根据题意以及第二个样例，我们可以发现对于同一个数，如果它是最终结果选择的数，那么可获得的分为该数*该数的次数，相同数出现再多，也就是选择该数数次。因为第一次选择就会将$a_i-1$和$a_i+1$的数删除，所以该数只能被选，而无法被删除。</p>
<p>由于对于每个不同数，该数存在两种状态，要不被选，要不被删除。</p>
<p>因此，使用dp数组来存各个状态，其中dp[i][0]：对于第i个数，被删除时获得的最大分数，dp[i][1]：对于第i个数，被选择时获得的最大分数。</p>
<p>那么迭代式可写为：$dp[i][0]=max(dp[i-1][0],dp[i-1][1])$,$dp[i][1]=dp[i-1][0]+i*count(i)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter </span><br><span class="line">    count = Counter(nums)</span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(nums)+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = count[<span class="number">1</span>]</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">max</span>(nums)+<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        dp[i][<span class="number">1</span>] = i*count[i] + dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(dp)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(calc([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础学习</title>
    <url>/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="JAVA基础学习">JAVA基础学习</h2>
<p>JAVA跨平台的实现是基于JVM。针对不同的操作系统开发了不同的虚拟机，将jva程序交给虚拟机，虚拟机转化为当前操作系统所能理解的指令，然后操作系统再根据指令执行代码。</p>
<ul>
<li>JVM–Java Virtual Machine–java虚拟机，是java能够跨平台的前提</li>
<li>JRE–Java Runtime Environment–java运行时环境，包含JVM+核心类库</li>
<li>JDK–Java Development Kit–java开发工具包，开发工具+JRE</li>
</ul>
<p><strong>JAVA技术结构</strong>：</p>
<ul>
<li>JAVASE：JAVA标准版</li>
<li>JAVAEE：JAVA企业版</li>
<li>JAVAME：JAVA微型版</li>
</ul>
<p><strong>JAVA基本知识：</strong></p>
<ul>
<li>Java程序必须放在Java文件(后缀名是java)；一个Java文件中，可以存放多个Java类，但是只能有一个公共类（用public修饰的类—要求Java文件名和类名一致）。</li>
<li>每一个Java类在编译完成之后都会产生一个class文件（字节码文件）</li>
<li>javac -d 存放位置 编译Java文件</li>
<li>java 包名.类名 运行java文件</li>
</ul>
<p><strong>关键字</strong>：</p>
<p>在Java中有特殊含义的单词–53个关键字–2个关键字到目前为止没有使用，也称之为保留字：goto, const</p>
<p>注意：在Java中，所有的关键字都是小写的</p>
<p><strong>标识符：</strong></p>
<p>在程序中自定义的名称。定义规则：可以使用字母（常见语言的基本字符）、数字、__、$，$虽然可以使用，但是尽量减少使用，因为$一般用于标识内部类。数字不能开头。JAVA完全区分大小写。</p>
<p><strong>驼峰命名法：</strong></p>
<ul>
<li>类名/接口名：如果名字由多个单词组成，那么每一个单词的首字母要大写，如HelloWorld Demo</li>
<li>变量名、方法名：如果由多个单词组成，那么第一个单词的首字母小写，其余单词的首字母大写，如helloWorld  demo</li>
<li>常量名：无论由几个单词组成，所有字母全部大写，每一个单词之间用__隔开，如HELLO_WORLD DEMO</li>
<li>包名：无论由几个单词组成，所有的字母全部小写，每一个单词之间用.隔开，如cn.tedu.exer</li>
</ul>
<p><strong>注释：</strong></p>
<p>单行注释：//内容</p>
<p>多行注释：/* 内容*/</p>
<p>文档注释：/**内容*/ —文档注释中的内容可以提取出来形成文档—javadoc</p>
<h3 id="基本数据类型">基本数据类型</h3>
<p>字符：单引号标识，如‘a’</p>
<p>字符串；双引号标识，如“abc”</p>
<p>空：NULL</p>
<p>二进制数：OB/Ob开头，如0B10101</p>
<p>八进制数：O开头，如O5</p>
<p>十六进制数：OX/Ox开头，如Ox5A</p>
<h4 id="数值型-2">数值型</h4>
<p>**byte：**字节型，1个字节，$[2^7,2^7-1]$，-128~127</p>
<p>**short：**短整型，2个字节。-32768~32767</p>
<p>**int：**整型，4个字节。JAVA中整数默认为int类。</p>
<p>**long：**长整型，8个字节。需要在结尾添加L/l作为标识（数值大于int范围时，必须加；在int范围内，可以省略）。</p>
<p>注：在java中，可以使用_进行整型的分位，如1_234_123_213。</p>
<p>**float：**单精度浮点型，4个字节。需要添加F/f作为标识。</p>
<p>**double：**双精度浮点型，8个字节。在JAVA中小数默认为double。</p>
<p>注：double d = 4e4，AeB：表示A*10^B，十进制的科学计数法。</p>
<p>double d = Ox5p3，表示16进制的科学计数法，ApB：表示A*2^B</p>
<h4 id="字符型">字符型</h4>
<p>char：两个字节，0~65535，默认utf-16编码。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/1.png" alt="image-20230403212848550"></p>
<p>Unicode编码体系（万国码体系，收录了常见语言的常见字符）：**utf-8：**3个字节1个字符，**utf-16：**2个字节1个字符。</p>
<p>所有码表都要兼容西欧码表，意味着前256个字符是一样的，而且其永远只占1个字节。</p>
<h4 id="布尔型">布尔型</h4>
<p>boolean，内存大小随着发展而变化。</p>
<h4 id="数据类型的转换">数据类型的转换</h4>
<h5 id="自动类型转换-隐式转换">自动类型转换/隐式转换</h5>
<p>1、小的类型可以自动转化为大的类型。</p>
<p>2、整型可以自动转化为小数，但是可能产生精度损失。</p>
<p>3、字符可以自动转为int类型。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/2.png" alt="image-20230403214442145"></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/3.png" alt="image-20230403214800804"></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/4.png" alt="image-20230403214949623"></p>
<h5 id="强制类型转换-显式转换">强制类型转换/显式转换</h5>
<p>byte b = (byte) i;</p>
<h4 id="算术运算符">算术运算符</h4>
<p><code>+ - * / % ++ --</code></p>
<p>byte/short/char在参与运算时会自动提升为int。但byte i = 3 + 5;这句话可以正常运行，因为3+5是字面量，java会在编译时自动运行的，因此该语句就相当于byte i = 8。但byte/short/char在进行自增、自减时不会改变类型，如果超范围也不会转换为int，因为其底层是先计算后强转实现。byte/short/char也可以参与赋值运算（<code>+= -= /= *=</code>），其基本实现同自增自减。</p>
<p>Java是一门类型严格的语言，所以同一个类型运算完成之后结果是同一类型。</p>
<ul>
<li>小类型和大 类型同时运算，结果一定是大类型。</li>
<li>小数运算不保证精确性。</li>
<li>整数/0：会报算术异常。非零小数/0或0.0：infinity，无穷大，有正负之分。0/0 .0或0.0/0或0.0/0.0：NaN，非数字。</li>
<li>取余运算的结果符号和%左边的数字（被除余数）符号有关，左边为正，则结果为正；左边为负，结果为负。JAVA支持小数取余。</li>
<li>JAVA不支持连等定义，但支持连等运算。</li>
</ul>
<h4 id="逻辑运算符">逻辑运算符</h4>
<p><code>&amp; | ! ^ &amp;&amp; ||</code></p>
<p>||在&amp;&amp;前边的时候能够把&amp;&amp;给短路掉，但是&amp;&amp;在||前边，不能短路掉||。</p>
<h4 id="位运算">位运算</h4>
<p>注意：位运算针对整数的补码进行计算。</p>
<p><code>&amp; | ^ &lt;&lt; &gt;&gt;  &gt;&gt;&gt;：无符号右移 ~：取反</code></p>
<p>左移、右移：符号位不参与移动。</p>
<p>无符号右移：符号位参与移动，右移时，最高位补0。</p>
<p>在进行移位运算，并不是直接移动对应的位数，而是将要移动的位数对32进行取余，移动的是余数对应的位数</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/5.png" alt="image-20230404144852611"></p>
<h5 id="补充：异或法交换值：">补充：异或法交换值：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">x = x ^ y;</span><br><span class="line">y = x ^ y;<span class="comment">// y = 5</span></span><br><span class="line">x = x ^ y;<span class="comment">// x = 7</span></span><br><span class="line"><span class="comment">//局限性：只能用于整数。</span></span><br></pre></td></tr></table></figure>
<h5 id="补充：判断一个整数n是否满足2-x的形式">补充：判断一个整数n是否满足2^x的形式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( n &amp; (n-<span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据n的二进制数来判断，如果满足2^x，则其二进制可写为10…00这种形式，它与上n-1（01…11）肯定为0。</p>
<h4 id="三元运算符">三元运算符</h4>
<p><code>逻辑值?表达式1:表达式2</code></p>
<p>逻辑值位True：执行表达式1，False：执行表达式2。表达式1和2的结果能够兼容。三元表达式可以嵌套。</p>
<h4 id="运算符优先级">运算符优先级</h4>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/6.png" alt="image-20230404151901686"></p>
<h3 id="流程">流程</h3>
<h4 id="条件控制">条件控制</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 代码块只有一句话时，其对应的&#123;&#125;可以省略。</span><br><span class="line">if(逻辑值)&#123;</span><br><span class="line">	代码块1</span><br><span class="line">&#125;else if&#123;</span><br><span class="line">	代码块2</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	代码块3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch(选项)&#123; //选项支持byte/short/char/int/String（jdk1.7）</span><br><span class="line">	case 选项1: code1; break;</span><br><span class="line">	case 选项2: code2; break;</span><br><span class="line">	case 选项3: code3; break;</span><br><span class="line">	...</span><br><span class="line">	default: coden; //默认，其他都不匹配时启用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：从控制台获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.nextInt();<span class="comment">//获取整数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> s.nextDouble();<span class="comment">//获取小数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.nextLine();<span class="comment">//获取字符串</span></span><br></pre></td></tr></table></figure>
<h5 id="循环结构">循环结构</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(逻辑值)&#123;</span><br><span class="line">	代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	代码块</span><br><span class="line">&#125;while(逻辑值)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(定义循环变量;控制条件;改变循环变量)&#123;</span><br><span class="line">	代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>continue、break。</p>
<h3 id="数组">数组</h3>
<h4 id="一维数组">一维数组</h4>
<p>存储<strong>同一类型</strong>的多个数据的<strong>固定大小</strong>的容器。</p>
<h5 id="定义格式">定义格式</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数组类型[] 数组名 = new 数据类型[长度]; // 动态初始化</span><br><span class="line">2、数组类型[] 数组名 = new 数据类型[]&#123;v1,v2,...,vn&#125;; // 静态初始化</span><br><span class="line">3、数组类型[] 数组名 = &#123;v1,v2,...,vn&#125;; // 静态初始化，这种方式的声明和初始化不能分开。</span><br></pre></td></tr></table></figure>
<h5 id="数组存储过程：">数组存储过程：</h5>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/7.png" alt="image-20230404164933723"></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/8.png" alt="image-20230404165524585"></p>
<h5 id="数组应用">数组应用</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br><span class="line"></span><br><span class="line">// 获取元素</span><br><span class="line">arr[i]</span><br><span class="line"></span><br><span class="line">// 获取数组的长度</span><br><span class="line">arr.length</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">//		1、遍历下标</span><br><span class="line">for(int i = 0;i &lt; arr.length;i ++)&#123;</span><br><span class="line">    arr[i]</span><br><span class="line">&#125;</span><br><span class="line">// 		2、增强for循环，不能改变数组的值</span><br><span class="line">for(int i : arr)&#123;</span><br><span class="line">	i</span><br><span class="line">&#125;</span><br><span class="line">//		3、将数组中的元素拼接成一个字符串返回</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">String str = Arrays.toString(arr);</span><br><span class="line"></span><br><span class="line">// 获取数组的最大值（最小值）</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">int max = Arrays.stream (numbers).max().getAsInt()</span><br><span class="line">int min = Arrays.stream (numbers).min().getAsInt()</span><br><span class="line"></span><br><span class="line">// 数组排序</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">Arrays.sort(arr); //只能升序排序，快速排序+归并排序的实现</span><br><span class="line">// 实现降序，可以利用内部类进行</span><br><span class="line">Arrays.sort(arr, );</span><br><span class="line"></span><br><span class="line">// 反转数组--首尾互换</span><br><span class="line"></span><br><span class="line">// 有序数组查找：二分查找--O(logn)</span><br><span class="line">int b = Arrays.binarySearch(arr, v);// 返回待查找数v的下标</span><br><span class="line"></span><br><span class="line">// 数组的复制：将arr1的数组的值赋给arr2。</span><br><span class="line">System.arraycopy(arr1, arr1起始下标, arr2, arr2起始下标， 复制长度)</span><br><span class="line"></span><br><span class="line">// 数组扩容：实际上数组的扩容本质上就是数组的复制：先创建一个指定长度的数组，再将原数据的值复制到该数组，最后返回。</span><br><span class="line">import java.util.Arrays</span><br><span class="line">Arrays.copyof(arr, 扩容后的数组长度)</span><br></pre></td></tr></table></figure>
<h4 id="二维数组">二维数组</h4>
<h5 id="定义格式-2">定义格式</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数组类型[][] 数组名 = new 数据类型[行数][列数]; </span><br><span class="line">2、数组类型[] 数组名 = new 数据类型[行数][];//然后在后续部分进行声明每一行存的一维数组，这时候，每一行的一维数组长度可以不一样。如：</span><br><span class="line">int[][] arr = new int[3][]; </span><br><span class="line">arr[0] = new int[3];</span><br><span class="line">arr[1] = new int[5];</span><br><span class="line">arr[2] = new int[4];</span><br><span class="line">3、数组类型[] 数组名 = &#123;数组1, 数组2, ...&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/9.png" alt="image-20230405210512567"></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/10.png" alt="image-20230405211515420"></p>
<h5 id="二维数组应用">二维数组应用</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 二维数组遍历</span><br><span class="line">1、遍历下标</span><br><span class="line">2、增强for循环</span><br><span class="line">int[][] arr = new int[3][5];</span><br><span class="line">for(int[] as : arr)&#123;</span><br><span class="line">	for(int a : as)&#123;</span><br><span class="line">		a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-2">方法</h3>
<h4 id="格式">格式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型/void 方法名(参数列表)&#123;</span><br><span class="line">	方法体;</span><br><span class="line">	return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法的重载">方法的重载</h4>
<p>在同一个类中存在方法名一样，参数列表不同（参数个数，对应位置的参数类型）的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public double add(double i, int j)</span><br><span class="line">public double add(int i, double j)</span><br><span class="line">// 构成重载，因为调用时不会产生歧义。</span><br></pre></td></tr></table></figure>
<p>Java中，如果没有最符合的方法，那么这个时候就看参数类型是否能够转换（自动转换）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行add(3,5)时</span><br><span class="line">//可以调用public double add(double i, int j)或public double add(int i, double j)，但由于都可以转换，且优先级一样，如果两者同时存在，就会出现歧义，编译出错。</span><br><span class="line">//所以方法在重载时，尽量重载所有的形式以防产生歧义。</span><br></pre></td></tr></table></figure>
<h4 id="方法的传值">方法的传值</h4>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/11.png" alt="image-20230406191209963"></p>
<h3 id="面向对象">面向对象</h3>
<p>面向对象是一种思维方式，相对于面向过程而言的。面向过程注重流程中的每一步，清楚流程中的每一个细节。面向对象注重的是对象，只要找到了这个对象，就能够拥有对象身上的一切功能。面向对象是基于面向过程的。</p>
<h4 id="对象的内存存储">对象的内存存储</h4>
<p>对象在栈内存中存储的是地址引用；在堆内存中存储的是实际对象，其中属性会对象存储到堆内存中，并且属性会在堆内存中赋予默认值。</p>
<h4 id="类">类</h4>
<p>根据一类对象进行概括，将对象的特征概括为属性，将对象的行为概括为方法，将这一类对象用一个类表示—类是对象的概括/抽取。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/12.png" alt="image-20230406200249890"></p>
<h4 id="成员变量和局部变量">成员变量和局部变量</h4>
<ul>
<li>定义位置：成员变量定义在类中，局部变量定义在方法中</li>
<li>作用范围：成语变量作用在整个类中，局部变量只能在定义它的方法或者语句中使用</li>
<li>内存位置：成员变量存储在堆内存中，并且在堆内存中自动的赋予了默认值；局部变量存储在栈内存中，不会自动给默认值</li>
<li>生命周期：成员变量在对象创建的时候存到堆内存中，在对象被回收的时候销毁；局部变量在方法或者语句执行的时候创建，方法或者语句执行完销毁</li>
</ul>
<h4 id="构造方法">构造方法</h4>
<p>构造方法特点：与类同名、无返回值类型、可以重载；作用：创建对象。</p>
<p>如果在类中没有手动指定构造方法，那么在编译的时候自动添加一个构造方法（无参）。</p>
<h4 id="this关键字">this关键字</h4>
<p>由于在定义类的时候，本类的对象无法调用属性和方法，就利用this代替本类对象来调用本类中的属性和方法。</p>
<p>this代表本类在活动的对象的引用，可以认为是一个虚拟对象。</p>
<p>this.方法名：只能调用普通方法，不能调用构造方法。用this调用构造方法应该使用方法：this(参数)–this语句：表示调用本类中对应形式的构造方法，this语句必须放在构造方法的首行。</p>
<p>**补充：**在Java中，变量使用遵循就近原则。</p>
<h4 id="构造代码块">构造代码块</h4>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/13.png" alt="image-20230406205852035"></p>
<p>特点：定义在类内用{}括起来的代码，此时无论用哪个构造方法创建对象，都会执行一次（<strong>在构造方法之前运行</strong>）。一个类可以定义多个构造代码块（按代码块顺序依次运行）。</p>
<h4 id="局部代码块">局部代码块</h4>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/14.png" alt="image-20230406211122808"></p>
<h4 id="面向对象的特征">面向对象的特征</h4>
<h5 id="封装">封装</h5>
<p>体现形式：方法、属性私有化、内部类</p>
<p>属性的私有化：将属性用<strong>private</strong>修饰，然后提供对外的访问(getxx)和设置(setxx)的方法，在方法中进行限定，使属性值更加符合的场景要求。</p>
<p>优势：提高代码复用性、保证数据的合法性。</p>
<p>**权限修饰符：**限定变量或方法的使用范围</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/15.png" alt="image-20230406213052986"></p>
<p>**注意：**1、在本类中使用和本类对象使用不是一回事。2、哪个子类对象调用必须在对应的子类中，不能跨类。</p>
<h5 id="继承">继承</h5>
<p><strong>关键字：extends</strong> 父类/超类/基类，子类/派生类。</p>
<p>子类通过继承可以<strong>使用</strong>父类中的一部分方法和属性。<strong>注意：子类在继承父类的时候继承了父类全部的数据域（属性、方法），但是只有一部分的数据域对子类可见。</strong></p>
<p>在JAVA中，只支持的是单继承–一个子类只能继承一个父类，一个父类可以有多个子类。</p>
<p>单继承与多继承的比较：1、多继承比单继承能更好的提高代码的复用性。2、单继承相对多继承而言，能明确方法的调用。</p>
<p>**super关键字：**在子类中表示父类对象的引用，可以认为是一个虚拟对象。在子类中，通过super来调用父类中的方法和属性。</p>
<p>**super语句：**表示在子类的构造方法中调用父类对应形式的构造方法来创建一个父类对象。</p>
<ul>
<li>如果没有手动指定supr语句那么在编泽的时候会自动添加一个supr();</li>
<li>如果父类只提供了含参构造，那么在子类的构造方法中必须手动提供对应形式的super语句</li>
<li>supr语句必须放在子类构造方法的第一行</li>
</ul>
<p>**方法的重写：**在父子类中存在方法签名一致的非静态方法。<strong>限定：两等两小一大。</strong></p>
<ul>
<li>
<p>**一大：**子类在重写父类方法的时候，子类方法的权限修饰符的范围要大于等于父类对应方法的权限修饰符。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/17.png" alt="image-20230408210309459"></p>
</li>
<li>
<p>**一等：**方法签名要相同。</p>
</li>
<li>
<p>**一等：**如果父类方法的返回值类型是基本类型/void，那么子类重写的方法的返回值类型要和父类—致</p>
</li>
<li>
<p><strong>一小：</strong> 如果父类方法的返回值类型是引用类型，那么子类重写的方法的返回值类型要么和父类方法返回值类型一致要么是父类方法返回值类型的子类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	public mb()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">	public B m()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class D extends C&#123;</span><br><span class="line">	public B m()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20230408210701290.png" alt="image-20230408210701290"></p>
</li>
</ul>
<h5 id="多态">多态</h5>
<p>**编译时多态：**方法的重载。在编译期间就能够绑定当前调用的是哪种方法。</p>
<p>**运行时多态：**向上造型、方法的重写----基于继承</p>
<p><strong>向上造型：</strong></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/16.png" alt="image-20230408205921293"></p>
<p><strong>注意：利用向上造型创建的对象，能干什么看的是父类，具体的执行看子类。</strong></p>
<h3 id="静态–static">静态–static</h3>
<p>static是一个修饰符，可以修饰变量、方法、代码块、内部类</p>
<h4 id="静态变量">静态变量</h4>
<p>静态变量（类变量）在类加载的时候加载到方法区，并赋予默认值。由于静态变量先于对象出现，所以可以通过类名来调用静态变量。这个类的所有对象存储的是这个静态变量在方法区的地址，所以所有对象是共享这个静态变量。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/18.png" alt="image-20230408213739853"></p>
<p>**注意：**1、类是加载到方法区中——类中所有的信息都会加载方法区。2、类是第一次使用的时候加载到方法区，加载之后不在移除——意味着类只加载一次。</p>
<p>静态变量能否定义到构造方法中？——不可以。静态变量在类加载的时候加载到方法区；构造方法是在创建对象的时候调用，在栈内存中执行。</p>
<p>静态变量能否定义到构造代码块中？——不可以。静态变量在类加载的时候加载到方法区；构造代码块是在创建对象的时候调用，在栈内存中执行。</p>
<p><strong>注意：所有的静态只能定义在类中不能定义到代码块（方法）中。</strong></p>
<h4 id="静态方法-类方法">静态方法/类方法</h4>
<p>随着类的加载而加载到方法区，只是存储在方法区中，在被调用的时候到栈内存中执行。静态方法先于对象存在的，所以习惯上是通过类名来调用静态方法。</p>
<p>在静态方法中，能否直接使用本类中的非静态属性或者非静态方法？——不能，因为：  <img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/19.png" alt="image-20230409171122426"></p>
<p>静态 方法中能否定义静态变量？——不可以。静态变量在类加载的时候加载到方法区，静态方法在调用的时候才执行，并且是在栈内存中执行。</p>
<p>静态方法可以重载、继承、不能重写，但父子类中可以存在方法签名一致的静态方法，此时构成的是方法的隐藏（Hide）。此时向上造型，执行的是声明类中的方法而不是实际类的方法。如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	public static void m()&#123;System.out.println(&#x27;A&#x27;)&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	public static void m()&#123;System.out.println(&#x27;B&#x27;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a = new B();</span><br><span class="line">a.m();//结果是A，因为此时执行的是声明类中的方法。</span><br></pre></td></tr></table></figure>
<p>父子类中只要存在方法签名一致的方法，要么都是非静态（重写），要么都是静态（隐藏）。</p>
<h4 id="静态代码块">静态代码块</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代码块在类加载的时候执行一次——类只加载一次，因此静态代码块也只能执行一次。</p>
<p>**执行顺序：**父类静态-&gt;子类静态-&gt;父类非静态-&gt;子类非静态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SA&#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&#x27;1&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&#x27;2&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	public SA()&#123;</span><br><span class="line">		System.out.println(&#x27;3&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new SA();//结果为123,因为类加载的时候执行静态代码块，再在创建对象的时候执行构造代码块和构造方法。</span><br><span class="line"></span><br><span class="line">class SB extends SA&#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&#x27;4&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&#x27;5&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	public SB()&#123;</span><br><span class="line">		System.out.println(&#x27;6&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new SB();//142356</span><br></pre></td></tr></table></figure>
<p><strong>静态存储前两步：</strong></p>
<ul>
<li>
<p>解析—将静态变量放入方法区并标记，标记一个值0</p>
</li>
<li>
<p>初始化—执行静态代码块以及检查静态变量是否有值，如果有值，则去掉标记值0，将定义的值赋值进去；如果没有值，将标记值0赋值进去，这两部分是根据代码的先后来确定的。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/20.png" alt="image-20230409202319858"></p>
</li>
</ul>
<h3 id="final关键字">final关键字</h3>
<p>修饰符，修饰数据、方法、类。</p>
<h4 id="final修饰数据——常量">final修饰数据——常量</h4>
<p>常量的值在定义好后不可改变。对于基本类型而言，指的是实际值不可变。对于引用类型而言，限定的是地址不可变，不代表里面的属性不可变。常量可以先声明后赋值，但只能一次。</p>
<p>类里的常量要么在初始时给值，要么在对象创建完成之前赋值（构造代码块，构造方法，但要避免二次赋值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SA&#123;</span><br><span class="line">	final int a;</span><br><span class="line">	&#123;</span><br><span class="line">		a = 10;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态常量，如static final int i = 5;，要求在类加载完成之前赋值，所以要么直接赋值，要么在静态代码块里赋值。</p>
<h4 id="final修饰方法——最终方法">final修饰方法——最终方法</h4>
<p>最终方法不能被重写，不能被隐藏，可以重载，可以继承。</p>
<h4 id="final修饰类——最终类">final修饰类——最终类</h4>
<p>最终类不能被继承。</p>
<p>最终类：System、String</p>
<h3 id="abstract关键字">abstract关键字</h3>
<p>修饰符，abstract可以修饰方法、类。<strong>如果一个类的所有子类都重写了某个方法，那么这个时候可以把这个类中的这个方法的方法体省略，声明为一个抽象方法，如public abstract void m();。抽象方法，如abstract class Pet。</strong></p>
<p>非抽象子类在继承抽象类之后必须重写抽象类中抽象方法。</p>
<p>抽象类无法创建对象，但有构造方法。可以通过匿名内部类的方式来创建（实质是创建了一个它的子类），如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class Pet&#123;</span><br><span class="line">	public void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pet p = new Pet() &#123;</span><br><span class="line">	@override</span><br><span class="line">	public void eat()&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>抽象类不可以用final修饰。</li>
<li>抽象类中可以定义其他属性和方法</li>
<li>抽象方法所在的类必须是抽象类，抽象类中不一定有抽象方法</li>
<li>抽象方法可以重载、重写。</li>
<li>抽象方法不能用static、final、private修饰。</li>
</ul>
<h3 id="接口-interface">接口-interface</h3>
<p>如果一个类中的所有方法都是抽象方法，那么可以把这个类声明为一个接口。即用interface定义接口，接口中都是抽象方法（JDK1.8以前，JDK1.8开始允许接口中存在实体方法）。</p>
<p>接口里面的方法默认用public abstract修饰。接口可以定义属性，其默认使用public static final 修饰。</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>接口不允许创建对象。</p>
</li>
<li>
<p>接口没有构造器、构造方法——接口本身不是类</p>
</li>
</ul>
<h4 id="implements关键字">implements关键字</h4>
<p>通过implements关键字让接口与类产生联系——实现。</p>
<p>在JAVA中，单继承多实现——一个子类只能继承一个父类，一个类可以实现多个接口（class a implements A,B,C）。——如果实现多个接口，并且多个接口中存在方法签名一致的方法的时候会导致方法重写时产生冲突</p>
<p>接口可以继承接口，并且接口与接口之间是多继承。</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/21.png" alt="image-20230410211140158"></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/22.png" alt="image-20230410211246503"></p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/23.png" alt="image-20230410211834702"></p>
<h4 id="JDK1-8对接口的改进">JDK1.8对接口的改进</h4>
<ol>
<li>
<p>从JDK1.8开始，接口中允许定义实体方法——默认方法、静态方法。如果定义实体方法，需要将该方法用default或static修饰。</p>
</li>
<li>
<p>如果利用接口创建匿名内部类，需要在这个内部类中重写抽象方法。</p>
<ol>
<li>
<p>如果这个接口中只有一个抽象方法需要重写，可以用Lambda表达式（只有是用于实现只有一个抽象方法的接口）来写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Calculator&#123;</span><br><span class="line">	double add(double d1, double d2);</span><br><span class="line">&#125; </span><br><span class="line">//匿名内部类</span><br><span class="line">Calculator c = new Calculator()&#123;</span><br><span class="line">	@override</span><br><span class="line">	public double add(double d1, double d2)&#123;</span><br><span class="line">		return d1 + d2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// Lambda表达式</span><br><span class="line">Calculator c = (double d1, double d2) -&gt; &#123;</span><br><span class="line">	return d1 + d2;</span><br><span class="line">&#125;</span><br><span class="line">// 如果表达式里只有一句话，那么可以省略&#123;&#125;和return</span><br><span class="line">// 这个时候这唯一的一句话的执行结果默认为返回值</span><br><span class="line">Calculator c = (double d1, double d2) -&gt; d1 + d2;</span><br><span class="line">// 在执行这个方法的时候，参数类型是确定的，可以省略参数类型</span><br><span class="line">Calculator c = (d1, d2) -&gt; d1 + d2;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/24.png" alt="image-20230410215330414"></p>
</li>
</ol>
</li>
<li>
<p>当一个接口中只有一个抽象方法时，可以申明为函数式接口，可以用@FunctionalInterface声明。</p>
</li>
</ol>
<h3 id="内部类">内部类</h3>
<h4 id="方法内部类">方法内部类</h4>
<p>定义在方法中的类，又称局部内部类。</p>
<ul>
<li>只能在定义它的方法中使用。它的class文件名中含$符，如<code>Outer$1Inner</code>，前面为方法所在类，后面为内部类的类名，1为编号。</li>
<li>在方法内部类中不能定义静态变量和静态方法，但是可以静态常量。</li>
<li>方法内部类可以使用外部类中的属性和方法，可以使用外部类名.this.属性/方法，表示利用外部类中的this调用外部类中的属性或方法，如<code>Outer.this.i</code>。</li>
<li>JDK1.8特性：内部类使用当前方法中的数据的时候，要求这个数据是一个常量不可变，如果是变量，也会被认为是一个常量，即隐式声明。</li>
<li>方法内部类只能用abstract/final修饰。</li>
</ul>
<h4 id="成员内部类">成员内部类</h4>
<p>定义在类中的类。</p>
<ul>
<li>成员内部类不能在本类的静态方法中使用。</li>
<li>可以使用外部类中的一切属性和方法。</li>
<li>成员内部类不能定义静态变量和静态方法，可以定义静态常量。</li>
</ul>
<p>创建成员内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Inner是Outer的成员内部类</span><br><span class="line">// 利用外部类对象来创建一个内部类对象，前提对外部可见</span><br><span class="line">Outer.Inner oi = new Outer().new Inner();</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类">静态内部类</h4>
<p>用static修饰的内部类。</p>
<ul>
<li>静态内部类只能使用外部类的静态属性和静态方法。</li>
<li>静态内部类可以作用在整个类（本类的静态方法可以调用）。</li>
<li>可以定义静态属性和方法。</li>
</ul>
<p>静态内部类创建方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Inner是Outer的静态成员内部类</span><br><span class="line">// 利用外部类来创建一个内部类对象，前提对外部可见</span><br><span class="line">Outer.Inner oi = new Outer.Inner();</span><br></pre></td></tr></table></figure>
<h4 id="匿名内部类">匿名内部类*</h4>
<p>匿名内部类实际上是对应类的子类或者对应接口的实现类。</p>
<ul>
<li>任何一个接口都可以存在匿名内部类形式。</li>
<li>任何一个类只要可以被继承，就可以存在匿名内部类的形式。</li>
<li>如果匿名内部类定义在方法中，使用规则跟方法内部类一样。</li>
<li>如果匿名内部类定义在类中，使用规则跟成员内部类一样。</li>
</ul>
<h4 id="扩展">扩展</h4>
<p>在Java中，在类中可以定义类和接口，在接口中可以定义类和接口。</p>
<ul>
<li>类中的内部接口，默认是静态。</li>
<li>接口中的内部接口默认是静态，接口中的内部类默认也是静态。</li>
</ul>
<h3 id="包">包</h3>
<p>用package声明包，用import导入包。</p>
<p>包的作用：用于区分同名类、功能划分。</p>
<ul>
<li>
<p>在一个JAVA文件中，只能定义一个包。</p>
</li>
<li>
<p>声明包的package语句必须放在java文件的第一行。</p>
</li>
<li>
<p>导入某个包下所有类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">// * 在这里表示通配符。</span><br><span class="line">// 该语句表示导入util包下所有类，但不包括子包下的类。</span><br></pre></td></tr></table></figure>
</li>
<li>
<pre><code>java.lang 基本包，提供一个java程序运行所需要的基本类，这个包中的所有类在程序启动时就已经自动加载到内存中。

java.util 工具包，提供一系列便携操作的工具类，如Arrays。

java.io 数据传输相关包

java.math 数学运算包

java.nio 高并发相关包

java.net 网络编程相关包

java.text 格式化相关包

java.sql 数据库交互的包
</code></pre>
</li>
<li>
<p>java.lang和同包类不需要导包</p>
</li>
<li>
<p>注意：在声明包的时候尽量不要使用java/javax/org</p>
</li>
</ul>
<h3 id="垃圾回收分代机制">垃圾回收分代机制</h3>
<p>注：方法区不考虑回收，只进不出（程序运行期间）。栈内存是用完立即释放，不考虑回收。</p>
<p><strong>垃圾回收针对堆内存的。</strong></p>
<p>在Java中，每一个类型的大小是固定的，所以所有内存由Java来自动分配，也是自动回收的——垃圾收集器（Garbage Collector, GC）。</p>
<p>对象在使用完成之后不一定立即回收而是在不确定的某个时刻回收——当堆内存的使用率超过70%的时候，GC才会启动回收。</p>
<h4 id="回收过程">回收过程</h4>
<p><strong>将堆内存划分为新生代和老生代，将新生代划分为伊甸园区和幸存区。</strong></p>
<p>对象刚创建的时候是放到伊甸园区，在伊甸园区经过一次扫描，如果对象依然存在则挪到幸存区。如果在幸存区中经过多次扫描依然存在，则挪到老生代。幸存区扫描频率低于伊甸园区，老生代扫描频率远低于新生代。<strong>老生代的对象一 旦产生回收可能会导致程序的卡顿甚至崩溃。</strong></p>
<p>发生在新生代的回收：minor gc（初代回收）</p>
<p>发生在老生代的回收：full gc（完全回收）</p>
<p><img src="/2023/04/03/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/25.png" alt="image-20230417201443469"></p>
<h3 id="内存">内存</h3>
<p>java将占用的内存分为了5块：栈内存、堆内存、方法区、本地方法栈、PC计数器（寄存器）。</p>
<h4 id="栈内存">栈内存</h4>
<p>栈内存：存储的变量。变量在声明的时候存储到栈内存中，不会自动给值，只能手动给值。变量在栈内存中使用完成之后要立即释放。</p>
<p>方法在栈内存中执行，因此方法递归深度太大，会出现栈溢出错误。</p>
<p>方法在栈内存中执行。</p>
<h4 id="堆内存">堆内存</h4>
<p>堆内存：存储的是对象。对象在存储到堆内存中之后，会被堆内存赋予一个默认值：byte/short/int：0，long ：0L ，float ：0.0f，double ：0.0，char：‘\u0000’，boolean：false。其他类型一律是null。对象使用完成不一定会从堆内存中立即移除，而是在某个不确定的时刻被回收。</p>
<h4 id="方法区">方法区</h4>
<p>java文件编译后的class文件存在方法区，同时还有java核心类库。</p>
<p>将类加载进来，并分成两块，分别存储非静态属性和方法以及静态属性和方法（赋予默认值）。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础：API</title>
    <url>/2023/04/17/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9AAPI/</url>
    <content><![CDATA[<h2 id="JAVA基础：API（应用程序接口）">JAVA基础：API（应用程序接口）</h2>
<h3 id="Object">Object</h3>
<p>顶级父类——任何一个类都直接或者间接继承Object——任何一个类的对象都可以赋值给一个Object对象。</p>
<h4 id="protected-Object-clone">protected Object clone()</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">demo1</span> <span class="variable">b</span> <span class="operator">=</span> (demo1) a.clone();</span><br></pre></td></tr></table></figure>
<ul>
<li>一个类所产生的对象要想被克隆，那么这个类必须实现Cloneable接口（这个接口没有任何的方法和属性，仅仅用作一个标记）。</li>
<li>该方法是产生了一个新对象，而新对象的属性和原对象一致。</li>
<li>由于它的修饰词为protected，所以一个类要使用clone，只能在该类中使用。</li>
</ul>
<h4 id="public-boolean-equals-Object-obj">public boolean equals(Object obj)</h4>
<p>判断其他对象是否与此对象“相等”。底层使用==进行比较，==默认比较的是地址。</p>
<p>当要比较两对象的属性是否一致时，需要重写equals()方法，重写一般分为以下几步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断参数是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断参数是否为null</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断类型是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下一步开始比较两个对象的属性是否一致，之前需要将obj强转为当前对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="protected-void-finalize">protected void finalize()</h4>
<p>当垃圾回收确定不再有对对象的引用时，由垃圾回收器对该对象调用。</p>
<ul>
<li>
<p>该方法并不是直接调用GC，而是通知GC进行回收。</p>
</li>
<li>
<p>对GC仅仅起通知作用，GC不一定启动。</p>
</li>
<li>
<p>System.gc();语句的实现就是通过finalize()，因此也不是直接调用GC，而是通知GC。</p>
</li>
</ul>
<h4 id="public-Class-getClass">public Class&lt;?&gt; getClass()</h4>
<p>返回此对象的运行时类。此时返回的是对象的实际类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">System.out.println(c.getClass());</span><br><span class="line"><span class="comment">//结果为：class java.lang.String</span></span><br></pre></td></tr></table></figure>
<h4 id="public-int-hashCode">public int hashCode()</h4>
<p>哈希码根据哈希散列算法计算出来的，哈希散列算法要求计算出来的值随机散落在int的取值范围内。由于取值范围较大，导致每一个对象与其他对象的哈希码取值重合概率太小，所以人为认定哈希码是唯一的。因此在存储对象的时候也以对象的哈希码作为基准。</p>
<h4 id="public-String-toString">public String toString()</h4>
<p>返回对象的字符串表示形式。</p>
<ul>
<li>当直接打印对象的时候，实际上底层默认调用对象的toString()方法。</li>
<li>可以重写toString()方法来自定义输出格式。</li>
<li>Bin：二进制 Oct：八进制 Dec：十进制 Hex：十六进制</li>
</ul>
<h3 id="String">String</h3>
<h4 id="构造方法-2">构造方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>String类表示字符串。Java程序中的所有字符串文字，如“abc”，都是作为此类的实例实现的。底层使用final char数组存储。</p>
</li>
<li>
<p>任何的字符串都是String的对象。</p>
</li>
<li>
<p>字符串是常量；它们的值在创建后不能更改。字符串缓冲区支持可变字符串。因为String对象是不可变的，所以它们可以共享。</p>
</li>
<li>
<p>字符串存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">//指向常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//指向堆内存</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/04/17/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9AAPI/1.png" alt="image-20230418213514926"></p>
</li>
<li>
<pre><code class="language-java">String s4 = &quot;a&quot;;
s4 = s4 + &quot;b&quot;;//字符串在+拼接时，实际上调用了StringBuilder中的append方法
// s4 = new StringBuilder(s4).append(&quot;b&quot;).toString() 相当于
// S4 = new String(&quot;ab&quot;);
// s1 != s4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 当大量字符串进行拼接时，StringBuilder的效率远高于+，如果需要拼接多个字符串，建议使用StringBuilder（底层使用char数据存储，无final修饰）。</span><br><span class="line"></span><br><span class="line">- StringBuilder类和StringBuffer类中的方法签名一模一样的，StringBuilder类本身是线程不安全的，StringBuffer类本身是线程安全的。</span><br><span class="line"></span><br><span class="line">#### 常用方法</span><br><span class="line"></span><br><span class="line">字符串中提供了一系列的操作而不改变原字符串的方法，会产生一个新的字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>String str = “zgasdsahd”;</p>
<p>// 获取字符串的长度<br>
str.length()</p>
<p>// 指定下标上的字符<br>
str.charAt(index);</p>
<p>// 将字符串转换为字符数组<br>
str.toCharArray();</p>
<p>// 将字符数组转换为字符串<br>
char[] cs= {‘d’,‘a’,‘c’};<br>
String str = new String(cs);//全部转换<br>
String str = new String(cs, offset, count);//部分转换，从offset开始总共count个字符</p>
<p>// 字符串转为大写<br>
str.toUpperCase();</p>
<p>// 字符串转为小写<br>
str.toLowerCase();</p>
<p>// 判断字符串是否一致<br>
str.equals(str2);<br>
str.equalsIgnoreCase(str2); //忽略大小写</p>
<p>// 拼接字符串，底层利用数组复制实现<br>
str.concat(str2);</p>
<p>// 判断字符串是否包含指定的子串<br>
str.contains(str2);</p>
<p>// 判断字符串是否以指定子串结尾<br>
str.endsWith(str2);</p>
<p>// 判断字符串是否以指定子串开头<br>
str.startsWith(str2);</p>
<p>// 将字符串转换为字节数组<br>
str.getBytes(); //在转换时如果没有指定编码，默认使用当前工程的默认编码<br>
str.getBytes(“gbk”); //指定编码，gbk utf-8</p>
<p>// 将字节数组转换为字符串<br>
String str = new String(字节数组,“gbk”);//指定编码进行构造<br>
String str = new String(字节数组,start,num,“gbk”);//指定编码进行构造，并只从开始位置起的num个字节。</p>
<p>// 获取哈希码，底层实现是通过迭代加和实现，hash = hash * 31 + c，c为字符串中的字符。<br>
str.hashcode(); //字符串在Java中存储的时候用的字符数组，char类型用的的编码是utf-16，因此同一个字符串的哈希码在任何条件下都是相同的。</p>
<p>// 获取字符串中指定元素（字符、字符串都可）第一次出现的下标，无就返回-1<br>
str.indexOf(str2)<br>
str.indexOf(str2, start) // 从start位置开始找起，返回的index依然为在整个字符串中的下标</p>
<p>// 返回字符串对象的规划化表示形式<br>
str.intern() //该方法强制返回常量池的值</p>
<p>// 判断字符串是否为空(“”),不能判断是否为null。<br>
str.isEmpty()</p>
<p>// 获取字符串中指定元素（字符、字符串）最后一次出现的下标，无就返回-1<br>
str.lastIndexOf(str2)<br>
str.lastIndexOf(str2, end) // 从end位置向前找起，返回的index依然为在整个字符串中的下标</p>
<p>// 用指定字符替换为原字符<br>
str.replace(oldchar, newchar)</p>
<p>// 截取子字符串<br>
str.substring(start) // 从start位置开始，截取到末尾<br>
str.substring(start, end) // 从start位置开始，截取到end(不包括)</p>
<p>// 注意：字符串的toString方法返回的是它本身，不再是地址。</p>
<p>// 去掉字符串前后的空白字符，包括转折、回车等<br>
str.trim()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### int res = str1.compareTo(str2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// 按字典顺序(字符升序)比较两个字符串<br>
int res = str1.compareTo(str2);<br>
// 如果不考虑大小写<br>
int res = str1.compareToIgnoreCase(str2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 按字典顺序比较两个字符串</span><br><span class="line">- s1,s2在]ava底层是以字符数组形式存储</span><br><span class="line">- 在比较两个字符串的时候，遍历两个字符数组 </span><br><span class="line">- 将字符数组的对应位置上字符进行相减</span><br><span class="line">- 如果这一位相减不为0，那么就将这个相减的差作为结果返回；如果这一位相减为0，则继续遍历，计算下一位 </span><br><span class="line">- 如果每一位相减都为0并且一个字符串先遍历完了，返回两个字符串的长度之差</span><br><span class="line">- **如果返回值为0表示s1 = s2**</span><br><span class="line">- **如果返回值为正数，表示s1 &gt; s2；如果返回值为负数，表示s1 &lt; s2**</span><br><span class="line"></span><br><span class="line">#### instanceof：判断类和对象的关系</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对象 instanceof 类/接口 //表示判断对象是否指定类/接口及其父类/父接口的对象，这里对象看的是实际对象（即A a = new B(); a instanceof B;中比较的是B和B）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20230421162117975](JAVA基础：API/2.png)</span><br><span class="line"></span><br><span class="line">#### valueOf方法</span><br><span class="line"></span><br><span class="line">静态方法，表示将其他类型数据转化为字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>String str = String.valueOf(6);</p>
<p>Object o = new Object();<br>
String str = String.valueOf(o); // 对一个对象进行valueOf操作时，实际上调用了这个对象的toString方法。字符数组除外</p>
<p>char[] cs = {‘a’,‘b’,‘c’}<br>
String str1 = String.valueOf(cs); // str1:abc<br>
String str2 = cs.toString();//类名+地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### replaceAll方法</span><br><span class="line"></span><br><span class="line">匹配指定字符并替换，匹配不成功的部分保留。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">str.replaceAll(regex, replacement); // regex:正则表达式，replacement:替换字符</span><br><span class="line"></span><br><span class="line">String str = &quot;asdasfaf113&quot;;</span><br><span class="line">// 将所有数字替换成+</span><br><span class="line">str.replaceAll(&quot;\\d&quot;,&quot;+&quot;);</span><br><span class="line"></span><br><span class="line">// 将所有字母提取出来形成字符串</span><br><span class="line">str.replaceAll(&quot;[^a-zA-Z]&quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">//交换Sam和Cat的位置</span><br><span class="line">str.replaceAll(&quot;(.*)(Sam)(.*)(Cat)(.*)&quot;,&quot;$1$4$3$2$5&quot;); // $ 表示引用前面正则表达式的捕获组</span><br></pre></td></tr></table></figure>
<h4 id="split方法">split方法</h4>
<p>以指定规则进行切分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str. split(regex);<span class="comment">// regex：正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12dks3sol33df24&quot;</span>;</span><br><span class="line"><span class="comment">// 以数字作为边界，将这个字符串切分</span></span><br><span class="line">String[] arr = str.split(<span class="string">&quot;\\d&quot;</span>); <span class="comment">// 如果多个边界符相邻，则中间切割出&quot;&quot;字符串。如果边界符在最后，则直接切除。</span></span><br><span class="line"><span class="comment">// 上述结果：[, , dks, sol, , df]</span></span><br></pre></td></tr></table></figure>
<h3 id="Pattern类——正则表达式-Regular-Expression-REGEX">Pattern类——正则表达式-Regular Expression-REGEX</h3>
<h4 id="包-2">包</h4>
<p>java.util.regex</p>
<h4 id="基本语法">基本语法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产生正则对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(s);<span class="comment">// s：匹配规则</span></span><br><span class="line"><span class="comment">// 匹配器，将正则对象和实际对象进行匹配</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);<span class="comment">// str:待匹配字符串</span></span><br><span class="line"><span class="comment">// 进行判断</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.matches();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述流程可以简化为</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(s); <span class="comment">// 调用字符串的matches方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则语法示例部分1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串由3个字符组成，第一个字符是a/b/c中的一个，第二个字符是1/m/n一个，第三个字符是h/i/j/k的一个</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[abc][lmn][hijk]&quot;</span>; <span class="comment">// []表示匹配里面任意一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由一个字母或数字组成的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z0-9]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由一个字符组成的字符串，不包括a/b/c</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[[a-z]&amp;&amp;^a-c]&quot;</span>; <span class="comment">// 非逻辑,[]里面的^表示除里面的字符，匹配其余所有字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由一个字母组成的字符串，但不包括a/b/c</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[[a-z]&amp;&amp;^a-c]&quot;</span>; <span class="comment">// &amp;&amp;表示与的意思，前后同时满足</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配以数字开头的由两个字符组成的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[0-9].&quot;</span>; <span class="comment">// .是通配符，表示任意字符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 匹配.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\\.&quot;</span>; <span class="comment">//先由java进行转义，转义为\.，然后再由正则进行转义，转义为.。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配\</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\\\\&quot;</span>; <span class="comment">//先由java进行转义，转义为\\，然后再由正则进行转义，转义为\。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/04/17/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9AAPI/3.png" alt="image-20230424211149485"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则语法示例部分2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量词——每一个字符之和最多有一个</span></span><br><span class="line"><span class="comment">// 匹配由数字开头的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\\d.*&quot;</span>;<span class="comment">// * 表示之前的这个字符可以出现可以不出现 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由数字开头的至少由两个字符组成的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\\d.+&quot;</span>;<span class="comment">// + 表示之前的这个字符至少出现一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由数字开头的至多由两个字符组成的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\\d.?&quot;</span>;<span class="comment">// ? 表示之前的这个字符最多出现一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由字母组成的长度为5的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z]&#123;5&#125;&quot;</span>;<span class="comment">// &#123;n&#125; 表示之前的这个字符出现n次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由字母组成的长度至少为5的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z]&#123;5,&#125;&quot;</span>;<span class="comment">// &#123;n,&#125; 表示之前的这个字符至少出现n次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配由字母组成的长度为6到12的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z]&#123;6,12&#125;&quot;</span>;<span class="comment">// &#123;n,m&#125; 表示之前的这个字符至少出现n次，最多出现m次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配至少含有一个连续&quot;ab&quot;的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;.*(ab)+.*&quot;</span>;<span class="comment">// (字符) 表示将这些字符作为一个整体进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配dababcdseababfsa这类字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;.*(ab)+.*\\1+.*&quot;</span>;<span class="comment">// \\n 表示引用编号为n的捕获组，正则表达式会对包含的捕获组进行编号，编号从1开始计算，且从&#x27;(&#x27;出现的位置开始计数的。如 (A(BC)D) 编号1：(A(BC)D) 编号2：(BC)。</span></span><br><span class="line"><span class="comment">// 如匹配叠字：aaa,bbb这种</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;(.)\\1+&quot;</span>; <span class="comment">//这里匹配到第一个字符后，使用\\1来引用该字符，然后使它出现至少1次，而&quot;(.)+&quot;表示匹配至少两个字符。</span></span><br></pre></td></tr></table></figure>
<h3 id="Math类——数学类">Math类——数学类</h3>
<h4 id="包-3">包</h4>
<p>java.lang.Math</p>
<p>public final class Math，最终类。Math类包含用于执行基本数字运算的方法，如初等指数函数、对数函数、平方根函数和三角函数。Math类是针对类型进行运算的。</p>
<p>Math里面的方法都是静态，不支持对外创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line">Math.E; <span class="comment">// 自然对数</span></span><br><span class="line">Math.PI; <span class="comment">// 圆周率</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line">Math.ceil(<span class="number">3.2</span>); <span class="comment">// 返回值: double 结果：4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line">Math.floor(<span class="number">3.2</span>); <span class="comment">// 返回值: double 结果：3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四舍五入</span></span><br><span class="line">Math.round(<span class="number">3.2</span>); <span class="comment">// 返回值：double-&gt;long,float-&gt;int 结果：3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机值</span></span><br><span class="line">Math.random(); <span class="comment">// 返回一个double值，其大于等于0，小于1。</span></span><br><span class="line"><span class="comment">// 求随机数的一个类Random</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); </span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 返回10以内的随机数</span></span><br><span class="line">r.nextInt(<span class="number">50</span>) + <span class="number">30</span>; <span class="comment">// 返回30-80以内的随机数</span></span><br></pre></td></tr></table></figure>
<h4 id="补充-2">补充</h4>
<p>关键字：strictfp，只能作用在方法上，表示方法正在计算过程中是以80位二进制进行计算，在计算完成之后依然会以64位二进制进行存储。</p>
<p>类：BigDecimal，不可变的、任意精度的带符号十进制数。要想使用BigDecimal进行精确存储和计算，那么需要将参数以字符串形式传入。</p>
<p>类：BigInteger：存储、计算任意大小的整数的类，参数以字符串传入。</p>
<h3 id="包装类">包装类</h3>
<p>由于基本类型身上没有方法和属性，所以为了快捷的操作这些数据，针对每一种基本类型提供了对应的类形式。</p>
<p><img src="/2023/04/17/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9AAPI/4.png" alt="image-20230425203844564"></p>
<h4 id="Void类">Void类</h4>
<p>位于java.lang包，且定义形式为：public final class Void extends Object。</p>
<p>Void类是一个不可实例化的占位符类，用于保存对表示Java关键字Void的class对象的引用。特点：最终类，不可实例化。所以当一个方法的返回值类型为Void类时，其只能返回null。</p>
<h4 id="数值型包装类">数值型包装类</h4>
<p>Byte、Short、Integer、Long、Float、Double。</p>
<p>位于java.lang.Number包。特点：最终类</p>
<h5 id="以Integer类为例">以Integer类为例</h5>
<p>Integer类将基本类型int的值包装在对象中。Integer类型的对象包含一个类型为int的字段。此外，这个类提供了几个将int转换为String和将String转换为int的方法，以及处理int时有用的其他常量和方法。</p>
<p><strong>常用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;789&quot;</span>); <span class="comment">// 逐位判断是否合法，并计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将基本类型的变量直接赋值给对应的引用类型的对象——（自动封箱）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">in</span> <span class="operator">=</span> i; <span class="comment">// 当进行自动封箱的时候，底层会默认调用当前类中的valueOf方法进行封箱：Integer in = Integer.valueOf(i);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// valueOf方法，静态方法</span></span><br><span class="line">Integer.valueOf(<span class="type">int</span>/String i);<span class="comment">// 返回一个Integer实例，该实例表示指定的int/String值。</span></span><br><span class="line"><span class="comment">// 该方法对于Byte、Short、Integer、Long这四种整数类型有一个特性（以Integer为例）：当数值范围在-128~127之间的时候，返回Integer.cache中对应下标上的值，因此在此范围内的两个Integer对象==判断为真，超过这个范围就为假（new了新的Integer对象）。对于其他三种，范围都是-128~127。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用类型的对象直接赋值给了对应的基本类型的变量——（自动拆箱）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> in; <span class="comment">// 当进行自动拆箱的时候，底层会调用对应对象的***Value()方法进行拆箱：int i = in.intValue();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// intValue方法</span></span><br><span class="line">Integer in;</span><br><span class="line">in.intValue(); <span class="comment">// 以int形式返回此Integer的值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseInt方法，静态方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;567&quot;</span>);<span class="comment">// 将字符串参数作为有符号的十进制整数进行解析</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE <span class="comment">// int类型能够表示的最大值</span></span><br><span class="line">Integer.MIN_VALUE <span class="comment">// int类型能够表示的最小值</span></span><br><span class="line">    </span><br><span class="line">Double.NaN <span class="comment">// double类型的非数字not-a-number，唯一，和任何值（包括自己）都不相等。因此，判断NaN的方式：调用Double的静态方法:Double.isNaN(double v);或者调用Double对象自身的isNaN()方法来判断当前值是不是NaN。</span></span><br><span class="line">Double.POSITIVE_INFINITY <span class="comment">// double类型的正无穷，与自身相等</span></span><br><span class="line">Double.NEGATIVE_INFINITY <span class="comment">// double类型的负无穷，与自身相等</span></span><br></pre></td></tr></table></figure>
<h4 id="Character类">Character类</h4>
<p>只有一种构造方法，即char转化为Character。</p>
<p>没有parse这种字符串的解析方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.MAX_VALUE <span class="comment">// \uFFFF</span></span><br><span class="line">Character.MIN_VALUE <span class="comment">// \u0000</span></span><br></pre></td></tr></table></figure>
<h4 id="Boolean类">Boolean类</h4>
<p>当使用字符串进行创建Boolean对象时，如果字符串参数不为null并且等于字符串“true”（忽略大小写），则分配一个表示值true的布尔对象，其余均为false。</p>
<h4 id="包装类的hashcode方法">包装类的hashcode方法</h4>
<p>包装类的hashcode方法得到的哈希码不会改变。</p>
<ul>
<li>
<p>Byte、Short、Integer的hashcode()结果为其本身的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">8</span>);</span><br><span class="line">i.hashcode(); <span class="comment">// 结果为：8</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Long由于哈希码为int类型，所以不会是其值本身，hashcode()结果为：前32位与后32位异或结果。</p>
</li>
<li>
<p>Double则是将一个double转为long类型数，然后进行前32位与后32位异或，得到最终hashcode()结果。</p>
</li>
<li>
<p>Float则是将一个float转为int，然后返回。</p>
</li>
<li>
<p>Character的hashcode()方法则是将char强制转为int，然后返回。</p>
</li>
<li>
<p>Boolean的hashcode()方法结果为：值为true：返回1231；值为false：返回1237。</p>
</li>
</ul>
<h4 id="注意-3">注意</h4>
<p>包装类型在和基本类型进行运算的时候，会自动拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">i == j; <span class="comment">// True</span></span><br></pre></td></tr></table></figure>
<p>字面量的哈希码是固定不变的（null的哈希码规定为0）。所有的字面量都是存储在运行时常量池。</p>
<p>运行时常量池存储的是字面量以及自定义常量。</p>
<h3 id="日期类">日期类</h3>
<h4 id="Date类">Date类</h4>
<p>这里使用的是java.util.Date，代表日期的类，精确到毫秒。</p>
<p>字符串和日期进行转换：SimpleDateFormat，字符串-&gt;日期：parse方法，日期-&gt;字符串：format方法，使用时需要指定格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取的是当前的系统时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此种方法已过时</span></span><br><span class="line"><span class="comment">// 当需要指定日期时，可以指定参数</span></span><br><span class="line"><span class="comment">// 此时底层是在1900-01的基础上进行累加的</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2100</span>-<span class="number">1900</span>,<span class="number">12</span>-<span class="number">1</span>,<span class="number">17</span>);<span class="comment">// 此时代表2100年12月17日</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转换为日期对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2000-01-17 13:45:11&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh时mm分ss秒&quot;</span>).format(date);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Calendar类">Calendar类</h4>
<p>java.util.Calendar类，抽象类，代表日历的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Calendar对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<h4 id="LocalDate类">LocalDate类</h4>
<p>从JDK1.8开始，对时间体系进行了新的划分，将日期和时间进行分离，并且详细区分，从而形成了一个新的包——时间包 java.time包。</p>
<p>包；java.time。最终类。只包含日期，不包含时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前默认时区的日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(year, month, day);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期为一周中的第几天</span></span><br><span class="line">date.getDayOfWeek(); <span class="comment">// 直接返回星期几</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期为一年中的第几天</span></span><br><span class="line">date.getDayOfYear(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取年</span></span><br><span class="line">date.getYear(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取月</span></span><br><span class="line">date.getMonth(); <span class="comment">// 之间返回月份，如果需要返回数字：date.getMonthValue()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日</span></span><br><span class="line">date.getDayOfMonth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期比较</span></span><br><span class="line">date.isAfter(date1);</span><br><span class="line">date.isBefore(date1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断闰年</span></span><br><span class="line">date.isLeapYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这月有几天</span></span><br><span class="line">date.lengthOfMonth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这年有几天</span></span><br><span class="line">date.lengthOfYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时只支持日期单位的加减</span></span><br><span class="line"><span class="comment">// 日期加,如加3天</span></span><br><span class="line">date.plus(<span class="number">3</span>, ChronoUnit.DAYS);</span><br><span class="line"><span class="comment">// 日期减,如减3天</span></span><br><span class="line">date.minus(<span class="number">3</span>, ChronoUnit.DAYS);</span><br></pre></td></tr></table></figure>
<h4 id="LocalTime类">LocalTime类</h4>
<p>包；java.time。最终类。只包含时间，不包含日期。方法使用同LocalDate类。</p>
<h3 id="异常">异常</h3>
<p>异常在Java中式用于问题的反馈和处理的机制。</p>
<h4 id="异常的基本处理流程">异常的基本处理流程</h4>
<p><img src="/2023/04/17/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9AAPI/5.png" alt="image-20230426155550279"></p>
<h4 id="异常的特点">异常的特点</h4>
<p>异常的顶级父类（除了Object）是Throwable。</p>
<h4 id="Throwable类">Throwable类</h4>
<p>Throwable类是Java语言中所有错误和异常的超类。</p>
<h5 id="Error：错误">Error：错误</h5>
<p>Error是Throwable的一个子类，表示合理的应用程序（<strong>逻辑、语法没问题</strong>）不应该试图捕捉（<strong>特点：一旦出现，不能处理</strong>）的严重问题。</p>
<p>其中一个重要子类：<strong>VirtualMachineError</strong>（<strong>StackOverflowError</strong>（当应用程序递归过深而导致堆栈溢出时抛出）、<strong>OutOfMemoryError</strong>（当Java虚拟机由于堆内存不足而无法分配对象，并且垃圾收集器无法提供更多堆内存时抛出。））</p>
<h5 id="Exception：异常">Exception：异常</h5>
<p>出现之后可以处理，处理方法有两种：一种是捕获、一种是继续抛出。</p>
<p>一旦抛出异常对象，后续代码停止执行。异常处理完成后，后续代码（<strong>处理所在方法的后续，而不是抛出异常的方法后续</strong>）可以执行。</p>
<p>根据异常出现的时间，将异常划分为两类：编译时异常、运行时异常。</p>
<p>**编译时异常：**由于在编译的时候就已经出现，所以要求必须处理</p>
<table>
<thead>
<tr>
<th style="text-align:center">异常</th>
<th style="text-align:center">异常名</th>
<th style="text-align:center">原因</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CloneNotSupportedException</td>
<td style="text-align:center">克隆不支持异常</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ParseException</td>
<td style="text-align:center">解析异常</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>**运行时异常：**在运行的时候才出现，可以处理，也可以不处理。</p>
<table>
<thead>
<tr>
<th style="text-align:center">异常</th>
<th style="text-align:center">异常名</th>
<th style="text-align:center">原因</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArithmeticException</td>
<td style="text-align:center">算术异常</td>
<td style="text-align:center">非0/0</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ArrayIndexOutofBoundsException</td>
<td style="text-align:center">数组索引异常</td>
<td style="text-align:center">数组越界</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NullPointerException</td>
<td style="text-align:center">空指针异常</td>
<td style="text-align:center">对null进行使用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ClassCastException</td>
<td style="text-align:center">类型强制转换异常</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">PatternSyntaxException</td>
<td style="text-align:center">正则表达式格式异常</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="自定义异常">自定义异常</h4>
<p>定义一个类继承某个异常类，如果继承的是Exception或者是其他的异常，那么就定义了一个编译时异常；如果继承的是RuntimeException（<strong>运行时异常的父类</strong>）或者是它的子类，那么就定义了一个运行时异常。</p>
<h5 id="基本流程">基本流程</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exceptionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            readTxt(<span class="string">&quot;D://1.png&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (PathNotExistException e)&#123;</span><br><span class="line">            System.out.println(e.getStr());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileFormatException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readTxt</span><span class="params">(String path)</span> <span class="keyword">throws</span> PathNotExistException, FileFormatException&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;H://&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PathNotExistException</span>(<span class="string">&quot;H盘不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!path.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileFormatException</span>(<span class="string">&quot;文件格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PathNotExistException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathNotExistException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathNotExistException</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(str); <span class="comment">// 调用父类的message</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异常的捕获方式">异常的捕获方式</h4>
<h5 id="1、多异常时的捕获方式">1、多异常时的捕获方式</h5>
<ol>
<li>
<p>如果多个异常的处理方式不一样，可以使用多个catch来分别捕获、分别处理。</p>
</li>
<li>
<p>如果所有异常的处理方法都一样，可以捕获一个父类异常进行统一处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果多个异常分成了不同的组来进行处理，那么同一个组异常之间可以用 | 隔开。这种捕获方式从jdk1.7开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;catch(Exception1 | Exception2 e)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;catch(Exception3)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="2、抛出父类异常">2、抛出父类异常</h5>
<p>在抛出异常时，可以之间抛出一个父类异常，此时在捕获异常时，不仅需要对具体子类异常进行处理，还需要对父类异常进行处理，且只能最后处理父类异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exceptionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            readTxt(<span class="string">&quot;D://1.png&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (PathNotExistException e)&#123;</span><br><span class="line">            System.out.println(e.getStr());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileFormatException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        	 System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="comment">// 这里需要对父类异常进行最后处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readTxt</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception&#123; <span class="comment">//这里直接抛出父类异常</span></span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;H://&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PathNotExistException</span>(<span class="string">&quot;H盘不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!path.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileFormatException</span>(<span class="string">&quot;文件格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PathNotExistException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathNotExistException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathNotExistException</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、打印异常的栈轨迹">3、打印异常的栈轨迹</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如图类似：</p>
<p><img src="/2023/04/17/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9AAPI/6.png" alt="image-20230426194315280"></p>
<h4 id="方法的重载、重写过程中异常的抛出">方法的重载、重写过程中异常的抛出</h4>
<p>异常不影响重载，重载方法可以不抛出异常、抛出其他异常、抛出相同异常均可。</p>
<p>在重写时，子类抛出的编译时异常不能超过父类编译时异常的范围（<strong>跟向上造型有关</strong>），对运行时异常不限定。<strong>子类不能抛出比父类更多的异常（编译时异常、更多指的是范围，不是个数）</strong>。</p>
<h4 id="finally关键字">finally关键字</h4>
<p>之前无论出现异常与否，无论如何都会执行一次。必须结合try使用，用于完成一些善后的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(<span class="number">5</span>/<span class="number">2</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;it is exception&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;it is in exception finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：2 \n it is in finally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(<span class="number">5</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;it is exception&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;it is in exception finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：it is exception \n it is in finally</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;<span class="comment">//结果为2：为使得finally至少执行一次，在返回前，会执行finally的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;<span class="comment">// 这条语句会报错，因为finally里面有return语句使得当前语句不可能执行。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 代码是从上到下从左到右来依次编译运行的</span></span><br><span class="line">    <span class="comment">// 先编译 return i++;</span></span><br><span class="line">    <span class="comment">// 先编译出return 3; -&gt; 表示将3作为结果返回，将3标记为结果</span></span><br><span class="line">    <span class="comment">// 由于return在try之内，所有在返回结果之前需要先检查是否有finally需要执行，这里有，所有程序继续</span></span><br><span class="line">    <span class="comment">// 然后编译i++ -&gt; i = 4</span></span><br><span class="line">    <span class="comment">// 当finally执行完成之后，需要返回结果，此时由于将3标记为结果，所有返回3</span></span><br><span class="line">    <span class="keyword">return</span> i++; <span class="comment">// 返回 3</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 编译i ++，i -&gt; 5。</span></span><br><span class="line">    i++;</span><br><span class="line">    System.out.print(i);<span class="comment">// 结果：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之每日一题：2022-5-10</title>
    <url>/2022/05/10/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-10/</url>
    <content><![CDATA[<h2 id="问题介绍-2">问题介绍</h2>
<h3 id="题目：猫和老鼠-II">题目：猫和老鼠 II</h3>
<p>一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。它们所处的环境设定是一个<code>rows x cols</code>的方格 grid，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。</p>
<ul>
<li>玩家由字符 ‘C’ （代表猫）和 ‘M’ （代表老鼠）表示。</li>
<li>地板由字符 ‘.’ 表示，玩家可以通过这个格子。</li>
<li>墙用字符 ‘#’ 表示，玩家不能通过这个格子。</li>
<li>食物用字符 ‘F’ 表示，玩家可以通过这个格子。</li>
<li>字符 ‘C’ ， ‘M’ 和 ‘F’ 在 grid 中都只会出现一次。</li>
</ul>
<p>猫和老鼠按照如下规则移动：</p>
<ul>
<li>老鼠先移动，然后两名玩家轮流移动。</li>
<li>每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，它们不能跳过墙也不能跳出 grid 。</li>
<li>catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。</li>
<li>它们可以停留在原地。</li>
<li>老鼠可以跳跃过猫的位置。</li>
</ul>
<p>游戏有 4 种方式会结束：</p>
<ol>
<li>如果猫跟老鼠处在相同的位置，那么猫获胜。</li>
<li>如果猫先到达食物，那么猫获胜。</li>
<li>如果老鼠先到达食物，那么老鼠获胜。</li>
<li>如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。</li>
</ol>
<p>给你 rows x cols 的矩阵 grid 和两个整数 catJump 和 mouseJump ，双方都采取<strong>最优策略</strong>，如果老鼠获胜，那么请你返回 true ，否则返回 false 。</p>
<h3 id="示例-46">示例</h3>
<p>1、</p>
<p><img src="/2022/05/10/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-10/1.png" alt="image-20220510184546749"></p>
<p>输入：grid = [“####F”,“#C…”,“M…”], catJump = 1, mouseJump = 2</p>
<p>输出：true</p>
<p>解释：猫无法抓到老鼠，也没法比老鼠先到达食物。</p>
<p>2、</p>
<p><img src="/2022/05/10/Leetcode%E4%B9%8B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A2022-5-10/2.png" alt="image-20220510184711602"></p>
<p>输入：grid = [“M.C…F”], catJump = 1, mouseJump = 4</p>
<p>输出：true</p>
<p>3、</p>
<p>输入：grid = [“M.C…F”], catJump = 1, mouseJump = 3</p>
<p>输出：false</p>
<p>4、</p>
<p>输入：grid = [“C…#”,“…#F”,“…#”,“M…”], catJump = 2, mouseJump = 5</p>
<p>输出：false</p>
<p>5、</p>
<p>输入：grid = [“.M…”,“…#…”,“#…#.”,“C#.#.”,“…#F”], catJump = 3, mouseJump = 1</p>
<p>输出：true</p>
<h3 id="提示-34">提示</h3>
<ul>
<li>rows = grid.length</li>
<li>cols = grid[i].length</li>
<li>$1 \leq rows$, $cols \leq 8$</li>
<li>grid[i][j] 只包含字符 ‘C’ ，‘M’ ，‘F’ ，‘.’ 和 ‘#’ 。</li>
<li>grid 中只包含一个 ‘C’ ，‘M’ 和 ‘F’ 。</li>
<li>$1\leq catJump$, $mouseJump \leq 8$</li>
</ul>
<h3 id="来源-27">来源</h3>
<p>力扣（LeetCode）链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii">https://leetcode.cn/problems/cat-and-mouse-ii</a></p>
<h2 id="问题解答-45">问题解答</h2>
<p>该题未解答出来，下面是优质题解</p>
<h4 id="1、拓扑排序">1、拓扑排序</h4>
<h5 id="介绍">介绍</h5>
<p>此题解需要提前了解博弈问题中的必胜状态、必败状态与必和状态的概念，以及最优策略。</p>
<p>博弈问题通常可以使用动态规划求解。由于动态规划的时间复杂度和游戏轮数有关，因此动态规划的时间复杂度较高。博弈问题的另一种解法是拓扑排序。和动态规划相比，拓扑排序的时间复杂度和游戏轮数无关，因此拓扑排序的时间复杂度较低。下面是用拓扑排序解此题的思路</p>
<h5 id="概述">概述</h5>
<p>给定的网格包含 rows行和 cols列，网格中的单元格总数是 $total=rows×cols$。每个单元格对应一个编号，第 i 行第 j 列的单元格编号是$ i×cols+j$，其中$0≤i&lt;rows$，$0≤j&lt;cols$。</p>
<p>首先遍历网格，得到猫和老鼠初始时所在的单元格以及食物所在的单元格，然后计算获胜方。</p>
<h5 id="求解简化问题">求解简化问题</h5>
<p>这道题规定了移动次数上限为1000，如果在 1000次移动之内老鼠不能获胜，则猫获胜。可以首先考虑一个简化问题，在没有移动次数上限的情况下计算获胜方。该简化问题可以使用拓扑排序得到结果。</p>
<p>游戏中的状态由老鼠的位置、猫的位置和轮到移动的一方三个因素决定。初始时，只有边界情况的胜负结果已知，其余所有状态的结果都初始化为未知。边界情况为直接确定胜负的情况，包括三种情况：</p>
<ul>
<li>猫和老鼠在同一个单元格，无论在哪个单元格，都是猫获胜；</li>
<li>猫和食物在同一个单元格，无论老鼠在哪个单元格，都是猫获胜；</li>
<li>老鼠和食物在同一个单元格，只要猫和食物不在同一个单元格，无论猫在哪个单元格，都是老鼠获胜。</li>
</ul>
<p>从边界情况出发遍历其他情况。对于当前状态，可以得到老鼠所在的单元格、猫所在的单元格和轮到移动的一方，根据当前状态可知上一轮的所有可能状态，其中上一轮的移动方和当前的移动方相反，上一轮的移动方在上一轮状态和当前状态所在的单元格相同或不同（注意可以停留在原地）。假设当前状态是老鼠所在的单元格编号是 mouse，猫所在的单元格编号是 cat，则根据当前的移动方，可以得到上一轮的所有可能状态：</p>
<ul>
<li>如果当前的移动方是老鼠，则上一轮的移动方是猫，上一轮状态中老鼠所在的单元格编号是 mouse，猫所在的单元格编号可能是 cat 或者向四个方向之一跳跃到达的单元格编号，跳跃的距离不超过 catJump且不能跳过墙及不能跳出网格；</li>
<li>如果当前的移动方是猫，则上一轮的移动方是老鼠，上一轮状态中猫所在的单元格编号是 cat，老鼠所在的单元格编号可能是 mouse或者向四个方向之一跳跃到达的单元格编号，跳跃的距离不超过 mouseJump且不能跳过墙及不能跳出网格。</li>
</ul>
<p>对于上一轮的每一种可能的状态，如果该状态的结果已知，则不需要重复计算该状态的结果，只有对结果未知的状态，才需要计算该状态的结果。对于上一轮的移动方，只有当可以确定上一轮状态是必胜状态或者必败状态时，才更新上一轮状态的结果。</p>
<ul>
<li>如果上一轮的移动方和当前状态的获胜方相同，由于当前状态为上一轮的移动方的必胜状态，因此上一轮的移动方一定可以移动到当前状态而获胜，上一轮状态为上一轮的移动方的必胜状态。</li>
<li>如果上一轮的移动方和当前状态的获胜方不同，则上一轮的移动方需要尝试其他可能的移动，可能有以下三种情况：
<ul>
<li>如果存在一种移动可以到达上一轮的移动方的必胜状态，则上一轮状态为上一轮的移动方的必胜状态；</li>
<li>如果所有的移动都到达上一轮的移动方的必败状态，则上一轮状态为上一轮的移动方的必败状态；</li>
<li>如果所有的移动都不能到达上一轮的移动方的必胜状态，但是存在一种移动可以到达上一轮的移动方的未知状态，则上一轮状态为上一轮的移动方的未知状态。</li>
</ul>
</li>
</ul>
<p>其中，对于必败状态与未知状态的判断依据为上一轮的移动方可能的移动是都到达必败状态还是可以到达未知状态。为了实现必败状态与未知状态的判断，需要记录每个状态的度，初始时每个状态的度为当前玩家在当前单元格可以到达的单元格数，由于可以停留在原地，因此初始时每个状态的度为当前玩家在当前单元格可以跳跃到达的单元格数加 1。</p>
<p>遍历过程中，从当前状态出发遍历上一轮的所有可能状态，如果上一轮状态的结果未知且上一轮的移动方和当前状态的获胜方不同，则将上一轮状态的度减 1。如果上一轮状态的度减少到 0，则从上一轮状态出发到达的所有状态都是上一轮的移动方的必败状态，因此上一轮状态也是上一轮的移动方的必败状态。</p>
<p>在确定上一轮状态的结果（必胜或必败）之后，即可从上一轮状态出发，遍历其他的未知状态。当没有更多的状态可以确定胜负结果时，遍历结束，此时即可得到初始状态的结果。</p>
<h5 id="求解原始问题">求解原始问题</h5>
<p>上述解法为简化问题的解法，没有考虑移动次数的上限。由于移动次数的限制只会影响到平局以及老鼠获胜的条件，因此只需要对平局和老鼠获胜的情况考虑移动次数。</p>
<p>平局对应上述解法中的未知状态，表示当猫和老鼠都按照最优策略参与游戏时，双方都无法在有限的移动次数内到达食物所在的单元格，移动次数一定会超过老鼠获胜的上限，因此未知状态对应的结果都是猫获胜。</p>
<p>如果在简化问题中，从初始状态开始游戏的结果是老鼠获胜，即老鼠先到达食物，则在原始问题中，需要计算从初始状态至老鼠到达食物的移动次数，只有当移动次数不超过1000时，老鼠才能获胜，否则猫获胜。</p>
<p>为了计算从初始状态至老鼠到达食物的移动次数，在拓扑排序的过程中除了记录每个状态的结果以外，还需要记录从边界情况到达每个状态的移动次数，等价于从每个状态到边界情况的移动次数。每个状态对应的移动次数计算方法如下：</p>
<ul>
<li>边界情况可以直接确定胜负，因此移动次数为0；</li>
<li>如果状态 $s_1$和状态 $s_2$相邻（即状态 $s_2$是状态 $s_1$的上一轮的状态之一），且状态 $s_1$的结果和移动次数已知，记状态 $s_1$的移动次数为 x，如果可以确定状态 $s_2$的结果，则状态 $s_2$的移动次数为 x+1。</li>
</ul>
<h5 id="证明-2">证明</h5>
<p>对于上述解法的正确性证明，需要证明两点，一是未知状态的正确性，二是移动次数的正确性。</p>
<p>证明一：未知状态的正确性</p>
<p>遍历结束之后，如果一个状态的结果未知，则该状态满足以下两个条件：</p>
<ul>
<li>从该状态出发，任何移动都无法到达该状态的移动方的必胜状态；</li>
<li>从该状态出发，存在一种移动可以到达未知状态。</li>
</ul>
<p>对于结果未知的状态，如果其实际结果是该状态的移动方必胜，则一定存在一个下一轮状态，为当前状态的移动方的必胜状态，在根据下一轮状态的结果标记当前状态的结果时会将当前状态标记为当前状态的移动方的必胜状态，和结果未知矛盾。</p>
<p>对于结果未知的状态，如果其实际结果是该状态的移动方必败，则所有的下一轮状态都为当前状态的移动方的必败状态，在根据下一轮状态的结果标记当前状态的结果时会将当前状态标记为当前状态的移动方的必败状态，和结果未知矛盾。</p>
<p>因此，对于结果不是任何一方必胜的状态，实际结果一定是未知。根据游戏规则，未知状态表示在该状态下当猫和老鼠都按照最优策略参与游戏时，双方都无法在有限的移动次数内到达食物所在的单元格，移动次数一定会超过老鼠获胜的上限，因此未知状态对应的结果都是猫获胜。</p>
<h5 id="证明二：移动次数的正确性">证明二：移动次数的正确性</h5>
<p>在考虑移动次数的情况下，每个玩家的最优策略应满足以下三点：</p>
<ul>
<li>当自己可以到达必胜状态时，应将移动次数最小化；</li>
<li>当自己无法到达必胜状态时，如果可以避免自己到达必败状态，则应到达未知状态；</li>
<li>当无法避免自己到达必败状态时，应将移动次数最大化。</li>
</ul>
<p>由于拓扑排序的实现方式是广度优先搜索，因此拓扑排序的过程中遍历状态的顺序为移动次数递增的顺序。</p>
<p>边界情况的移动次数为 0。从已知状态出发计算未知状态的结果和移动次数，将已知状态记为$s_1$，未知状态记为 $s_2$，且状态 s_1 和状态 s_2相邻（即状态 s_2是状态 $s_1$的上一轮的状态之一），记状态 $s_1$的移动次数为 x，考虑以下两种情况。</p>
<ul>
<li>
<p>如果状态$s_2$ 的移动方和状态 $s_1$的获胜方相同，则状态 $s_2$的移动方会移动到状态 $s_1$从而确保胜利，因此状态 $s_2$的移动方必胜，移动次数为 x+1，且该移动次数为状态 $s_2$到边界情况的最少移动次数。</p>
<p><strong>假设存在另一个已知状态$s_3$的获胜方和状态$s_1$相同且状态$s_3$的移动次数小于 x，则状态$s_3$在状态$s_1$之前被遍历，在遍历到状态$s_3$时就会更新状态$s_2$的结果，和遍历到状态$s_1$时状态$s_2$的结果未知矛盾。因此状态$s_2$的最少移动次数为 x+1。</strong></p>
</li>
<li>
<p>如果状态 $s_2$的移动方和状态 $s_1$的获胜方不同，则只有当状态 $s_2$的所有相邻状态都已知是状态 $s_2$的移动方的必败状态时，才能确定状态 $s_2$ 的移动方必败。如果在遍历到状态 $s_1$ 时可以确定状态 $s_2$的结果为移动方必败，则在遍历到状态 $s_1$之前，状态 $s_2$ 的所有相邻状态都已经遍历过，即状态 $s_1$ 是最后一个遍历到的状态 $s_2$的相邻状态，因此在状态 $s_2$ 的所有相邻状态中，状态 $s_1$的移动次数最多，状态 $s_2$的移动次数是 x+1符合必败状态下将移动次数最大化。</p>
</li>
</ul>
<h5 id="代码-53">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MOUSE_TURN = <span class="number">0</span></span><br><span class="line">CAT_TURN = <span class="number">1</span></span><br><span class="line">UNKNOWN = <span class="number">0</span></span><br><span class="line">MOUSE_WIN = <span class="number">1</span></span><br><span class="line">CAT_WIN = <span class="number">2</span></span><br><span class="line">MAX_MOVES = <span class="number">1000</span></span><br><span class="line">DIRS = ((-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMouseWin</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], catJump: <span class="built_in">int</span>, mouseJump: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPos</span>(<span class="params">row: <span class="built_in">int</span>, col: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">return</span> row * cols + col</span><br><span class="line"></span><br><span class="line">        startMouse = startCat = food = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                    startMouse = getPos(i, j)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                    startCat = getPos(i, j)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">                    food = getPos(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算每个状态的度</span></span><br><span class="line">        total = rows * cols</span><br><span class="line">        degrees = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)]</span><br><span class="line">        <span class="keyword">for</span> mouse <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            mouseRow, mouseCol = <span class="built_in">divmod</span>(mouse, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[mouseRow][mouseCol] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> cat <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">                catRow, catCol = <span class="built_in">divmod</span>(cat, cols)</span><br><span class="line">                <span class="keyword">if</span> grid[catRow][catCol] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                degrees[mouse][cat][MOUSE_TURN] += <span class="number">1</span></span><br><span class="line">                degrees[mouse][cat][CAT_TURN] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                    row, col, jump = mouseRow + dx, mouseCol + dy, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="number">0</span> &lt;= row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols <span class="keyword">and</span> grid[row][col] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> jump &lt;= mouseJump:</span><br><span class="line">                        nextMouse = getPos(row, col)</span><br><span class="line">                        nextCat = getPos(catRow, catCol)</span><br><span class="line">                        degrees[nextMouse][nextCat][MOUSE_TURN] += <span class="number">1</span></span><br><span class="line">                        row += dx</span><br><span class="line">                        col += dy</span><br><span class="line">                        jump += <span class="number">1</span></span><br><span class="line">                    row, col, jump = catRow + dx, catCol + dy, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="number">0</span> &lt;= row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols <span class="keyword">and</span> grid[row][col] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> jump &lt;= catJump:</span><br><span class="line">                        nextMouse = getPos(mouseRow, mouseCol)</span><br><span class="line">                        nextCat = getPos(row, col)</span><br><span class="line">                        degrees[nextMouse][nextCat][CAT_TURN] += <span class="number">1</span></span><br><span class="line">                        row += dx</span><br><span class="line">                        col += dy</span><br><span class="line">                        jump += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        results = [[[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total)]</span><br><span class="line">        q = deque()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 猫和老鼠在同一个单元格，猫获胜</span></span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            row, col = <span class="built_in">divmod</span>(pos, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results[pos][pos][MOUSE_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[pos][pos][MOUSE_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            results[pos][pos][CAT_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[pos][pos][CAT_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            q.append((pos, pos, MOUSE_TURN))</span><br><span class="line">            q.append((pos, pos, CAT_TURN))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 猫和食物在同一个单元格，猫获胜</span></span><br><span class="line">        <span class="keyword">for</span> mouse <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            mouseRow, mouseCol = <span class="built_in">divmod</span>(mouse, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[mouseRow][mouseCol] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> mouse == food:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results[mouse][food][MOUSE_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[mouse][food][MOUSE_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            results[mouse][food][CAT_TURN][<span class="number">0</span>] = CAT_WIN</span><br><span class="line">            results[mouse][food][CAT_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            q.append((mouse, food, MOUSE_TURN))</span><br><span class="line">            q.append((mouse, food, CAT_TURN))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜</span></span><br><span class="line">        <span class="keyword">for</span> cat <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            catRow, catCol = <span class="built_in">divmod</span>(cat, cols)</span><br><span class="line">            <span class="keyword">if</span> grid[catRow][catCol] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> cat == food:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results[food][cat][MOUSE_TURN][<span class="number">0</span>] = MOUSE_WIN</span><br><span class="line">            results[food][cat][MOUSE_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            results[food][cat][CAT_TURN][<span class="number">0</span>] = MOUSE_WIN</span><br><span class="line">            results[food][cat][CAT_TURN][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            q.append((food, cat, MOUSE_TURN))</span><br><span class="line">            q.append((food, cat, CAT_TURN))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPrevStates</span>(<span class="params">mouse: <span class="built_in">int</span>, cat: <span class="built_in">int</span>, turn: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>]]:</span><br><span class="line">            mouseRow, mouseCol = <span class="built_in">divmod</span>(mouse, cols)</span><br><span class="line">            catRow, catCol = <span class="built_in">divmod</span>(cat, cols)</span><br><span class="line">            prevTurn = CAT_TURN <span class="keyword">if</span> turn == MOUSE_TURN <span class="keyword">else</span> MOUSE_TURN</span><br><span class="line">            maxJump = mouseJump <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> catJump</span><br><span class="line">            startRow = mouseRow <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> catRow</span><br><span class="line">            startCol = mouseCol <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> catCol</span><br><span class="line">            prevStates = [(mouse, cat, prevTurn)]</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                i, j, jump = startRow + dx, startCol + dy, <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="number">0</span> &lt;= i &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; cols <span class="keyword">and</span> grid[i][j] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> jump &lt;= maxJump:</span><br><span class="line">                    prevMouseRow = i <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> mouseRow</span><br><span class="line">                    prevMouseCol = j <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> mouseCol</span><br><span class="line">                    prevCatRow = catRow <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> i</span><br><span class="line">                    prevCatCol = catCol <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> j</span><br><span class="line">                    prevMouse = getPos(prevMouseRow, prevMouseCol)</span><br><span class="line">                    prevCat = getPos(prevCatRow, prevCatCol)</span><br><span class="line">                    prevStates.append((prevMouse, prevCat, prevTurn))</span><br><span class="line">                    i += dx</span><br><span class="line">                    j += dy</span><br><span class="line">                    jump += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> prevStates</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            mouse, cat, turn = q.popleft()</span><br><span class="line">            result = results[mouse][cat][turn][<span class="number">0</span>]</span><br><span class="line">            moves = results[mouse][cat][turn][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> prevMouse, prevCat, prevTurn <span class="keyword">in</span> getPrevStates(mouse, cat, turn):</span><br><span class="line">                <span class="keyword">if</span> results[prevMouse][prevCat][prevTurn][<span class="number">0</span>] == UNKNOWN:</span><br><span class="line">                    <span class="keyword">if</span> result == MOUSE_WIN <span class="keyword">and</span> prevTurn == MOUSE_TURN <span class="keyword">or</span> result == CAT_WIN <span class="keyword">and</span> prevTurn == CAT_TURN:</span><br><span class="line">                        results[prevMouse][prevCat][prevTurn][<span class="number">0</span>] = result</span><br><span class="line">                        results[prevMouse][prevCat][prevTurn][<span class="number">1</span>] = moves + <span class="number">1</span></span><br><span class="line">                        q.append((prevMouse, prevCat, prevTurn))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        degrees[prevMouse][prevCat][prevTurn] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> degrees[prevMouse][prevCat][prevTurn] == <span class="number">0</span>:</span><br><span class="line">                            loseResult = CAT_WIN <span class="keyword">if</span> prevTurn == MOUSE_TURN <span class="keyword">else</span> MOUSE_WIN</span><br><span class="line">                            results[prevMouse][prevCat][prevTurn][<span class="number">0</span>] = loseResult</span><br><span class="line">                            results[prevMouse][prevCat][prevTurn][<span class="number">1</span>] = moves + <span class="number">1</span></span><br><span class="line">                            q.append((prevMouse, prevCat, prevTurn))</span><br><span class="line">        <span class="keyword">return</span> results[startMouse][startCat][MOUSE_TURN][<span class="number">0</span>] == MOUSE_WIN <span class="keyword">and</span> results[startMouse][startCat][MOUSE_TURN][<span class="number">1</span>] &lt;= MAX_MOVES</span><br></pre></td></tr></table></figure>
<h5 id="作者-37">作者</h5>
<p>LeetCode-Solution，链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-leetcode-solution-e5io/">https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-leetcode-solution-e5io/</a></p>
<h4 id="2、博弈树搜索（暴力法）">2、博弈树搜索（暴力法）</h4>
<h5 id="介绍-2">介绍</h5>
<p>基本思路就是深度优先搜索整个博弈树，同时使用记忆化的方法（即记录搜索过的状态避免重复搜索），再加上剪枝策略：当前状态如果有胜利的走法，那么就无需继续向下搜索了。一个小优化是，搜索顺序对剪枝的效率有很大影响，所以这里设置了一个顺序，老鼠先搜索距离食物距离更近的点，猫先搜索距离老鼠和食物更近的点。</p>
<h5 id="代码-54">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    DIR = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMouseWin</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], catJump: <span class="built_in">int</span>, mouseJump: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            grid[i] = <span class="built_in">list</span>(grid[i])</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">                <span class="keyword">if</span> y == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                    cat = (i, j)</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> y == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                    mouse = (i, j)</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> y == <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">                    food = (i, j)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cat, mouse, t</span>):</span><br><span class="line">            <span class="comment"># 猫的位置、老鼠位置，回合数</span></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">128</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            win = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 老鼠的回合</span></span><br><span class="line">            <span class="keyword">if</span> t % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                x, y = mouse</span><br><span class="line">                nxt = <span class="built_in">list</span>()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.DIR:</span><br><span class="line">                    nx, ny = x, y</span><br><span class="line">                    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(mouseJump + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> (nx != cat[<span class="number">0</span>] <span class="keyword">or</span> ny != cat[<span class="number">1</span>]):</span><br><span class="line">                            <span class="keyword">if</span> grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">                            nxt.append((nx, ny))</span><br><span class="line">                        nx += dx</span><br><span class="line">                        ny += dy</span><br><span class="line">              	<span class="comment"># 按照（nx，ny）与食物位置的曼哈顿距离进行升序排列</span></span><br><span class="line">                nxt.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (i - j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, food)))))<span class="comment"># 使用lambda可以定义一个匿名函数。</span></span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> nxt:</span><br><span class="line">                    <span class="comment"># 老鼠获得食物，获胜</span></span><br><span class="line">                    win = grid[nx][ny] == <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> <span class="keyword">not</span> dfs(cat, (nx, ny), t + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> win: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 猫的回合</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x, y = cat</span><br><span class="line">                nxt = <span class="built_in">list</span>()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.DIR:</span><br><span class="line">                    nx, ny = x, y</span><br><span class="line">                    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(catJump + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m:</span><br><span class="line">                            <span class="keyword">if</span> grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">                            nxt.append((nx, ny))</span><br><span class="line">                        nx += dx</span><br><span class="line">                        ny += dy</span><br><span class="line">                <span class="comment"># 按照（nx，ny）与食物位置和老鼠位置的曼哈顿距离的最小值进行升序排列</span></span><br><span class="line">                nxt.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">min</span>(<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (i - j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, food)))), <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (i - j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, mouse))))))</span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> nxt:</span><br><span class="line">                    <span class="comment"># 猫获得食物或抓住老鼠，获胜</span></span><br><span class="line">                    win = (nx == mouse[<span class="number">0</span>] <span class="keyword">and</span> ny == mouse[<span class="number">1</span>]) <span class="keyword">or</span> grid[nx][ny] == <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> <span class="keyword">not</span> dfs((nx, ny), mouse, t + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> win: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> win</span><br><span class="line">        <span class="keyword">return</span> dfs(cat, mouse, <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(max(catJump,mouseJump)^{max_deep})$，这里最大搜索深度$max_deep$设置为 128，当然这是理论上界，实际上剪枝和记忆化后远远达不到这个上界</p>
<p>PS：注意这里不能按照题目给的 1000 回合进行搜索，这样必定会超时，不加优化策略的情况下可以设置为 128 （即地图大小 64 的两倍，不过目前还没有严谨的证明 “128 回合老鼠还没有获胜那就必定获胜”），更不严谨的，可以设置最大回合数为“猫与食物距离”的 16 倍（测试得到，无法保证正确性）。</p>
<p>空间复杂度: $O(n×m×max_deep)$，状态空间为地图大小和回合数的乘积</p>
<h5 id="作者-38">作者</h5>
<p>meteordream，链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-meteordream-be5y/">https://leetcode.cn/problems/cat-and-mouse-ii/solution/mao-he-lao-shu-ii-by-meteordream-be5y/</a></p>
<h4 id="3、极大极小博弈">3、极大极小博弈</h4>
<p>对于老鼠来说，最好的情况是自己赢，我们认定该情景是-1分；其次好的情况是平局，我们认定该情景是0分；最差的情况是猫赢，我们认定该情景是1分。也就是说对于老鼠来说，想要得分尽可能小，而对于猫来说，想要得分尽可能大，这就是经典的最大最小博弈了。</p>
<p>平局分析：认定走了足够到遍历所有该去的尝试赢的走法的点，仍然无法结束。实际状态最多有 $8 * 8 * 8 * 8 * 2$ 种，可以用题目描述的1000作为界，但是会超出时间限制。猜测128为回合阈值，如果TLE可以调小一点，大于64，不会证明, 不保证正确性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIRS = (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMouseWin</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], catJump: <span class="built_in">int</span>, mouseJump: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        mm, nn = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">                match grid[x][y]:</span><br><span class="line">                    case <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                        cat = x, y</span><br><span class="line">                    case <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">                        food = x, y</span><br><span class="line">                    case <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                        mouse = x, y</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">m, c, i</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            极大极小博弈，</span></span><br><span class="line"><span class="string">            老鼠尽量找自己获胜的，其次接受平局</span></span><br><span class="line"><span class="string">            猫尽量找自己获胜的，其次接受平局</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            :param m: 老鼠的位置</span></span><br><span class="line"><span class="string">            :param c: 猫的位置</span></span><br><span class="line"><span class="string">            :param i: 回合</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> m == c <span class="keyword">or</span> c == food <span class="keyword">or</span> i &gt; <span class="number">128</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> m == food:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            is_cat = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 猫回合</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                pos, jump = c, catJump</span><br><span class="line">                is_cat = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos, jump = m, mouseJump</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                <span class="keyword">for</span> jp <span class="keyword">in</span> <span class="built_in">range</span>(jump + <span class="number">1</span>):</span><br><span class="line">                    nx, ny = pos[<span class="number">0</span>] + dx * jp, pos[<span class="number">1</span>] + dy * jp</span><br><span class="line">                    <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= mm <span class="keyword">or</span> ny &gt;= nn <span class="keyword">or</span> grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> is_cat <span class="keyword">and</span> dfs((nx, ny), c, i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> is_cat <span class="keyword">and</span> <span class="keyword">not</span> dfs(m, (nx, ny), i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> is_cat</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(mouse, cat, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="作者-39">作者</h5>
<p>himymBen，链接：<a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/python-ji-xiao-ji-da-bo-yi-by-himymben-ukbk/">https://leetcode.cn/problems/cat-and-mouse-ii/solution/python-ji-xiao-ji-da-bo-yi-by-himymben-ukbk/</a></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL题目总结</title>
    <url>/2023/03/24/MySQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1、计算特殊奖金">1、计算特殊奖金</h2>
<p>表: <code>Employees</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名        | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| employee_id | int     |</span><br><span class="line">| name        | varchar |</span><br><span class="line">| salary      | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">employee_id 是这个表的主键。</span><br><span class="line">此表的每一行给出了雇员id ，名字和薪水。</span><br></pre></td></tr></table></figure>
<p>写出一个SQL 查询语句，计算每个雇员的奖金。如果一个雇员的id是奇数并且他的名字不是以’M’开头，那么他的奖金是他工资的100%，否则奖金为0。</p>
<p>Return the result table ordered by <code>employee_id</code>.</p>
<p>返回的结果集请按照<code>employee_id</code>排序。</p>
<p>查询结果格式如下面的例子所示。</p>
<h3 id="示例-47">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employees 表:</span><br><span class="line">+-------------+---------+--------+</span><br><span class="line">| employee_id | name    | salary |</span><br><span class="line">+-------------+---------+--------+</span><br><span class="line">| 2           | Meir    | 3000   |</span><br><span class="line">| 3           | Michael | 3800   |</span><br><span class="line">| 7           | Addilyn | 7400   |</span><br><span class="line">| 8           | Juan    | 6100   |</span><br><span class="line">| 9           | Kannon  | 7700   |</span><br><span class="line">+-------------+---------+--------+</span><br><span class="line">输出：</span><br><span class="line">+-------------+-------+</span><br><span class="line">| employee_id | bonus |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| 2           | 0     |</span><br><span class="line">| 3           | 0     |</span><br><span class="line">| 7           | 7400  |</span><br><span class="line">| 8           | 0     |</span><br><span class="line">| 9           | 7700  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">解释：</span><br><span class="line">因为雇员id是偶数，所以雇员id 是2和8的两个雇员得到的奖金是0。</span><br><span class="line">雇员id为3的因为他的名字以&#x27;M&#x27;开头，所以，奖金是0。</span><br><span class="line">其他的雇员得到了百分之百的奖金。</span><br></pre></td></tr></table></figure>
<h3 id="MySQL代码">MySQL代码</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id ,</span><br><span class="line"></span><br><span class="line">if(employee_id <span class="operator">%</span> <span class="number">2</span> <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="keyword">left</span>(name,<span class="number">1</span>)<span class="operator">!=</span>&quot;M&quot; ,salary,<span class="number">0</span>) <span class="keyword">as</span> bonus</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Employees </span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> employee_id</span><br></pre></td></tr></table></figure>
<p>可以在SELECT里面的列里面使用if语句来条件输出结果。同时，if还可以用于UPDATE里面的SET子句，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Salary <span class="keyword">SET</span> sex<span class="operator">=</span>if(sex<span class="operator">=</span><span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2、删除重复的电子邮箱">2、删除重复的电子邮箱</h2>
<p>表: <code>Person</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| id          | int     |</span><br><span class="line">| email       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">id是该表的主键列。</span><br><span class="line">该表的每一行包含一封电子邮件。电子邮件将不包含大写字母</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL <strong>删除语句</strong>来 <strong>删除</strong> 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。 （<strong>注意</strong>： 仅需要写删除语句，将自动对剩余结果进行查询）</p>
<p>查询结果格式如下所示。</p>
<h3 id="示例-48">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">Person 表:</span><br><span class="line">+----+------------------+</span><br><span class="line">| id | email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">输出: </span><br><span class="line">+----+------------------+</span><br><span class="line">| id | email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br><span class="line">解释: john@example.com重复两次。我们保留最小的Id = 1。</span><br></pre></td></tr></table></figure>
<h3 id="代码-55">代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM Person WHERE id in (SELECT p3.id FROM (SELECT p2.id FROM Person as p1 JOIN Person as p2 on p1.email = p2.email WHERE p2.id &gt; p1.id) as p3 );</span><br></pre></td></tr></table></figure>
<p>这里面不能直接写成下面这种：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> id <span class="keyword">in</span> (<span class="keyword">SELECT</span> p2.id <span class="keyword">FROM</span> Person <span class="keyword">as</span> p1 <span class="keyword">JOIN</span> Person <span class="keyword">as</span> p2 <span class="keyword">on</span> p1.email <span class="operator">=</span> p2.email <span class="keyword">WHERE</span> p2.id <span class="operator">&gt;</span> p1.id);</span><br></pre></td></tr></table></figure>
<p>虽然逻辑上是对的，但是MySQL不支持在同一条SQL语句中查询出一张表的某些值，再直接用这些值更新这张表。所以此时必须在用一条SELECT语句查询依次生成一张临时表。同时在MySQL中，派生表必须有别名，所以上面的p3不能删。</p>
<h2 id="3、修复表中的名字">3、修复表中的名字</h2>
<p>表： <code>Users</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| user_id        | int     |</span><br><span class="line">| name           | varchar |</span><br><span class="line">+----------------+---------+</span><br><span class="line">user_id 是该表的主键。</span><br><span class="line">该表包含用户的 ID 和名字。名字仅由小写和大写字符组成。</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询来修复名字，使得只有第一个字符是大写的，其余都是小写的。返回按 <code>user_id</code> 排序的结果表。查询结果格式示例如下。</p>
<h3 id="示例-49">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Users table:</span><br><span class="line">+---------+-------+</span><br><span class="line">| user_id | name  |</span><br><span class="line">+---------+-------+</span><br><span class="line">| 1       | aLice |</span><br><span class="line">| 2       | bOB   |</span><br><span class="line">+---------+-------+</span><br><span class="line">输出：</span><br><span class="line">+---------+-------+</span><br><span class="line">| user_id | name  |</span><br><span class="line">+---------+-------+</span><br><span class="line">| 1       | Alice |</span><br><span class="line">| 2       | Bob   |</span><br><span class="line">+---------+-------+</span><br></pre></td></tr></table></figure>
<h3 id="代码-56">代码</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	user_id, </span><br><span class="line">	CONCAT(<span class="built_in">UPPER</span>(<span class="keyword">LEFT</span>(name, <span class="number">1</span>)), <span class="built_in">LOWER</span>(<span class="keyword">RIGHT</span>(name, length(name) <span class="operator">-</span> <span class="number">1</span>))) <span class="keyword">as</span> name</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> Users</span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一、计算字段</span><br><span class="line"># 其实本题主要考察的就是计算字段的使用。</span><br><span class="line"></span><br><span class="line"># 二、知识点</span><br><span class="line"># 2.1 CONCAT() 函数</span><br><span class="line"># CONCAT 可以将多个字符串拼接在一起。</span><br><span class="line"></span><br><span class="line"># 2.2 LEFT(str, length) 函数</span><br><span class="line"># 从左开始截取字符串，length 是截取的长度。</span><br><span class="line"></span><br><span class="line"># 2.3 UPPER(str) 与 LOWER(str)</span><br><span class="line"># UPPER(str) 将字符串中所有字符转为大写</span><br><span class="line"># LOWER(str) 将字符串中所有字符转为小写</span><br><span class="line"></span><br><span class="line"># 2.4 SUBSTRING(str, begin, end)</span><br><span class="line"># 截取字符串，end 不写默认为空。</span><br><span class="line"># SUBSTRING(name, 2) 从第二个截取到末尾，注意并不是下标，就是第二个。</span><br><span class="line"># CONCAT 用来拼接字符串 ● LEFT 从左边截取字符 ● RIGHT 从右边截取字符 ● UPPER 变为大写 ● LOWER 变为小写 ● LENGTH 获取字符串长度</span><br></pre></td></tr></table></figure>
<h2 id="4、按日期分组销售产品">4、按日期分组销售产品</h2>
<p>表 <code>Activities</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| sell_date   | date    |</span><br><span class="line">| product     | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">此表没有主键，它可能包含重复项。</span><br><span class="line">此表的每一行都包含产品名称和在市场上销售的日期。</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称。每个日期的销售产品名称应按词典序排列。返回按 <code>sell_date</code> 排序的结果表。查询结果格式如下例所示。</p>
<h3 id="示例-50">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Activities 表：</span><br><span class="line">+------------+-------------+</span><br><span class="line">| sell_date  | product     |</span><br><span class="line">+------------+-------------+</span><br><span class="line">| 2020-05-30 | Headphone   |</span><br><span class="line">| 2020-06-01 | Pencil      |</span><br><span class="line">| 2020-06-02 | Mask        |</span><br><span class="line">| 2020-05-30 | Basketball  |</span><br><span class="line">| 2020-06-01 | Bible       |</span><br><span class="line">| 2020-06-02 | Mask        |</span><br><span class="line">| 2020-05-30 | T-Shirt     |</span><br><span class="line">+------------+-------------+</span><br><span class="line">输出：</span><br><span class="line">+------------+----------+------------------------------+</span><br><span class="line">| sell_date  | num_sold | products                     |</span><br><span class="line">+------------+----------+------------------------------+</span><br><span class="line">| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |</span><br><span class="line">| 2020-06-01 | 2        | Bible,Pencil                 |</span><br><span class="line">| 2020-06-02 | 1        | Mask                         |</span><br><span class="line">+------------+----------+------------------------------+</span><br><span class="line">解释：</span><br><span class="line">对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 &#x27;,&#x27; 分隔。</span><br><span class="line">对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。</span><br><span class="line">对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。</span><br></pre></td></tr></table></figure>
<h3 id="代码-57">代码</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">    sell_date,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>(<span class="keyword">distinct</span> product) num_sold,</span><br><span class="line"></span><br><span class="line">    group_concat(</span><br><span class="line"></span><br><span class="line">        <span class="keyword">distinct</span> product</span><br><span class="line"></span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> product</span><br><span class="line"></span><br><span class="line">        separator <span class="string">&#x27;,&#x27;</span></span><br><span class="line"></span><br><span class="line">    ) products</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"></span><br><span class="line">    Activities</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sell_date</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sell_date</span><br></pre></td></tr></table></figure>
<p>COUNT(DISTINCT col_name)：COUNT可以加DISTINCT，统计该字段不同值的次数，不计算NULL。</p>
<p>GROUP_CONCAT函数，将字段内的值连接起来，形成一个新的值。DISTINCT表示要不要去重，ORDER BY 排序，SEPARATOR ：分隔符的样式。</p>
<p>group_concat([distinct] 要连接的字段 [order by 排序字段] [separator ‘分隔符’])</p>
<p>REGEXP：正则表达式，用 ^ 匹配输入字符串的开始位置，|表示或者。例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Patients <span class="keyword">WHERE</span> conditions REGEXP <span class="string">&#x27;^DIAB1|\\sDIAB1&#x27;</span>;</span><br><span class="line">#等同于下面：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Patients <span class="keyword">WHERE</span> conditions <span class="keyword">like</span> <span class="string">&#x27;DIAB1%&#x27;</span> <span class="keyword">or</span> conditions <span class="keyword">like</span> <span class="string">&#x27;% DIAB1%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5、每个产品在不同商店的价格">5、每个产品在不同商店的价格</h2>
<p>表：<code>Products</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| product_id  | int     |</span><br><span class="line">| store1      | int     |</span><br><span class="line">| store2      | int     |</span><br><span class="line">| store3      | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">这张表的主键是product_id（产品Id）。</span><br><span class="line">每行存储了这一产品在不同商店store1, store2, store3的价格。</span><br><span class="line">如果这一产品在商店里没有出售，则值将为null。</span><br></pre></td></tr></table></figure>
<p>请你重构 <code>Products</code> 表，查询每个产品在不同商店的价格，使得输出的格式变为<code>(product_id, store, price)</code> 。如果这一产品在商店里没有出售，则不输出这一行。</p>
<p>输出结果表中的 <strong>顺序不作要求</strong> 。</p>
<p>查询输出格式请参考下面示例。</p>
<h3 id="示例-51">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Products table:</span><br><span class="line">+------------+--------+--------+--------+</span><br><span class="line">| product_id | store1 | store2 | store3 |</span><br><span class="line">+------------+--------+--------+--------+</span><br><span class="line">| 0          | 95     | 100    | 105    |</span><br><span class="line">| 1          | 70     | null   | 80     |</span><br><span class="line">+------------+--------+--------+--------+</span><br><span class="line">输出：</span><br><span class="line">+------------+--------+-------+</span><br><span class="line">| product_id | store  | price |</span><br><span class="line">+------------+--------+-------+</span><br><span class="line">| 0          | store1 | 95    |</span><br><span class="line">| 0          | store2 | 100   |</span><br><span class="line">| 0          | store3 | 105   |</span><br><span class="line">| 1          | store1 | 70    |</span><br><span class="line">| 1          | store3 | 80    |</span><br><span class="line">+------------+--------+-------+</span><br><span class="line">解释：</span><br><span class="line">产品0在store1，store2,store3的价格分别为95,100,105。</span><br><span class="line">产品1在store1，store3的价格分别为70,80。在store2无法买到。</span><br></pre></td></tr></table></figure>
<h3 id="代码-58">代码</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="string">&#x27;store1&#x27;</span> store, store1 <span class="keyword">AS</span> price <span class="keyword">FROM</span> Products <span class="keyword">WHERE</span> store1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="string">&#x27;store2&#x27;</span> store, store2 <span class="keyword">AS</span> price <span class="keyword">FROM</span> Products <span class="keyword">WHERE</span> store2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="string">&#x27;store3&#x27;</span> store, store3 <span class="keyword">AS</span> price <span class="keyword">FROM</span> Products <span class="keyword">WHERE</span> store3 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>该题主要在于如何自定义字段，同时赋予自定义值。在WHERE子句判断是否为NULL：is not null。同时，该题是属于列转行的题目，使用UNION将每一列转化为行并联合输出。</p>
<p>行转列的方法：</p>
<p><img src="/2023/03/24/MySQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/1.png" alt="image-20230326141100674"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"></span><br><span class="line">  product_id,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SUM</span>(IF(store <span class="operator">=</span> <span class="string">&#x27;store1&#x27;</span>, price, <span class="keyword">NULL</span>)) <span class="string">&#x27;store1&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SUM</span>(IF(store <span class="operator">=</span> <span class="string">&#x27;store2&#x27;</span>, price, <span class="keyword">NULL</span>)) <span class="string">&#x27;store2&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SUM</span>(IF(store <span class="operator">=</span> <span class="string">&#x27;store3&#x27;</span>, price, <span class="keyword">NULL</span>)) <span class="string">&#x27;store3&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"></span><br><span class="line">  Products1 </span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id ;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/24/MySQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/2.png" alt="image-20230326141205317"></p>
<p>这里SUM语句的作用是得到如<code>product_id=0 and store=store1</code>的所有价格的和，因为表中记录只有一条，结果就等于其值。为什么一定要使用聚合函数？是因为这是针对分组后的数据进行处理，必须使用聚合函数对组内数据进行聚合。如上述表：查询分组后的所有记录，结果如下，不使用聚合函数时，有数据会查不到。</p>
<p><a href><img src="/2023/03/24/MySQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/3.png" alt="image-20230326143433809"></a></p>
<h2 id="6、树节点">6、树节点</h2>
<p>给定一个表 <code>tree</code>，<strong>id</strong> 是树节点的编号， <strong>p_id</strong> 是它父节点的 <strong>id 。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+</span><br><span class="line">| id | p_id |</span><br><span class="line">+----+------+</span><br><span class="line">| 1  | null |</span><br><span class="line">| 2  | 1    |</span><br><span class="line">| 3  | 1    |</span><br><span class="line">| 4  | 2    |</span><br><span class="line">| 5  | 2    |</span><br><span class="line">+----+------+</span><br></pre></td></tr></table></figure>
<p>树中每个节点属于以下三种类型之一：</p>
<ul>
<li>叶子：如果这个节点没有任何孩子节点。</li>
<li>根：如果这个节点是整棵树的根，即没有父节点。</li>
<li>内部节点：如果这个节点既不是叶子节点也不是根节点。</li>
</ul>
<p>写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+</span><br><span class="line">| id | Type |</span><br><span class="line">+----+------+</span><br><span class="line">| 1  | Root |</span><br><span class="line">| 2  | Inner|</span><br><span class="line">| 3  | Leaf |</span><br><span class="line">| 4  | Leaf |</span><br><span class="line">| 5  | Leaf |</span><br><span class="line">+----+------+</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ul>
<li>
<p>节点 ‘1’ 是根节点，因为它的父节点是 NULL ，同时它有孩子节点 ‘2’ 和 ‘3’ 。</p>
</li>
<li>
<p>节点 ‘2’ 是内部节点，因为它有父节点 ‘1’ ，也有孩子节点 ‘4’ 和 ‘5’ 。</p>
</li>
<li>
<p>节点 ‘3’, ‘4’ 和 ‘5’ 都是叶子节点，因为它们都有父节点同时没有孩子节点。</p>
</li>
<li>
<p>样例中树的形态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line">/   \</span><br><span class="line">       2       3</span><br><span class="line">     /   \</span><br><span class="line">   4       5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong></p>
<p>如果树中只有一个节点，你只需要输出它的根属性。</p>
<h3 id="代码-59">代码</h3>
<p>1、使用UNION联合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, <span class="string">&#x27;Root&#x27;</span> <span class="keyword">AS</span> type <span class="keyword">FROM</span> tree <span class="keyword">WHERE</span> p_id <span class="keyword">is</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> t1.id, <span class="string">&#x27;Inner&#x27;</span> <span class="keyword">AS</span> type <span class="keyword">FROM</span> tree t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tree t2 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.p_id <span class="keyword">WHERE</span> t1.p_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span> <span class="keyword">and</span> t2.id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, <span class="string">&#x27;Leaf&#x27;</span> <span class="keyword">AS</span> type <span class="keyword">FROM</span> tree t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tree t2 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.p_id <span class="keyword">WHERE</span> t1.p_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span> <span class="keyword">and</span> t2.id <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>2、流控制语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">WHEN</span> ... <span class="keyword">THEN</span> .. </span><br><span class="line"># <span class="keyword">ELSE</span> ..</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id <span class="keyword">AS</span> `Id`,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> tree.id <span class="operator">=</span> (<span class="keyword">SELECT</span> atree.id <span class="keyword">FROM</span> tree atree <span class="keyword">WHERE</span> atree.p_id <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line">          <span class="keyword">THEN</span> <span class="string">&#x27;Root&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> tree.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> atree.p_id <span class="keyword">FROM</span> tree atree)</span><br><span class="line">          <span class="keyword">THEN</span> <span class="string">&#x27;Inner&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;Leaf&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> Type</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `Id`;</span><br></pre></td></tr></table></figure>
<p>3、IF函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 双重if语句</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    atree.id,</span><br><span class="line">    IF(ISNULL(atree.p_id),</span><br><span class="line">        <span class="string">&#x27;Root&#x27;</span>,</span><br><span class="line">        IF(atree.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> p_id <span class="keyword">FROM</span> tree), <span class="string">&#x27;Inner&#x27;</span>,<span class="string">&#x27;Leaf&#x27;</span>)) Type</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tree atree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> atree.id;</span><br></pre></td></tr></table></figure>
<h2 id="7、第二高的薪水">7、第二高的薪水</h2>
<p><code>Employee</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| id          | int  |</span><br><span class="line">| salary      | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">id 是这个表的主键。</span><br><span class="line">表的每一行包含员工的工资信息。 </span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询，获取并返回 <code>Employee</code> 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 <code>null</code> 。</p>
<p>查询结果如下例所示。</p>
<h3 id="示例-52">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employee 表：</span><br><span class="line">+----+--------+</span><br><span class="line">| id | salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br><span class="line">输出：</span><br><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employee 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">100</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> SecondHighestSalary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">null</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>
<h3 id="代码-60">代码</h3>
<p>使用子查询和 <code>LIMIT</code> 子句：将不同的薪资按降序排序，然后使用 <a href="https://leetcode.cn/link/?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fselect.html"><code>LIMIT</code></a> 子句获得第二高的薪资。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">    Salary <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span></span><br><span class="line"># 无法解决<span class="keyword">NULL</span>值问题</span><br><span class="line"># 下面使用IFNULL函数改进了</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    IFNULL(</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">       <span class="keyword">FROM</span> Employee</span><br><span class="line">       <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary</span><br></pre></td></tr></table></figure>
<p>学会使用LIMIT A OFFSET B：输出A条记录，偏移量为B，相当于从B+1开始输出A条记录。</p>
<h2 id="8、上升的温度">8、上升的温度</h2>
<p>表： <code>Weather</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| recordDate    | date    |</span><br><span class="line">| temperature   | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是这个表的主键</span><br><span class="line">该表包含特定日期的温度信息</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 <code>id</code> 。</p>
<p>返回结果 <strong>不要求顺序</strong> 。</p>
<p>查询结果格式如下例。</p>
<h3 id="示例-53">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Weather 表：</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">| id | recordDate | Temperature |</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">| 1  | 2015-01-01 | 10          |</span><br><span class="line">| 2  | 2015-01-02 | 25          |</span><br><span class="line">| 3  | 2015-01-03 | 20          |</span><br><span class="line">| 4  | 2015-01-04 | 30          |</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">输出：</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 2  |</span><br><span class="line">| 4  |</span><br><span class="line">+----+</span><br><span class="line">解释：</span><br><span class="line">2015-01-02 的温度比前一天高（10 -&gt; 25）</span><br><span class="line">2015-01-04 的温度比前一天高（20 -&gt; 30）</span><br></pre></td></tr></table></figure>
<h2 id="代码-61">代码</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> w1.id <span class="keyword">AS</span> Id <span class="keyword">FROM</span> weather w1, weather w2 <span class="keyword">WHERE</span> DATEDIFF(w1.recordDate, w2.recordDate)<span class="operator">=</span><span class="number">1</span>  <span class="keyword">AND</span> w1.temperature <span class="operator">&gt;</span> w2.temperature;</span><br></pre></td></tr></table></figure>
<p>这题主要考察日期函数，日期无法之间使用+、-，因为Mysql的日期类型直接加、减，会转换成数字类型加、减。如：‘2023-01-01’ -1 = ‘2023-01-00’ 这是一个不存在的日子。</p>
<p>因此，日期之间的计算需要用到日期函数：</p>
<p>**ADDDATE：**ADDDATE()函数用于将指定的时间间隔添加到日期值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="type">date</span>时间字段名  expr时间间隔 <span class="type">INTERVAL</span>关键字  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>unit单位 指的时间单位 天<span class="keyword">day</span> 小时<span class="keyword">hour</span>表示等</span><br><span class="line">ADDDATE(<span class="type">date</span>, <span class="type">INTERVAL</span> expr unit)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>其中，可选的时间单位非常多，从MICROSECOND, <span class="keyword">SECOND</span>, 到<span class="keyword">MONTH</span>, <span class="operator">/</span><span class="operator">/</span>QUARTER, <span class="keyword">YEAR</span>都可以接受。甚至复合的时间单位，如HOUR_MINUTE, <span class="operator">/</span><span class="operator">/</span>DAY_HOUR, YEAR_MONTH也可以，</span><br><span class="line">ADDDATE(<span class="type">date</span>, <span class="type">INTERVAL</span> <span class="string">&#x27;1-2&#x27;</span> YEAR_MONTH)</span><br><span class="line">ADDDATE(<span class="string">&#x27;2020-01-02 00:00:00&#x27;</span>, <span class="type">INTERVAL</span> <span class="string">&#x27;1 1:1:1&#x27;</span> DAY_SECOND)</span><br></pre></td></tr></table></figure>
<p>**DATA_ADD和DATA_SUB：**也是用于将指定的时间间隔添加到日期值，用法与写法与上面ADDDATE差不多。</p>
<p>与ADDDATE的差别主要在于：当只进行以日为单位的日期加减时，<code>ADDDATE</code>有一个简写的使用方法（省略关键字INTERVAL和单位），而<code>DATE_ADD</code>没有。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATE_SUB: DATE_SUB(<span class="string">&#x27;2023-12-29&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">2</span> <span class="keyword">DAY</span>) #<span class="number">2023</span><span class="number">-12</span><span class="number">-27</span></span><br><span class="line">DATE_ADD: 同上</span><br></pre></td></tr></table></figure>
<p>**DATEDIFF：**传入两个日期参数，比较DAY天数，第一个参数减去第二个参数的天数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2013-01-13&#x27;</span>,<span class="string">&#x27;2012-10-01&#x27;</span>); # <span class="number">104</span></span><br></pre></td></tr></table></figure>
<p><strong>TIMESTAMPDIFF：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：TIMESTAMPDIFF(interval_type, datetime1, datetime2)</span><br><span class="line">结果：返回（时间<span class="number">2</span><span class="operator">-</span>时间<span class="number">1</span>）的时间差，结果单位由interval_type参数给出。</span><br><span class="line"></span><br><span class="line">frac_second 毫秒（低版本不支持，用<span class="keyword">second</span>，再除于<span class="number">1000</span>）</span><br><span class="line"><span class="keyword">second</span> 秒</span><br><span class="line"><span class="keyword">minute</span> 分钟</span><br><span class="line"><span class="keyword">hour</span> 小时</span><br><span class="line"><span class="keyword">day</span> 天</span><br><span class="line">week 周</span><br><span class="line"><span class="keyword">month</span> 月</span><br><span class="line">quarter 季度</span><br><span class="line"><span class="keyword">year</span> 年</span><br></pre></td></tr></table></figure>
<p><strong>TIMEDIFF：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：timediff(time1,time2)</span><br><span class="line"></span><br><span class="line">结果：返回两个时间相减得到的差值，time1<span class="operator">-</span>time2</span><br><span class="line"></span><br><span class="line">如：<span class="keyword">SELECT</span> TIMEDIFF(<span class="string">&#x27;2018-05-21 14:51:43&#x27;</span>,<span class="string">&#x27;2018-05-19 12:54:43&#x27;</span>);# <span class="number">49</span>:<span class="number">57</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>**NOW()：**返回的是当前时间的年月日时分秒</p>
<p>**CURDATE()：**返回的是年月日信息</p>
<p>**CURTIME()：**返回的是当前时间的时分秒信息</p>
<h2 id="9、销售员">9、销售员</h2>
<p>表: <code>SalesPerson</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------+---------+</span><br><span class="line">| Column Name     | Type    |</span><br><span class="line">+-----------------+---------+</span><br><span class="line">| sales_id        | int     |</span><br><span class="line">| name            | varchar |</span><br><span class="line">| salary          | int     |</span><br><span class="line">| commission_rate | int     |</span><br><span class="line">| hire_date       | date    |</span><br><span class="line">+-----------------+---------+</span><br><span class="line">sales_id 是该表的主键列。</span><br><span class="line">该表的每一行都显示了销售人员的姓名和 ID ，以及他们的工资、佣金率和雇佣日期。</span><br></pre></td></tr></table></figure>
<p>表: <code>Company</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| com_id      | int     |</span><br><span class="line">| name        | varchar |</span><br><span class="line">| city        | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">com_id 是该表的主键列。</span><br><span class="line">该表的每一行都表示公司的名称和 ID ，以及公司所在的城市。 </span><br></pre></td></tr></table></figure>
<p>表: <code>Orders</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| order_id    | int  |</span><br><span class="line">| order_date  | date |</span><br><span class="line">| com_id      | int  |</span><br><span class="line">| sales_id    | int  |</span><br><span class="line">| amount      | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">order_id 是该表的主键列。</span><br><span class="line">com_id 是 Company 表中 com_id 的外键。</span><br><span class="line">sales_id 是来自销售员表 sales_id 的外键。</span><br><span class="line">该表的每一行包含一个订单的信息。这包括公司的 ID 、销售人员的 ID 、订单日期和支付的金额。 </span><br></pre></td></tr></table></figure>
<p>编写一个SQL查询，报告没有任何与名为 <strong>“RED”</strong> 的公司相关的订单的所有销售人员的姓名。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<h3 id="示例-54">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">SalesPerson 表:</span><br><span class="line">+----------+------+--------+-----------------+------------+</span><br><span class="line">| sales_id | name | salary | commission_rate | hire_date  |</span><br><span class="line">+----------+------+--------+-----------------+------------+</span><br><span class="line">| 1        | John | 100000 | 6               | 4/1/2006   |</span><br><span class="line">| 2        | Amy  | 12000  | 5               | 5/1/2010   |</span><br><span class="line">| 3        | Mark | 65000  | 12              | 12/25/2008 |</span><br><span class="line">| 4        | Pam  | 25000  | 25              | 1/1/2005   |</span><br><span class="line">| 5        | Alex | 5000   | 10              | 2/3/2007   |</span><br><span class="line">+----------+------+--------+-----------------+------------+</span><br><span class="line">Company 表:</span><br><span class="line">+--------+--------+----------+</span><br><span class="line">| com_id | name   | city     |</span><br><span class="line">+--------+--------+----------+</span><br><span class="line">| 1      | RED    | Boston   |</span><br><span class="line">| 2      | ORANGE | New York |</span><br><span class="line">| 3      | YELLOW | Boston   |</span><br><span class="line">| 4      | GREEN  | Austin   |</span><br><span class="line">+--------+--------+----------+</span><br><span class="line">Orders 表:</span><br><span class="line">+----------+------------+--------+----------+--------+</span><br><span class="line">| order_id | order_date | com_id | sales_id | amount |</span><br><span class="line">+----------+------------+--------+----------+--------+</span><br><span class="line">| 1        | 1/1/2014   | 3      | 4        | 10000  |</span><br><span class="line">| 2        | 2/1/2014   | 4      | 5        | 5000   |</span><br><span class="line">| 3        | 3/1/2014   | 1      | 1        | 50000  |</span><br><span class="line">| 4        | 4/1/2014   | 1      | 4        | 25000  |</span><br><span class="line">+----------+------------+--------+----------+--------+</span><br><span class="line">输出：</span><br><span class="line">+------+</span><br><span class="line">| name |</span><br><span class="line">+------+</span><br><span class="line">| Amy  |</span><br><span class="line">| Mark |</span><br><span class="line">| Alex |</span><br><span class="line">+------+</span><br><span class="line">解释：</span><br><span class="line">根据表 orders 中的订单 &#x27;3&#x27; 和 &#x27;4&#x27; ，容易看出只有 &#x27;John&#x27; 和 &#x27;Pam&#x27; 两个销售员曾经向公司 &#x27;RED&#x27; 销售过。</span><br><span class="line">所以我们需要输出表 salesperson 中所有其他人的名字。</span><br></pre></td></tr></table></figure>
<h3 id="代码-62">代码</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> salesperson <span class="keyword">WHERE</span> sales_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> o.sales_id <span class="keyword">FROM</span> (orders o <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> company c <span class="keyword">ON</span> o.com_id <span class="operator">=</span> c.com_id) <span class="keyword">WHERE</span> c.name <span class="operator">=</span> <span class="string">&#x27;RED&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="知识点">知识点</h4>
<p><strong>1、多表连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> s.name <span class="keyword">from</span> SalesPerson s</span><br><span class="line"><span class="keyword">join</span> Orders o <span class="keyword">on</span> o.sales_id<span class="operator">=</span>s.sales_id</span><br><span class="line"><span class="keyword">join</span> Company c <span class="keyword">on</span> o.com_id<span class="operator">=</span>c.com_id</span><br><span class="line"><span class="keyword">where</span> c.name <span class="operator">!=</span><span class="string">&#x27;RED&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>写法如上，但上述方法无法解决上述问题，因为它实现了筛选出所有与RED之外公司有交易的销售，一个销售可能即有RED也有其他公司的销售单，会被上面的列出来而不满足题意。</p>
<p><strong>2、in和exist</strong></p>
<p>in查询相当于多个or条件的叠加。in查询就是先将子查询条件的记录全都查出来，假设结果集为B，共有m条记录，然后在将子查询条件的结果集分解成m个，再进行m次查询。</p>
<p>exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false。</p>
<p>exist基本用法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> AM_USER <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> AM_ROLE <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"># <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> AM_ROLE 返回的数字没有意义，<span class="keyword">exists</span>子句不在乎返回什么，而是在乎有没有结果返回。</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/24/MySQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/4.png" alt="image-20230328111459956"></p>
<p><strong>区别</strong>：</p>
<ol>
<li>当B表比A表数据大时适合使用exists()，因为它没有那么遍历操作,只需要再执行一次查询就行。当B表数据较大时不适合使用in()，因为它会把B表数据全部遍历一次，因而in()适合B表比A表数据小的情况。</li>
<li>in引导的子句只能返回一个字段，exists子句是允许多字段返回的。</li>
</ol>
<h2 id="10、2020年最后一次登录">10、2020年最后一次登录</h2>
<p>表: <code>Logins</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+----------+</span><br><span class="line">| 列名           | 类型      |</span><br><span class="line">+----------------+----------+</span><br><span class="line">| user_id        | int      |</span><br><span class="line">| time_stamp     | datetime |</span><br><span class="line">+----------------+----------+</span><br><span class="line">(user_id, time_stamp) 是这个表的主键。</span><br><span class="line">每一行包含的信息是user_id 这个用户的登录时间。</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询，该查询可以获取在 <code>2020</code> 年登录过的所有用户的本年度 <strong>最后一次</strong> 登录时间。结果集 <strong>不</strong> 包含 <code>2020</code> 年没有登录过的用户。</p>
<p>返回的结果集可以按 <strong>任意顺序</strong> 排列。</p>
<p>查询结果格式如下例。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Logins 表:</span><br><span class="line">+---------+---------------------+</span><br><span class="line">| user_id | time_stamp          |</span><br><span class="line">+---------+---------------------+</span><br><span class="line">| 6       | 2020-06-30 15:06:07 |</span><br><span class="line">| 6       | 2021-04-21 14:06:06 |</span><br><span class="line">| 6       | 2019-03-07 00:18:15 |</span><br><span class="line">| 8       | 2020-02-01 05:10:53 |</span><br><span class="line">| 8       | 2020-12-30 00:46:50 |</span><br><span class="line">| 2       | 2020-01-16 02:49:50 |</span><br><span class="line">| 2       | 2019-08-25 07:59:08 |</span><br><span class="line">| 14      | 2019-07-14 09:00:00 |</span><br><span class="line">| 14      | 2021-01-06 11:59:59 |</span><br><span class="line">+---------+---------------------+</span><br><span class="line">输出：</span><br><span class="line">+---------+---------------------+</span><br><span class="line">| user_id | last_stamp          |</span><br><span class="line">+---------+---------------------+</span><br><span class="line">| 6       | 2020-06-30 15:06:07 |</span><br><span class="line">| 8       | 2020-12-30 00:46:50 |</span><br><span class="line">| 2       | 2020-01-16 02:49:50 |</span><br><span class="line">+---------+---------------------+</span><br><span class="line">解释：</span><br><span class="line">6号用户登录了3次，但是在2020年仅有一次，所以结果集应包含此次登录。</span><br><span class="line">8号用户在2020年登录了2次，一次在2月，一次在12月，所以，结果集应该包含12月的这次登录。</span><br><span class="line">2号用户登录了2次，但是在2020年仅有一次，所以结果集应包含此次登录。</span><br><span class="line">14号用户在2020年没有登录，所以结果集不应包含。</span><br></pre></td></tr></table></figure>
<h3 id="代码-63">代码</h3>
<h4 id="1、普通写法">1、普通写法</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	user_id, </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">MAX</span>(time_stamp) last_stamp </span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> logins </span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> DIFFDATE(time_stamp,<span class="string">&#x27;2019-12-31 23:59:59&#x27;</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> DIFFDATE(time_stamp,<span class="string">&#x27;2021-01-01 00:00:00&#x27;</span> ) <span class="operator">&lt;</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure>
<p>这是自己的写法，使用&lt;和&gt;来判断时间是否为2020年，这时候使用时间函数更好。如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TIMEDIFF(time_stamp,<span class="string">&#x27;2020-01-01 00:00:00&#x27;</span>) # 返回值以xx:xx:xx为单位</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line">DATEDIFF(time_stamp,<span class="string">&#x27;2020-01-01 00:00:00&#x27;</span>) # 返回值以天为单位</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">YEAR</span>(time_stamp) # 直接返回当前时间的年份</span><br></pre></td></tr></table></figure>
<h4 id="2、窗口函数">2、窗口函数</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 开窗函数降序排名，最后只保留排名为<span class="number">1</span>的字段。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"></span><br><span class="line">    user_id,</span><br><span class="line"></span><br><span class="line">    time_stamp <span class="keyword">AS</span> last_stamp</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line"></span><br><span class="line">        user_id,</span><br><span class="line"></span><br><span class="line">        time_stamp,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> time_stamp <span class="keyword">DESC</span>) <span class="keyword">AS</span> `rank`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">FROM</span> Logins</span><br><span class="line"></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">Year</span>(time_stamp) <span class="operator">=</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">)<span class="keyword">AS</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> tmp.rank <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 作者：dasen</span><br><span class="line"># 链接：https:<span class="operator">/</span><span class="operator">/</span>leetcode.cn<span class="operator">/</span>problems<span class="operator">/</span>the<span class="operator">-</span>latest<span class="operator">-</span>login<span class="operator">-</span><span class="keyword">in</span><span class="number">-2020</span><span class="operator">/</span>solutions<span class="operator">/</span><span class="number">2171916</span><span class="operator">/</span>kai<span class="operator">-</span>chuang<span class="operator">-</span>han<span class="operator">-</span>shu<span class="operator">-</span>pai<span class="operator">-</span>ming<span class="operator">-</span><span class="keyword">where</span><span class="operator">-</span>fen<span class="operator">-</span>zu<span class="operator">-</span>ahyt<span class="operator">/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>时序预测方法总结</title>
    <url>/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="自回归移动平均模型（ARMA）">自回归移动平均模型（ARMA）</h3>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="image-20220315184103757"></p>
<p>ARMA属于时间序列参数模型。假设$x_t$表示t时刻的时间序列的值，p和q表示时间窗的大小，$\varepsilon_t$表示t时刻的白噪声，$\alpha_1,\dots,\alpha_p$和$\beta_1,\dots,\beta_q$表示权重系数，则：</p>
<p>MA(q)可以表示为：$X_t=\sum_{i=1}^{q}\beta_i\varepsilon_{t-i}+\varepsilon_{t}$，MA模型研究时间序列在t时刻的值与$t-1, t-2, …$ 时刻随机干扰值的相关关系；MA模型主要考察外部影响对变量的影响情况和相应的记忆期限。</p>
<p>AR§可以表示为：$X_t=\sum_{i=1}^{p}\alpha_iX_{t-i}+\varepsilon_t$，AR模型研究第t时刻的序列值受$t-1, t-2, …$时刻的序列值以及当前随机干扰值的影响；AR模型主要考察变量的记忆特征和记忆衰减情况；</p>
<p>ARMA(p,q)可以表示为：$X_t=\sum_{i=1}^{p}\alpha_iX_{t-i}+\sum_{i=1}^{q}\beta_i\varepsilon_{t-i}+\varepsilon_t$，由自回归模型（AR）和移动平均模型（MA模型）为基础“混合”构成。</p>
<h4 id="特点">特点</h4>
<ul>
<li>
<p>ARMA方法作为基于统计的传统时间序列预测方法，其优点是复杂度低、计算速度快。但是针对现实世界复杂的时间序列，传统的单一统计学模型的准确率相对来说会比机器学习差。</p>
</li>
<li>
<p>传统的时间序列预测方法非常依赖参数模型的选择，能 否正确选择参数模型在很大程度上决定了预测结果的准确率。</p>
</li>
<li>
<p>只能适用于单变量时序预测</p>
</li>
</ul>
<h4 id="意义">意义</h4>
<p>传统时间序列预测模型也有其重要的意义：</p>
<ul>
<li>可以作为预测的基准模型，为项目提供一个准确率的基准线，来帮助评估其他模型。</li>
<li>前置清洗作用，时序模型由于其较好的可解释性，可以帮助剔除一些异常值。</li>
<li>作为集成模型中的一块，参与时序集成模型的训练。</li>
</ul>
<h4 id="改进1：ARIMA模型">改进1：ARIMA模型</h4>
<p>ARIMA模型是ARMA模型的推广。当时间序列${X_t}$不满足平稳性时, 我们通常使用<strong>差分</strong>的技巧使序列变得平稳, 然后再应用ARMA模型。使得ARMA模型可以应用于非平稳序列中。但ARIMA模型在长时间序列预测工作表现较差。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt="img"></p>
<h4 id="改进2：VARMA模型">改进2：VARMA模型</h4>
<p>解决ARMA只能适用于单变量时序的局限性。</p>
<p>m维ARMA(p,q)序列，即$VARMA(p,q)$：$X_t=\sum_{j=1}^p A_jX_j+\varepsilon_t-\sum_{j=1}^q B_j\varepsilon_{t-j}$</p>
<p>平稳可逆的VARMA模型具有平稳解，但需要估计出VARMA(p,q)模型的参数$A_1,\dots,A_p,B_1,\dots,B_q$，这是很麻烦的事情。</p>
<p>若q=0，模型退化为m维AR§模型，记为VAR§；</p>
<p>若p=0，模型退化为m维MA(q)模型，记为VMA(q)；</p>
<h4 id="参考-3">参考</h4>
<p><a href="https://www.jianshu.com/p/6250e60fa28a">多维时间序列——ARMA模型简介、VAR模型</a>、<a href="https://cloud.tencent.com/developer/article/1666552">【时序预测】一文梳理时间序列预测——ARMA模型</a>、<a href="https://www.jianshu.com/p/e52a4b82654e">时间序列模型简介</a></p>
<h3 id="支持向量机（SVM）">支持向量机（SVM）</h3>
<p>支持向量机在回归上的应用之一便是时序预测。为了使用SVR进行非线性回归，使用核函数将输入空间$x(i)$映射到高维特征空间$w(x(i))$。<strong>核函数的使用</strong>是SVR应用的关键。它提供了将非线性数据映射到本质上是线性的“特征”空间的能力。为了使SVR能在时序预测上取得好的效果，也出现了很多改进，如LSSVM、ASVM、$\varepsilon$-DSVM等。</p>
<p>在广泛使用SVR技术的时间序列预测应用中，将SVR视为时间序列预测方法的根本原因是预测问题的非线性方面。传统的基于模型的技术在预测非线性系统生成的时间序列方面通常不如SVR。而当时基于传统人工神经网络（ANN）的多层感知器等模型的性能不一定比SVR好。这可能是由于其固有的局限性，即无法保证网络优化的全局最小值。通过设计，SVR保证了这种全局最小解，并且通常在泛化能力方面具有优越性。随着深度学习的发展，SVR在非线性回归上的优势逐渐减低。</p>
<h4 id="参考-4">参考</h4>
<p>N. I. Sapankevych and R. Sankar, “Time series prediction using support vector machines: A survey,” IEEE Comput. Intell. Mag., vol. 4, no. 2,pp. 24–38, May 2009.</p>
<h3 id="径向基-RBF-函数神经网络">径向基(RBF)函数神经网络</h3>
<p>基函数神经网络是一类特殊的前馈神经网络模型。这类网络的前提是，要逼近的函数可以写成一些基函数的线性展开，并且只用在网络中产生一个隐藏层。基函数神经网络的一个主要优点是：可以使用线性自适应算法（如最小均方（LMS）和递归最小二乘（RLS）算法）来执行学习过程。基函数神经网络的例子包括径向、多项式和小波。这些基函数对输出单元执行非线性数据转换，以产生任意输出函数。</p>
<p>RBF神经网络的基本思想是：用RBF作为隐单元的“基”来构成隐空间，从而将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和。**所以，隐含层的作用是把向量从低维度映射到高维度，这样低维度线性不可分的情况到高维度就可以线性可分了，类似核函数的思想。**这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p>
<p>基函数神经网络用于时序预测，一方面因为它们具有良好的非线性拟合能力，另一方面通过非线性的基函数来实现非线性到线性的映射，从而增加神经网络的性能。</p>
<h4 id="参考-5">参考</h4>
<p><a href="https://www.cnblogs.com/pinking/p/9349695.html">RBF（径向基）神经网络</a></p>
<h3 id="CNN">CNN</h3>
<p>CNN用于时序数据的主要目的是提取时序数据上的特征，在一般情况下，CNN更常用于时序分类问题。</p>
<p>将CNN应用于时间序列预测的想法是学习能代表序列中某些重复模式的过滤器，并使用这些过滤器预测未来值。由于CNN的分层结构，它们可以很好地处理含噪序列，在随后的每一层中丢弃噪声，只提取有意义的模式。</p>
<p>针对时序数据的非线性，提高CNN学习非线性依赖关系能力的一种方法是使用大量的层和过滤器，但往往会遇到学习非线性的能力和过拟合之间的权衡问题。</p>
<h4 id="改进1：TCN（时间卷积网络）">改进1：TCN（时间卷积网络）</h4>
<p>TCN的体系结构与深度前馈神经网络相同，只是每一层的激活值是通过使用前一层的值来计算的。扩张卷积用于选择前一层神经元的哪些值将影响下一层神经元的值。因此，这种扩大的卷积运算捕获了局部和时间信息。</p>
<p>膨胀卷积：膨胀卷积允许卷积时的输入存在间隔采样，采样率受参数d控制。  最下面一层的d=1，表示输入时每个点都采样，中间层d=2，表示输入时每2个点采样一个作为输入。一般来讲，越高的层级使用的d的大小越大。所以，膨胀卷积使得有效窗口的大小随着层数呈指数型增长。这样卷积网络用比较少的层，就可以获得很大的感受野。</p>
<h5 id="优点：">优点：</h5>
<ol>
<li>并行性。可以并行处理数据。</li>
<li>灵活的感受野。TCN的感受野的大小受层数、卷积核大小、扩张系数等决定。可以根据不同的任务不同的特性灵活定制。</li>
<li>稳定的梯度。TCN不太存在梯度消失和爆炸问题。</li>
<li>内存更低。RNN需要将每步的信息都保存下来，从而占据大量的内存，TCN在一层里面卷积核是共享的，内存使用更低。</li>
</ol>
<h5 id="缺点">缺点</h5>
<p>TCN是卷积神经网络的变种，虽然使用扩展卷积可以扩大感受野，但相比于Transformer可以提取任意长度的相关信息的特性还是差了点。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt="image-20220317163822436"></p>
<h4 id="参考-6">参考</h4>
<p><a href="https://arxiv.org/abs/1703.04691">A. Borovykh, S. Bohte, and C. W. Oosterlee, “Conditional time series forecasting with convolutional neural networks,” 2017, arXiv:1703. 04691.</a>、<a href="https://blog.csdn.net/qq_27586341/article/details/90751794/">TCN-时间卷积网络</a></p>
<h3 id="RNN">RNN</h3>
<p>模型的输入是时间序列，其呈现出一个共同的特征，即数据之间存在时间依赖性。传统的神经网络不能考虑到这种依赖关系，RNN正是为了解决这个问题而出现的。</p>
<img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/4.png" alt="image-20220318105605529" width="50%" height="50%">
<h4 id="改进1：LSTM">改进1：LSTM</h4>
<p>标准的基本RNN存在消失梯度问题，即梯度随着层数的增加而减小。实际上，对于具有大量层的深层RNN，梯度实际上变为零，从而阻止了网络的学习。因此，这些网络只具有短期记忆，在处理需要记忆完整序列中包含的所有信息的长序列时，不会获得良好的结果。长短时记忆（LSTM）递归网络的出现是为了解决梯度消失问题。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/5.png" alt="preview"></p>
<h4 id="改进2：GRU">改进2：GRU</h4>
<p>GRU也是长期记忆网络，由于LSTM网络的高计算成本，GRU在作为LSTM的简化版本出现。GRU是在实际应用中对于许多不同的问题都是健壮和有用的。GRU在RNN的基础上使用门控机制使得捕获远程依赖成为可能，同时相对于LSTM有三个门，但GRU通过减少门的数量，使得模型更简单，计算速度更快。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/6.png" alt="image-20220317162500255"></p>
<h4 id="改进3：双向机制（BRNN、BiLSTM）">改进3：双向机制（BRNN、BiLSTM）</h4>
<p>RNN和LSTM都只能依据之前时刻的时序信息来预测下一时刻的输出，但在有些问题中，<strong>当前时刻的输出不仅和之前的状态有关，还可能和未来的状态有关系</strong>。为了获取时间序列在某一时刻前后序列的信息，出现了BRNN等带双向的递归神经网络。主要缺点是在预测之前需要整个数据序列的信息，计算量大。</p>
<h4 id="改进4：DRNN">改进4：DRNN</h4>
<p><strong>DRNN可以增强模型的表达能力，主要是将每个时刻上的循环体重复多次</strong>，每一层循环体中参数是共享的，但不同层之间的参数可以不同。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/7.png" alt="image-20220318110734017"></p>
<h4 id="参考：">参考：</h4>
<p><a href="https://zhuanlan.zhihu.com/p/123211148">史上最详细循环神经网络讲解（RNN/LSTM/GRU）</a>、Torres J F, Hadjout D, Sebaa A, et al. Deep learning for time series forecasting: a survey[J]. Big Data, 2021, 9(1): 3-21.</p>
<h3 id="自编码器">自编码器</h3>
<img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/8.png" alt="image-20220319094312851" width="50%" height="50%">
<p>自编码器(autoencoder) 是神经网络的一种，该网络可以看作由两部分组成：一个编码器函数$h = f(x) $和一个生成重构的解码器$r = g(h)$。自编码器是一种无监督的神经网络模型，它可以学习到输入数据的隐含特征，这称为编码，同时用学习到的新特征可以重构出原始输入数据，称之为解码。从直观上来看，自编码器可以用于特征降维，其相比PCA性能更强。除了进行特征降维，自编码器学习到的新特征可以送入有监督学习模型中，所以自编码器可以起到特征提取器的作用。</p>
<h4 id="改进1：SAE-堆栈自编码器">改进1：SAE(堆栈自编码器)</h4>
<p>即通过堆叠多层的自编码来学习更多的特征，将它用于时序主要还是像CNN那样方便提取特征。</p>
<h4 id="参考-7">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/31742653">简单易懂的自动编码器</a></p>
<h3 id="隐马尔可夫模型（HMM）">隐马尔可夫模型（HMM）</h3>
<p>隐马尔可夫模型是关于时序（顺序）的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列，称为状态序列；每个状态生成一个观测，而由此产生的观测的随机序列，称为观测序列。序列的每一个位置又可以看作是一个时刻。基本原理：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；</p>
<p>隐马尔可夫模型的基本假设：</p>
<p>1.齐次马尔科夫性假设：即假设隐藏的马尔科夫链在任意时刻t的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关；</p>
<p>2.观测独立性假设：即假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测即状态无关。</p>
<h4 id="参考-8">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/29938926">隐马尔可夫模型HMM</a></p>
<h3 id="深度置信网络（DBN）">深度置信网络（DBN）</h3>
<p>假设有一个二部图，每一层的节点之间没有链接，一层是可视层，即输入数据层(v)，一层是隐藏层(h)，如果假设所有的节点都是随机二值变量节点（只能取0或者1值），同时假设全概率分布p(v,h)满足Boltzmann 分布，则称这个模型是受限玻尔茨曼机 (RBM)。</p>
<p>深度置信网络：当输入v的时候，通过p(h|v)可以得到隐藏层h，而得到隐藏层h之后，通过p(v|h)又能得到可视层，通过调整参数，使得从隐藏层得到的可视层v1与原来的可视层v如果一样，那么得到的隐藏层就是可视层另外一种表达，因此隐藏层可以作为可视层输入数据的特征。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/9.png" alt="img"></p>
<p>如果把隐藏层的层数增加，同时在靠近可视层的部分使用贝叶斯信念网络（即有向图模型），而在最远离可视层的部分使用RBM，便可以得到DBN。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/10.png" alt="image-20220321105813797"></p>
<h4 id="特点-2">特点</h4>
<p>RBM能够将输入分类到一个特征空间，因此多个RBM层可以在DBN中提取高层特征。学习方式：<strong>逐层贪婪训练</strong>。</p>
<h4 id="参考-9">参考</h4>
<p><a href="https://blog.csdn.net/kellyroslyn/article/details/82668733">DBN(深度置信网络）</a></p>
<h3 id="GAN">GAN</h3>
<p>生成性对抗网络可分为判别网络和生成网络。经过训练的判别网络能够通过学习给定输入输出的条件概率分布来预测给定输入输出。而经过训练的生成网络通过学习输入和输出的联合分布，能够生成与训练样本具有相似分布的样本。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/11.png" alt="image-20220321145501389"></p>
<p>GAN用于时序预测主要因为生成对抗的思想，通过预测网络（如LSTM）与判别网络（如CNN）之间的相互对抗来提升预测网络的预测精度，从而获得较好的预测精度。</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/12.png" alt="image-20220321150651996"></p>
<h4 id="参考-10">参考</h4>
<p>Zhou X, Pan Z, Hu G, et al. Stock market prediction on high-frequency  data using generative adversarial nets[J]. Mathematical Problems in  Engineering, 2018.</p>
<h3 id="Transformers">Transformers</h3>
<p>Transformers对序列数据中的长期依赖关系和交互具有强大的建模能力，因此可以适合于时间序列建模。 利用在输入嵌入中加入的位置编码，对序列信息进行建模。</p>
<p>从网络结构和应用领域的角度看时间序列建模Transformers：</p>
<p><img src="/2022/04/18/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/13.png" alt="image-20220322162918132"></p>
<h4 id="位置编码">位置编码</h4>
<p>Vanilla Positional Encoding：该编码可以从时间序列中提取一些位置信息，但它们不能充分利用时间序列数据的重要特征。</p>
<p>Learnable Positional Encoding：从时间序列中学习适当的位置编码</p>
<p>Timestamp Encoding：使用数据对应的现实时间戳信息</p>
<h4 id="自注意力机制">自注意力机制</h4>
<p>在神经网络模型处理大量输入信息的过程中，利用注意力机制，可以做到只选择一些关键的的输入信息进行处理，来<strong>提高神经网络的效率</strong>。自注意力机制是注意力机制的变体，其<strong>减少了对外部信息的依赖，更擅长捕捉数据或特征的内部相关性</strong>。Transformer的核心是自注意力机制。它可以看作是一个全连通层，其权值是根据输入的两两相似度动态生成的。因此，它与全连接层共享相同的最大路径长度，但参数量要少得多，这使得它适合于建模长期依赖关系。</p>
<h4 id="参考-11">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/265108616">Attention注意力机制与self-attention自注意力机制</a>、Wen Q, Zhou T, Zhang C, et al. Transformers in Time Series: A Survey[J]. arXiv preprint arXiv:2202.07125, 2022.</p>
]]></content>
      <tags>
        <tag>Knowledge summary</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择策略总结</title>
    <url>/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/507101225">https://zhuanlan.zhihu.com/p/507101225</a></p>
<h2 id="特征选择">特征选择</h2>
<p>太多的特征会增加模型的复杂性和过拟合，而太少的特征会导致模型的拟合不足。将模型优化为足够复杂以使其性能可推广，但又足够简单易于训练、维护和解释是特征选择的主要工作。“特征选择”意味着可以保留一些特征并放弃其他一些特征。本文的目的是概述一些特征选择策略：</p>
<ol>
<li>删除未使用的列</li>
<li>删除具有缺失值的列</li>
<li>不相关的特征</li>
<li>低方差特征</li>
<li>多重共线性</li>
<li>特征系数</li>
<li>p 值</li>
<li>方差膨胀因子 (VIF)</li>
<li>基于特征重要性的特征选择</li>
<li>使用 sci-kit learn 进行自动特征选择</li>
<li>主成分分析 (PCA)</li>
</ol>
<h2 id="数据集">数据集</h2>
<p>为了更好的展示各个特征选择策略的结果，下面使用的数据集是来自 PyCaret（一个开源的低代码机器学习库）。数据集相当干净，但做了一些预处理。</p>
<p>加载数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = <span class="string">&#x27;https://raw.githubusercontent.com/pycaret/pycaret/master/datasets/automobile.csv&#x27;</span> </span><br><span class="line">df = pd.read_csv(data) </span><br><span class="line"> </span><br><span class="line">df.sample(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/1.png" alt="image-20220520093922825"></p>
<p>该数据集包含 202 行和 26 列——每行代表一个汽车实例，每列代表其特征和相应的价格。 这些列包括：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Index([<span class="string">&#x27;symboling&#x27;</span>, <span class="string">&#x27;normalized-losses&#x27;</span>, <span class="string">&#x27;make&#x27;</span>, <span class="string">&#x27;fuel-type&#x27;</span>, <span class="string">&#x27;aspiration&#x27;</span>, <span class="string">&#x27;num-of-doors&#x27;</span>, <span class="string">&#x27;body-style&#x27;</span>, <span class="string">&#x27;drive-wheels&#x27;</span>, <span class="string">&#x27;engine-location&#x27;</span>,<span class="string">&#x27;wheel-base&#x27;</span>, <span class="string">&#x27;length&#x27;</span>, <span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;curb-weight&#x27;</span>, <span class="string">&#x27;engine-type&#x27;</span>, <span class="string">&#x27;num-of-cylinders&#x27;</span>, <span class="string">&#x27;engine-size&#x27;</span>, <span class="string">&#x27;fuel-system&#x27;</span>, <span class="string">&#x27;bore&#x27;</span>, <span class="string">&#x27;stroke&#x27;</span>, <span class="string">&#x27;compression-ratio&#x27;</span>, <span class="string">&#x27;horsepower&#x27;</span>, <span class="string">&#x27;peak-rpm&#x27;</span>, <span class="string">&#x27;city-mpg&#x27;</span>, <span class="string">&#x27;highway-mpg&#x27;</span>, <span class="string">&#x27;price&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在让我们深入研究特征选择的 11 种策略。</p>
<h2 id="实现模型之前">实现模型之前</h2>
<h3 id="删除未使用的列">删除未使用的列</h3>
<p>通过一定的先验知识，可以判别出某些列在最终模型中不会以任何形式使用（例如“ID”、“FirstName”、“LastName”等列）。 如果有这样某个特定列将不会被使用，请随时将其删除。</p>
<p>在上述的数据集中，没有发现这样一列有这样的问题，所以这里不删除任何列。</p>
<h3 id="删除具有缺失值的列">删除具有缺失值的列</h3>
<p>缺失值会给后续的分析、处理带来很大的困扰，因此需采用不同的策略来清理缺失数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># total null values per column </span></span><br><span class="line">df.isnull().<span class="built_in">sum</span>() </span><br><span class="line"> </span><br><span class="line">&gt;&gt; </span><br><span class="line">symboling             <span class="number">0</span> </span><br><span class="line">normalized-losses    <span class="number">37</span> </span><br><span class="line">make                  <span class="number">0</span> </span><br><span class="line">fuel-<span class="built_in">type</span>             <span class="number">0</span> </span><br><span class="line">aspiration            <span class="number">0</span> </span><br><span class="line">num-of-doors          <span class="number">2</span> </span><br><span class="line">body-style            <span class="number">0</span> </span><br><span class="line">drive-wheels          <span class="number">0</span> </span><br><span class="line">engine-location       <span class="number">0</span> </span><br><span class="line">wheel-base            <span class="number">0</span> </span><br><span class="line">length                <span class="number">0</span> </span><br><span class="line">width                 <span class="number">0</span> </span><br><span class="line">height                <span class="number">0</span> </span><br><span class="line">curb-weight           <span class="number">0</span> </span><br><span class="line">engine-<span class="built_in">type</span>           <span class="number">0</span> </span><br><span class="line">num-of-cylinders      <span class="number">0</span> </span><br><span class="line">engine-size           <span class="number">0</span> </span><br><span class="line">fuel-system           <span class="number">0</span> </span><br><span class="line">bore                  <span class="number">0</span> </span><br><span class="line">stroke                <span class="number">0</span> </span><br><span class="line">compression-ratio     <span class="number">0</span> </span><br><span class="line">horsepower            <span class="number">0</span> </span><br><span class="line">peak-rpm              <span class="number">0</span> </span><br><span class="line">city-mpg              <span class="number">0</span> </span><br><span class="line">highway-mpg           <span class="number">0</span> </span><br><span class="line">price                 <span class="number">0</span> </span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>1、如果列中缺少大量数据，那么完全删除它是非常好的方法。如这里数据集里面的‘ normalized-losses ’这一列，缺失率达到了17%，那么删除它可能是一个好的选择。</p>
<p>2、如果列中缺少少量数据，那么可以采用插补的方法。如这里数据集里面的‘ num-of-doors ’ 。插补的方法一般有个案剔除法（直接删除有缺失值这一条数据）、均值替换法（用全局或附近数据的均值来替换均值）、附近替换法（直接用附近某一条数据的值来替换缺失值）。</p>
<h3 id="不相关的特征">不相关的特征</h3>
<p>无论模型处理的是回归问题（预测数字）还是分类问题（预测类别），输入特征都需要与目标值具有相关性。 如果一个特征没有表现出相关性，它就是一个主要的消除目标。 对于数值特征和分类特征可以分别进行相关性测试。</p>
<h4 id="数值变量">数值变量</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># correlation between target and features </span></span><br><span class="line">(df.corr().loc[<span class="string">&#x27;price&#x27;</span>] </span><br><span class="line"> .plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">4</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/2.png" alt="img"></p>
<p>在此示例中，<em>peak-rpm</em>, <em>compression-ratio, stroke, bore</em> , <em>symboling</em> 等特征与价格几乎没有相关性，因此可以删除它们。</p>
<p>可以手动删除列，也可以使用相关阈值进行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># drop uncorrelated numeric features (threshold &lt;0.2) </span></span><br><span class="line">corr = <span class="built_in">abs</span>(df.corr().loc[<span class="string">&#x27;price&#x27;</span>]) </span><br><span class="line">corr = corr[corr&lt;<span class="number">0.2</span>] </span><br><span class="line">cols_to_drop = corr.index.to_list() </span><br><span class="line">df = df.drop(cols_to_drop, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="分类变量">分类变量</h4>
<p>可以使用箱线图查找目标和分类特征之间的相关性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns </span><br><span class="line"> </span><br><span class="line">sns.boxplot(y = <span class="string">&#x27;price&#x27;</span>, x = <span class="string">&#x27;fuel-type&#x27;</span>, data=df)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/3.png" alt="img"></p>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/4.png" alt="img"></p>
<p>柴油车的中位价高于汽油车。 这意味着这个分类变量可以解释汽车价格，所以整个特征是具有相关性的。从第二个箱线图也可以看出普通吸入方式和涡轮增压两个对于汽车价格也具有相关性。</p>
<h3 id="低方差特征">低方差特征</h3>
<p>检查一下各个特征的差异：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># variance of numeric features </span></span><br><span class="line">(df </span><br><span class="line"> .select_dtypes(include=np.number) </span><br><span class="line"> .var() </span><br><span class="line"> .astype(<span class="string">&#x27;str&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/5.png" alt="image-20220520101044816"></p>
<p>这里的“symboling”具有极低的方差，虽然这是删除的候选者， 在这个数据集中，因为它的值在-2和3之间，因此方差很低:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;symboling&#x27;</span>].describe()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/6.png" alt="image-20220520101329463"></p>
<p>另两个特征“height”和“width”，他们的方差都不高，而且他们的取值也很大，所以可以删除这两个特征。</p>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/8.png" alt="image-20220520101845865"><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/7.png" alt="image-20220520101830675"></p>
<h3 id="多重共线性">多重共线性</h3>
<p>当任何两个特征之间存在相关性时，就会出现多重共线性。 在机器学习中，期望每个特征都应该独立于其他特征，即它们之间没有共线性。 如高马力车辆往往具有高发动机尺寸。 所以你可能想消除其中一个，让另一个决定目标变量——价格。</p>
<p>我们可以分别测试数字和分类特征的多重共线性：</p>
<h4 id="数值变量-2">数值变量</h4>
<p>Heatmap 是检查和寻找相关特征的最简单方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"> </span><br><span class="line">sns.<span class="built_in">set</span>(rc=&#123;<span class="string">&#x27;figure.figsize&#x27;</span>:(<span class="number">16</span>,<span class="number">10</span>)&#125;) </span><br><span class="line">sns.heatmap(df.corr(), </span><br><span class="line">            annot=<span class="literal">True</span>, </span><br><span class="line">            linewidths=<span class="number">.5</span>, </span><br><span class="line">            center=<span class="number">0</span>, </span><br><span class="line">            cbar=<span class="literal">False</span>, </span><br><span class="line">            cmap=<span class="string">&quot;PiYG&quot;</span>) </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/9.png" alt="img"></p>
<p>大多数特征在某种程度上相互关联，但有些特征具有非常高的相关性，例如长度与轴距以及发动机尺寸与马力。</p>
<p>可以根据相关阈值手动或以编程方式删除这些功能。 我将手动删除具有 0.80 共线性阈值的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># drop correlated features </span></span><br><span class="line">df = df.drop([<span class="string">&#x27;length&#x27;</span>, <span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;curb-weight&#x27;</span>, <span class="string">&#x27;engine-size&#x27;</span>, <span class="string">&#x27;city-mpg&#x27;</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>还可以使用称为方差膨胀因子 (VIF) 的方法来确定多重共线性并根据高 VIF 值删除特征。</p>
<h4 id="分类变量-2">分类变量</h4>
<p>检查分类变量之间的共线性，诸如独立性卡方检验之类的统计检验。</p>
<p>检查一下数据集中的两个分类列——燃料类型和车身风格——是独立的还是相关的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_cat = df[[<span class="string">&#x27;fuel-type&#x27;</span>, <span class="string">&#x27;body-style&#x27;</span>]] </span><br><span class="line">df_cat.sample(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/10.png" alt="image-20220520103040597"></p>
<p>然后在每一列中创建一个类别的交叉表/列联表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crosstab = pd.crosstab(df_cat[<span class="string">&#x27;fuel-type&#x27;</span>], df_cat[<span class="string">&#x27;body-style&#x27;</span>]) </span><br><span class="line">crosstab</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/11.png" alt="image-20220520103157014"></p>
<p>最后在交叉表上运行卡方检验，其结果将说明这两个特征是否独立。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2_contingency </span><br><span class="line"> </span><br><span class="line">chi2_contingency(crosstab)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/12.png" alt="image-20220520103313909"></p>
<p>输出依次是卡方值、p 值、自由度和预期频率数组。</p>
<p>因为 p 值 &lt;0.05，因此可以拒绝特征之间没有关联的原假设，即两个特征之间存在统计上的显著关系。由于这两个特征之间存在关联，可以选择删除其中一个。</p>
<h2 id="实现模型之后">实现模型之后</h2>
<p>到目前为止已经展示了在实现模型之前应用的特征选择策略。 这些策略在第一轮特征选择以建立初始模型时很有用。 但是一旦构建了模型，就可以获得有关模型性能中每个特征的适应度的更多信息。 根据这些新信息，可以进一步确定要保留哪些功能。</p>
<p>下面使用最简单的线性模型展示其中的一些方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># drop columns with missing values </span></span><br><span class="line">df = df.dropna() </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split </span><br><span class="line"><span class="comment"># get dummies for categorical features </span></span><br><span class="line">df = pd.get_dummies(df, drop_first=<span class="literal">True</span>) </span><br><span class="line"><span class="comment"># X features </span></span><br><span class="line">X = df.drop(<span class="string">&#x27;price&#x27;</span>, axis=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># y target </span></span><br><span class="line">y = df[<span class="string">&#x27;price&#x27;</span>] </span><br><span class="line"><span class="comment"># split data into training and testing set </span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression </span><br><span class="line"><span class="comment"># scaling </span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler </span><br><span class="line">scaler = StandardScaler() </span><br><span class="line">X_train = scaler.fit_transform(X_train) </span><br><span class="line">X_test = scaler.fit_transform(X_test) </span><br><span class="line"><span class="comment"># convert back to dataframe </span></span><br><span class="line">X_train = pd.DataFrame(X_train, columns = X.columns.to_list()) </span><br><span class="line">X_test = pd.DataFrame(X_test, columns = X.columns.to_list()) </span><br><span class="line"><span class="comment"># instantiate model </span></span><br><span class="line">model = LinearRegression()<span class="comment"># fit </span></span><br><span class="line">model.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>现在已经拟合了模型，下面进行另一轮特征选择。</p>
<h3 id="特征系数">特征系数</h3>
<p>如果正在运行回归任务，则特征适应度的一个关键指标是回归系数（所谓的 beta 系数），它显示了模型中特征的相对贡献。 有了这些信息，可以删除贡献很小或没有贡献的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># feature coefficients </span></span><br><span class="line">coeffs = model.coef_ </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualizing coefficients </span></span><br><span class="line">index = X_train.columns.tolist() </span><br><span class="line"> </span><br><span class="line">(pd.DataFrame(coeffs, index = index, columns = [<span class="string">&#x27;coeff&#x27;</span>]).sort_values(by = <span class="string">&#x27;coeff&#x27;</span>) </span><br><span class="line"> .plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">4</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/13.png" alt="img"></p>
<p>某些特征beta 系数很小，对汽车价格的预测贡献不大。 可以过滤掉这些特征：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter variables near zero coefficient value </span></span><br><span class="line">temp = pd.DataFrame(coeffs, index = index, columns = [<span class="string">&#x27;coeff&#x27;</span>]).sort_values(by = <span class="string">&#x27;coeff&#x27;</span>) </span><br><span class="line">temp = temp[(temp[<span class="string">&#x27;coeff&#x27;</span>]&gt;<span class="number">1</span>) | (temp[<span class="string">&#x27;coeff&#x27;</span>]&lt; -<span class="number">1</span>)] </span><br><span class="line"> </span><br><span class="line"><span class="comment"># drop those features </span></span><br><span class="line">cols_coeff = temp.index.to_list() </span><br><span class="line">X_train = X_train[cols_coeff] </span><br><span class="line">X_test = X_test[cols_coeff]</span><br></pre></td></tr></table></figure>
<h3 id="p-值">p 值</h3>
<p>在回归任务中，p 值告诉我们预测变量和目标之间的关系是否具有统计显著性。 statsmodels 库提供了带有特征系数和相关 p 值的回归输出的函数。</p>
<p>如果某些特征不显著，可以将它们一个一个移除，然后每次重新运行模型，直到找到一组具有显著 p 值的特征，并通过更高的调整 R2 提高性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm </span><br><span class="line">ols = sm.OLS(y, X).fit() </span><br><span class="line"><span class="built_in">print</span>(ols.summary())</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/14.png" alt="image-20220520104330245"></p>
<p>如上面的“curb-weight”特征的 p 值只有0.001，可以删除。</p>
<h3 id="方差膨胀因子-VIF">方差膨胀因子 (VIF)</h3>
<p>方差膨胀因子 (VIF) 是衡量多重共线性的另一种方法。 它定义为整体模型方差与每个独立特征的方差的比率。 一个特征的高 VIF 表明它与一个或多个其他特征相关。 根据经验：</p>
<ul>
<li>VIF = 1 表示无相关性</li>
<li>VIF = 1-5 中等相关性</li>
<li>VIF &gt; 5 高相关</li>
</ul>
<p>VIF 是一种消除多重共线性特征的有用技术。 这里将所有 VIF 高于10的删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.stats.outliers_influence <span class="keyword">import</span> variance_inflation_factor </span><br><span class="line"> </span><br><span class="line"><span class="comment"># calculate VIF </span></span><br><span class="line">vif = pd.Series([variance_inflation_factor(X.values, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">1</span>])], index=X.columns) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># display VIFs in a table </span></span><br><span class="line">index = X_train.columns.tolist() </span><br><span class="line">vif_df = pd.DataFrame(vif, index = index, columns = [<span class="string">&#x27;vif&#x27;</span>]).sort_values(by = <span class="string">&#x27;vif&#x27;</span>, ascending=<span class="literal">False</span>) </span><br><span class="line">vif_df[vif_df[<span class="string">&#x27;vif&#x27;</span>]&lt;<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/15.png" alt="image-20220520104823147"></p>
<h3 id="基于特征重要性选择">基于特征重要性选择</h3>
<p>决策树/随机森林使用一个特征来分割数据，该特征最大程度地减少了杂质(以基尼系数杂质或信息增益衡量)。 找到最佳特征是算法如何在分类任务中工作的关键部分。 我们可以通过 feature_importances_ 属性访问最好的特征。</p>
<p>让我们在我们的数据集上实现一个随机森林模型并过滤一些特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier </span><br><span class="line"> </span><br><span class="line"><span class="comment"># instantiate model </span></span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">200</span>, random_state=<span class="number">0</span>) </span><br><span class="line"><span class="comment"># fit model </span></span><br><span class="line">model.fit(X,y)</span><br></pre></td></tr></table></figure>
<p>现在让我们看看特征重要性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  feature importance </span></span><br><span class="line">importances = model.feature_importances_ </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualization </span></span><br><span class="line">cols = X.columns </span><br><span class="line">(pd.DataFrame(importances, cols, columns = [<span class="string">&#x27;importance&#x27;</span>]) </span><br><span class="line"> .sort_values(by=<span class="string">&#x27;importance&#x27;</span>, ascending=<span class="literal">True</span>) </span><br><span class="line"> .plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">4</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/16.png" alt="img"></p>
<p>上面的输出显示了每个特征在减少每个节点/拆分处的重要性。</p>
<p>由于随机森林分类器有很多估计量（例如上面例子中的 200 棵决策树），可以用置信区间计算相对重要性的估计值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate standard deviation of feature importances  </span></span><br><span class="line">std = np.std([i.feature_importances_ <span class="keyword">for</span> i <span class="keyword">in</span> model.estimators_], axis=<span class="number">0</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualization </span></span><br><span class="line">feat_with_importance  = pd.Series(importances, X.columns) </span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">5</span>)) </span><br><span class="line">feat_with_importance.plot.bar(yerr=std, ax=ax) </span><br><span class="line">ax.set_title(<span class="string">&quot;Feature importances&quot;</span>) </span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Mean decrease in impurity&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/17.png" alt="img"></p>
<p>现在我们知道了每个特征的重要性，可以手动或以编程方式确定保留哪些特征以及删除哪些特征。</p>
<h3 id="使用-Scikit-Learn-自动选择特征">使用 Scikit Learn 自动选择特征</h3>
<p>sklearn 库中有一个完整的模块，只需几行代码即可处理特征选择。</p>
<p>sklearn 中有许多自动化流程，但这里只展示一些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import modules </span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> (SelectKBest, chi2, SelectPercentile, SelectFromModel, SequentialFeatureSelector, SequentialFeatureSelector)</span><br></pre></td></tr></table></figure>
<h4 id="基于卡方的技术">基于卡方的技术</h4>
<p>基于卡方的技术根据一些预定义的分数选择特定数量的用户定义特征 (k)。 这些分数是通过计算 X（独立）和 y（因）变量之间的卡方统计量来确定的。 在 sklearn 中，需要做的就是确定要保留多少特征。 如果想保留 10 个功能，实现将如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># select K best features </span></span><br><span class="line">X_best = SelectKBest(chi2, k=<span class="number">10</span>).fit_transform(X,y) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># number of best features </span></span><br><span class="line">X_best.shape[<span class="number">1</span>] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>如果有大量特征，可以指定要保留的特征百分比。 假设我们想要保留 75% 的特征并丢弃剩余的 25%：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keep 75% top features  </span></span><br><span class="line">X_top = SelectPercentile(chi2, percentile = <span class="number">75</span>).fit_transform(X,y) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># number of best features </span></span><br><span class="line">X_top.shape[<span class="number">1</span>] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; <span class="number">36</span></span><br></pre></td></tr></table></figure>
<h4 id="正则化">正则化</h4>
<p>正则化减少了过拟合。 如果有太多的特征，正则化控制它们的效果，或者通过缩小特征系数（称为 L2 正则化）或将一些特征系数设置为零（称为 L1 正则化）。</p>
<p>一些模型具有内置的 L1/L2 正则化作为超参数来惩罚特征。 可以使用转换器 SelectFromModel 消除这些特征。</p>
<p>下面实现一个带有惩罚 = ‘l1’ 的 LinearSVC 算法。 然后使用 SelectFromModel 删除一些特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># implement algorithm </span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC </span><br><span class="line">model = LinearSVC(penalty= <span class="string">&#x27;l1&#x27;</span>, C = <span class="number">0.002</span>, dual=<span class="literal">False</span>) </span><br><span class="line">model.fit(X,y) </span><br><span class="line"><span class="comment"># select features using the meta transformer </span></span><br><span class="line">selector = SelectFromModel(estimator = model, prefit=<span class="literal">True</span>) </span><br><span class="line"> </span><br><span class="line">X_new = selector.transform(X) </span><br><span class="line">X_new.shape[<span class="number">1</span>] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; <span class="number">2</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># names of selected features </span></span><br><span class="line">feature_names = np.array(X.columns) </span><br><span class="line">feature_names[selector.get_support()] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; array([<span class="string">&#x27;wheel-base&#x27;</span>, <span class="string">&#x27;horsepower&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<h4 id="序贯法">序贯法</h4>
<p>序贯法是一种经典的统计技术。 在这种情况下一次添加/删除一个功能并检查模型性能，直到它针对需求进行优化。</p>
<p>序贯法有两种变体。 前向选择技术从 0 特征开始，然后添加一个最大程度地减少错误的特征； 然后添加另一个特征，依此类推。</p>
<p>向后选择在相反的方向上起作用。 模型从包含的所有特征开始并计算误差； 然后它消除了一个可以进一步减少误差的特征。 重复该过程，直到保留所需数量的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># instantiate model </span></span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">0</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># select features </span></span><br><span class="line">selector = SequentialFeatureSelector(estimator=model, n_features_to_select=<span class="number">10</span>, direction=<span class="string">&#x27;backward&#x27;</span>, cv=<span class="number">2</span>) </span><br><span class="line">selector.fit_transform(X,y) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># check names of features selected </span></span><br><span class="line">feature_names = np.array(X.columns) </span><br><span class="line">feature_names[selector.get_support()] </span><br><span class="line"> </span><br><span class="line">&gt;&gt; array([<span class="string">&#x27;bore&#x27;</span>, <span class="string">&#x27;make_mitsubishi&#x27;</span>, <span class="string">&#x27;make_nissan&#x27;</span>, <span class="string">&#x27;make_saab&#x27;</span>, </span><br><span class="line">       <span class="string">&#x27;aspiration_turbo&#x27;</span>, <span class="string">&#x27;num-of-doors_two&#x27;</span>, <span class="string">&#x27;body style_hatchback&#x27;</span>, <span class="string">&#x27;engine-type_ohc&#x27;</span>, <span class="string">&#x27;num-of-cylinders_twelve&#x27;</span>, <span class="string">&#x27;fuel-system_spdi&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<h3 id="主成分分析-PCA">主成分分析 (PCA)</h3>
<p>PCA的主要目的是降低高维特征空间的维数。原始特征被重新投影到新的维度（即主成分）。 最终目标是找到最能解释数据方差的特征数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import PCA module </span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA </span><br><span class="line"><span class="comment"># scaling data </span></span><br><span class="line">X_scaled = scaler.fit_transform(X) </span><br><span class="line"><span class="comment"># fit PCA to data </span></span><br><span class="line">pca = PCA() </span><br><span class="line">pca.fit(X_scaled) </span><br><span class="line">evr = pca.explained_variance_ratio_ </span><br><span class="line"> </span><br><span class="line"><span class="comment"># visualizing the variance explained by each principal components </span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>)) </span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(evr)), evr.cumsum(), marker=<span class="string">&quot;o&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>) </span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of components&quot;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&quot;Cumulative explained variance&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/18.png" alt="img"></p>
<p>20 个主成分解释了超过 80% 的方差，因此可以将模型拟合到这 20 个成分（特征）。 可以预先确定方差阈值并选择所需的主成分数量。</p>
]]></content>
      <tags>
        <tag>Knowledge summary</tag>
      </tags>
  </entry>
</search>
